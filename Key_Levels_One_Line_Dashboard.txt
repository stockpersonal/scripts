//@version=5
indicator("Key Levels Dashboard", overlay=true, max_labels_count=500, max_bars_back=3000)

// ═══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ═══════════════════════════════════════════════════════════════════════════════

// Level Settings - Controls key level calculation and validation
i_tf              = input.string("D", "Key Level Base TF", options=["D", "W", "M"], group="Level Settings")
i_lookback_months = input.int(18, "Lookback (Months)", minval=1, maxval=120, group="Level Settings")
i_bars_hold       = input.int(2, "Bars Level Must Hold", minval=1, maxval=10, group="Level Settings")
i_persist_holds   = input.bool(true, "Persist Holds Across HTF Bars", group="Level Settings")

i_zz_depth        = input.int(8, "ZigZag Pivot Depth", minval=3, maxval=20, group="Elliott Wave")
i_min_retr_w2     = input.float(0.30, "Min W2 Retrace", minval=0.1, maxval=0.9, step=0.01, group="Elliott Wave")
i_max_retr_w2     = input.float(0.90, "Max W2 Retrace", minval=0.5, maxval=1.0, step=0.01, group="Elliott Wave")
i_min_ext_w3      = input.float(0.80, "Min W3 Extension", minval=0.5, maxval=2.0, step=0.01, group="Elliott Wave")
i_ew_max_age      = input.int(10, "Max EW Pattern Age (HTF bars)", minval=3, maxval=30, group="Elliott Wave")

i_atr_len         = input.int(14, "ATR Length", minval=5, maxval=50, group="ATR")
i_atr_mult        = input.float(0.236, "ATR Trigger %", minval=0.1, maxval=1.0, step=0.01, group="ATR")

i_buffer_atr      = input.float(0.25, "Alert Buffer (ATR %)", minval=0.05, maxval=1.0, step=0.05, group="Alerts & Display", tooltip="Buffer as percentage of ATR for near-level detection")
i_min_breakout    = input.float(0.15, "Min Breakout (ATR %)", minval=0.05, maxval=0.5, step=0.05, group="Alerts & Display", tooltip="Minimum penetration required for valid breakout")
i_show_ew_fib     = input.bool(true, "Show EW & Fib in Dashboard", group="Alerts & Display")
i_use_options_lbl = input.bool(true, "Use Options Labels", group="Alerts & Display")

// ═══════════════════════════════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════════

// Formatting and Limits
FMT = "#.##"
MAX_HIST = 3000
MAX_PIVS = 50

// Elliott Wave State Constants
EW_NONE    = 0
EW_ACTIVE  = 1
EW_WAITING = 2

// Direction Constants
DIR_NONE  = 0
DIR_UP    = 1
DIR_DOWN  = 2


// Color Constants
CLR_BULL   = color.rgb(0, 180, 80)
CLR_BEAR   = color.rgb(200, 50, 50)
CLR_CHOP   = color.rgb(255, 165, 0)
CLR_HEADER = color.rgb(255, 140, 0)
CLR_LEVEL  = color.rgb(0, 150, 70)
CLR_TARGET = color.rgb(0, 120, 200)
CLR_ATR    = color.rgb(120, 70, 160)
CLR_EW     = color.rgb(40, 80, 120)
CLR_FIB    = color.rgb(20, 60, 120)
CLR_EXT    = color.rgb(0, 140, 150)
CLR_GRAY   = color.rgb(80, 80, 80)

// ═══════════════════════════════════════════════════════════════════════════════
// VARIABLES
// ═══════════════════════════════════════════════════════════════════════════════

// ZigZag Pivot Arrays - Stores pivot values, types, and bar indices
var float[] piv_val  = array.new_float()
var int[]   piv_type = array.new_int()
var int[]   piv_bar  = array.new_int()
var int     pivs_since_last_ew_scan = 0
var int     htf_bars_since_pivot = 999
var int     last_piv_dir = na
var int     last_piv_bar_index = na

// ZigZag Structure Arrays - Locked highs/lows for structure analysis
var float[] zz_highs_lock = array.new_float()
var float[] zz_lows_lock  = array.new_float()
var string  zz_structure = "N/A"
var color   zz_struct_clr = CLR_CHOP
var float   zz_last_val = na
var string  zz_last_type = "N/A"
var int     zz_last_age = na
var bool    zz_dirty = false

// Key Levels - Calculated support/resistance levels (L1, L2, L3)
var float L1 = na
var float L2 = na
var float L3 = na
var int   hold_L1 = 0
var int   hold_L2 = 0
var int   hold_L3 = 0
var float L1_lock = na
var float L2_lock = na
var float L3_lock = na
var bool  levels_valid = false
var float[] lvl_arr = array.new_float(3)
var int    last_htf_trend = DIR_NONE

// Elliott Wave State Variables
var int    ew_state = EW_NONE
var int    ew_dir = DIR_NONE
var float  ew_w0 = na
var float  ew_w1 = na
var float  ew_w2 = na
var float  ew_w3 = na
var float  ew_w4 = na
var float  ew_invalid = na
var int    ew_age = 0

// Fibonacci and Extension Levels - Calculated from Elliott Wave patterns
var float  fib_50 = na
var float  fib_618 = na
var float  fib_786 = na
var float  ext_127 = na
var float  ext_162 = na
var float  ext_200 = na

// Target Levels - Fibonacci extension targets (T1, T2, T3)
var float T1 = na
var float T2 = na
var float T3 = na
var bool  targets_locked = false
var float T1_lock = na
var float T2_lock = na
var float T3_lock = na


// Dashboard Display Variables
var table tbl = table.new(position.bottom_right, 1, 19, border_width=1)
var bool  dashboard_initialized = false

// Dashboard State Cache - Tracks previous values to minimize redraws
var string prev_rdy_txt = ""
var string prev_trend = ""
var string prev_levels = ""
var string prev_targets = ""
var string prev_zz_struct = ""
var string prev_zz_last = ""
var string prev_zz_highs = ""
var string prev_zz_lows = ""
var string prev_atr_txt = ""
var string prev_atr_trig = ""
var string prev_risk = ""
var string prev_ew_txt = ""
var string prev_fib_txt = ""
var string prev_ext_txt = ""
var bool   prev_buy_dip = false
var bool   prev_bull_burst = false
var bool   prev_bear_burst = false
var string prev_conf_txt = ""

// ═══════════════════════════════════════════════════════════════════════════════
// FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

// Converts timeframe string to seconds
f_tf_seconds(tf) =>
    tf == "D" ? 86400 : tf == "W" ? 604800 : tf == "M" ? 2592000 : na

// Checks if EW pivot is expired based on bar index difference
f_is_ew_expired(pivot_bar_index_val, htf_bar_index_val, max_age) =>
    if na(pivot_bar_index_val) or na(htf_bar_index_val)
        false
    else
        htf_bar_index_val - pivot_bar_index_val > max_age

// Detects Elliott Wave patterns with strict validation. Returns: [found, direction, w0, w1, w2, w3, w4, invalid_level]
// Note: piv_bar stores HTF bar_index values for accurate age calculation
f_detect_ew_strict(piv_val, piv_type, piv_bar, chop, min_retr_w2, max_retr_w2, min_ext_w3, htf_bar_index_val, max_age) =>
    bool   _found   = false
    int    _dir     = DIR_NONE
    float  _w0      = na
    float  _w1      = na
    float  _w2      = na
    float  _w3      = na
    float  _w4      = na
    float  _invalid = na

    if not chop
        n = array.size(piv_val)
        if n >= 5
            // Limit scan to most recent 10 patterns for better performance
            for ix = math.max(n - 10, 0) to n - 5
                if ix + 4 >= n
                    continue
                
                // Clamp EW scan range by pivot age
                // piv_bar stores HTF bar_index values for accurate age calculation
                pivot_bar_index = array.get(piv_bar, ix)
                if f_is_ew_expired(pivot_bar_index, htf_bar_index_val, max_age)
                    continue

                v0 = array.get(piv_val, ix)
                v1 = array.get(piv_val, ix + 1)
                v2 = array.get(piv_val, ix + 2)
                v3 = array.get(piv_val, ix + 3)
                v4 = array.get(piv_val, ix + 4)

                t0 = array.get(piv_type, ix)
                t1 = array.get(piv_type, ix + 1)
                t2 = array.get(piv_type, ix + 2)
                t3 = array.get(piv_type, ix + 3)
                t4 = array.get(piv_type, ix + 4)

                if t0 == 0 and t1 == 1 and t2 == 0 and t3 == 1 and t4 == 0
                    w1 = v1 - v0
                    w2 = v1 - v2
                    w3 = v3 - v2

                    r2 = w1 != 0 ? w2 / w1 : 0
                    x3 = w1 != 0 ? w3 / w1 : 0

                    cond1 = r2 >= min_retr_w2
                    cond2 = r2 <= max_retr_w2
                    cond3 = x3 >= min_ext_w3
                    cond4 = w3 > w1 * 0.9
                    cond5 = v4 > v1
                    cond6 = v4 > v0
                    valid = cond1 and cond2 and cond3 and cond4 and cond5 and cond6

                    if valid
                        _found   := true
                        _dir     := DIR_UP
                        _w0      := v0
                        _w1      := v1
                        _w2      := v2
                        _w3      := v3
                        _w4      := v4
                        _invalid := math.min(v0, v2)
                        break

                if t0 == 1 and t1 == 0 and t2 == 1 and t3 == 0 and t4 == 1
                    w1 = v0 - v1
                    w2 = v2 - v1
                    w3 = v2 - v3

                    r2 = w1 != 0 ? w2 / w1 : 0
                    x3 = w1 != 0 ? w3 / w1 : 0

                    cond1 = r2 >= min_retr_w2
                    cond2 = r2 <= max_retr_w2
                    cond3 = x3 >= min_ext_w3
                    cond4 = w3 > w1 * 0.9
                    cond5 = v4 < v1
                    cond6 = v4 < v0
                    valid = cond1 and cond2 and cond3 and cond4 and cond5 and cond6

                    if valid
                        _found   := true
                        _dir     := DIR_DOWN
                        _w0      := v0
                        _w1      := v1
                        _w2      := v2
                        _w3      := v3
                        _w4      := v4
                        _invalid := math.max(v0, v2)
                        break

    [_found, _dir, _w0, _w1, _w2, _w3, _w4, _invalid]

// Formats an array of floats into a pipe-separated string
f_fmt_list(arr) =>
    if array.size(arr) == 0
        "N/A"
    else
        string s = ""
        for i = 0 to array.size(arr) - 1
            s += (i > 0 ? " | " : "") + str.tostring(array.get(arr, i), FMT)
        s

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN LOGIC
// ═══════════════════════════════════════════════════════════════════════════════

// ───────────────────────────────────────────────────────────────────────────────
// Higher Timeframe Data Request
// ───────────────────────────────────────────────────────────────────────────────
bars_lb = math.min(i_lookback_months * 21, MAX_HIST)
[htf_h, htf_l, htf_c, htf_rng_h, htf_rng_l, htf_atr, htf_time, htf_bar_index] = request.security(syminfo.tickerid, i_tf, [high, low, close, ta.highest(high, bars_lb), ta.lowest(low, bars_lb), ta.atr(i_atr_len), time, bar_index], barmerge.gaps_off, barmerge.lookahead_off)
[htf_e8, htf_e21, htf_e34] = request.security(syminfo.tickerid, i_tf, [ta.ema(close, 8), ta.ema(close, 21), ta.ema(close, 34)],  barmerge.gaps_off, barmerge.lookahead_off)
new_htf_close = barstate.isconfirmed and timeframe.change(i_tf)

// ───────────────────────────────────────────────────────────────────────────────
// ZigZag Pivot Detection
// ───────────────────────────────────────────────────────────────────────────────
htf_piv_h = ta.pivothigh(htf_h, i_zz_depth, i_zz_depth)
htf_piv_l = ta.pivotlow(htf_l, i_zz_depth, i_zz_depth)

// ───────────────────────────────────────────────────────────────────────────────
// Technical Indicators
// ───────────────────────────────────────────────────────────────────────────────
e8  = ta.ema(close, 8)
e21 = ta.ema(close, 21)
e34 = ta.ema(close, 34)
atr = ta.atr(i_atr_len)

atr_buffer = htf_atr * i_buffer_atr
atr_min_break = htf_atr * i_min_breakout

// ───────────────────────────────────────────────────────────────────────────────
// Trend Detection
// ───────────────────────────────────────────────────────────────────────────────
bull = close >= e8 and e8 >= e21 and e21 >= e34
bear = close <= e8 and e8 <= e21 and e21 <= e34
chop = not bull and not bear

htf_bull = htf_c >= htf_e8 and htf_e8 >= htf_e21 and htf_e21 >= htf_e34
htf_bear = htf_c <= htf_e8 and htf_e8 <= htf_e21 and htf_e21 <= htf_e34

t_clr = bull ? CLR_BULL : bear ? CLR_BEAR : CLR_CHOP
t_dir = bull ? "BULL" : bear ? "BEAR" : "CHOP"

spread = atr > 0 ? math.abs(e8 - e34) / atr : 0
t_type = "CHOPPY"
if not chop
    if spread >= 1.0
        t_type := "POWER"
    else if spread >= 0.6
        t_type := "MOMENTUM"
    else if spread >= 0.3
        t_type := "NORMAL"

t_risk = "Range (0%)"
if t_type == "NORMAL"
    t_risk := "Trend (2%)"
else if t_type == "MOMENTUM"
    t_risk := "Clean (3%)"
else if t_type == "POWER"
    t_risk := "Breakout (0%)"

atr_call = htf_c + htf_atr * i_atr_mult
atr_put  = htf_c - htf_atr * i_atr_mult
lbl_l = i_use_options_lbl ? "Calls" : "Long"
lbl_s = i_use_options_lbl ? "Puts" : "Short"

rdy_txt = chop ? "WAIT" : bull ? "LONG" : "SHORT"
rdy_clr = chop ? CLR_CHOP : bull ? CLR_BULL : CLR_BEAR

sma200 = ta.sma(close, 200)
sma50  = ta.sma(close, 50)
ema10  = ta.ema(close, 10)
rsi20  = ta.rsi(close, 20)

buy_dip = ta.crossover(close, sma200) and close > ema10 and rsi20 < 70
bullish_burst = ta.crossover(close, ema10) and close > sma200 and close > sma50 and rsi20 < 70
bearish_burst = ta.crossunder(close, sma200) and close < sma50 and rsi20 > 30

// ───────────────────────────────────────────────────────────────────────────────
// Pivot Management
// ───────────────────────────────────────────────────────────────────────────────
piv_size_check = array.size(piv_val)

if new_htf_close and not na(htf_piv_h) and (na(last_piv_bar_index) or htf_bar_index != last_piv_bar_index)
    bool can_push = true
    if array.size(piv_val) > 0
        can_push := last_piv_dir != 1 or htf_piv_h != array.last(piv_val)

    if can_push
        array.push(piv_val, htf_piv_h)
        array.push(piv_type, 1)
        array.push(piv_bar, htf_bar_index)
        last_piv_dir := 1
        last_piv_bar_index := htf_bar_index
        zz_dirty := true
        htf_bars_since_pivot := 0
        pivs_since_last_ew_scan += 1

if new_htf_close and not na(htf_piv_l) and (na(last_piv_bar_index) or htf_bar_index != last_piv_bar_index)
    bool can_push = true
    if array.size(piv_val) > 0
        can_push := last_piv_dir != 0 or htf_piv_l != array.last(piv_val)

    if can_push
        array.push(piv_val, htf_piv_l)
        array.push(piv_type, 0)
        array.push(piv_bar, htf_bar_index)
        last_piv_dir := 0
        last_piv_bar_index := htf_bar_index
        zz_dirty := true
        htf_bars_since_pivot := 0
        pivs_since_last_ew_scan += 1


piv_size = array.size(piv_val)
if piv_size > 0
    oldest_piv_bar_index = array.get(piv_bar, 0)
    if f_is_ew_expired(oldest_piv_bar_index, htf_bar_index, i_ew_max_age * 5)
        array.shift(piv_val)
        array.shift(piv_type)
        array.shift(piv_bar)
        piv_size := array.size(piv_val)

while piv_size > MAX_PIVS
    array.shift(piv_val)
    array.shift(piv_type)
    array.shift(piv_bar)
    piv_size := array.size(piv_val)

if new_htf_close and htf_bars_since_pivot < 10000
    htf_bars_since_pivot += 1

// ───────────────────────────────────────────────────────────────────────────────
// ZigZag Structure Analysis
// ───────────────────────────────────────────────────────────────────────────────
if new_htf_close and zz_dirty
    array.clear(zz_highs_lock)
    array.clear(zz_lows_lock)

    n_piv = piv_size
    if n_piv > 0
        zz_highs_count = 0
        zz_lows_count = 0
        for k = 0 to n_piv - 1
            if zz_highs_count >= 5 and zz_lows_count >= 5
                break
            i = n_piv - 1 - k
            typ = array.get(piv_type, i)
            val = array.get(piv_val, i)
            if typ == 1 and zz_highs_count < 5
                array.push(zz_highs_lock, val)
                zz_highs_count += 1
            if typ == 0 and zz_lows_count < 5
                array.push(zz_lows_lock, val)
                zz_lows_count += 1
    array.reverse(zz_highs_lock)
    array.reverse(zz_lows_lock)
    zz_dirty := false

if new_htf_close
    if array.size(zz_highs_lock) < 2 or array.size(zz_lows_lock) < 2
        zz_structure := "N/A"
        zz_struct_clr := CLR_CHOP
    else if array.size(zz_highs_lock) >= 3 and array.size(zz_lows_lock) >= 2
        h0 = array.get(zz_highs_lock, 0)
        h1 = array.get(zz_highs_lock, 1)
        h2 = array.get(zz_highs_lock, 2)
        l0 = array.get(zz_lows_lock, 0)
        l1 = array.get(zz_lows_lock, 1)

        if h0 > h1 and h1 > h2 and l0 > l1
            zz_structure := "HH/HL"
            zz_struct_clr := CLR_BULL
        else if h0 < h1 and h1 < h2 and l0 < l1
            zz_structure := "LH/LL"
            zz_struct_clr := CLR_BEAR
        else
            zz_structure := "RANGE"
            zz_struct_clr := CLR_CHOP

zz_bull_struct = zz_structure == "HH/HL"
zz_bear_struct = zz_structure == "LH/LL"

if new_htf_close and piv_size > 0
    last_ix = piv_size - 1
    if last_ix >= 0
        zz_last_val := array.get(piv_val, last_ix)
        zz_last_type := array.get(piv_type, last_ix) == 1 ? "HIGH" : "LOW"
        pivot_bar_index = array.get(piv_bar, last_ix)
        if not na(pivot_bar_index) and not na(htf_bar_index)
            zz_last_age := htf_bar_index - pivot_bar_index
        else
            zz_last_age := na

// ───────────────────────────────────────────────────────────────────────────────
// Trade Direction Determination
// ───────────────────────────────────────────────────────────────────────────────
is_long  = (bull or (ew_state == EW_ACTIVE and ew_dir == DIR_UP)) and zz_bull_struct and not chop
is_short = (bear or (ew_state == EW_ACTIVE and ew_dir == DIR_DOWN)) and zz_bear_struct and not chop

// ───────────────────────────────────────────────────────────────────────────────
// Key Level Calculation
// ───────────────────────────────────────────────────────────────────────────────
if new_htf_close
    if not i_persist_holds
        hold_L1 := 0
        hold_L2 := 0
        hold_L3 := 0
    if not ((is_long and hold_L1 > 0) or (is_short and hold_L1 < 0))
        hold_L1 := 0
    if not ((is_long and hold_L2 > 0) or (is_short and hold_L2 < 0))
        hold_L2 := 0
    if not ((is_long and hold_L3 > 0) or (is_short and hold_L3 < 0))
        hold_L3 := 0

    if not na(htf_rng_h) and not na(htf_rng_l) and htf_rng_h > htf_rng_l
        // Quartile-based range levels (25%, 50%, 75%)
        rng_m = (htf_rng_h + htf_rng_l) * 0.5
        _b1 = htf_rng_l + (rng_m - htf_rng_l) * 0.5
        _b2 = rng_m
        _b3 = rng_m + (htf_rng_h - rng_m) * 0.5
        array.set(lvl_arr, 0, _b1)
        array.set(lvl_arr, 1, _b2)
        array.set(lvl_arr, 2, _b3)
        array.sort(lvl_arr)
        L1 := math.round(array.get(lvl_arr, 0), 2)
        L2 := math.round(array.get(lvl_arr, 1), 2)
        L3 := math.round(array.get(lvl_arr, 2), 2)
        if not levels_valid or na(L1_lock)
            L1_lock := L1
        if not levels_valid or na(L2_lock)
            L2_lock := L2
        if not levels_valid or na(L3_lock)
            L3_lock := L3
        
        curr_htf_trend = htf_bull ? DIR_UP : htf_bear ? DIR_DOWN : DIR_NONE
        if curr_htf_trend != last_htf_trend and curr_htf_trend != DIR_NONE
            L1_lock := L1
            L2_lock := L2
            L3_lock := L3
            last_htf_trend := curr_htf_trend
        
        levels_valid := htf_bull or htf_bear
    else
        levels_valid := false

// ───────────────────────────────────────────────────────────────────────────────
// Elliott Wave Detection and Management
// ───────────────────────────────────────────────────────────────────────────────
ew_struct_ok = (zz_bull_struct and not zz_bear_struct) or (zz_bear_struct and not zz_bull_struct)
ew_active = ew_state == EW_ACTIVE

if ew_state == EW_ACTIVE
    struct_ok = (ew_dir == DIR_UP and zz_bull_struct) or (ew_dir == DIR_DOWN and zz_bear_struct)
    if not struct_ok
        ew_state := EW_WAITING
        ew_age := 0

if ew_state == EW_WAITING and ew_age > 2 and ew_struct_ok
    ew_state := EW_NONE
    ew_dir := DIR_NONE
    ew_invalid := na
    ew_age := 0

piv_size_ew = array.size(piv_val)
can_detect_ew = ew_state == EW_NONE
can_detect_ew := can_detect_ew and piv_size_ew >= 5
can_detect_ew := can_detect_ew and htf_bars_since_pivot <= i_zz_depth * 2

if new_htf_close and pivs_since_last_ew_scan >= 1 and can_detect_ew and not chop
    [found_, dir_, w0_, w1_, w2_, w3_, w4_, invalid_] = f_detect_ew_strict(piv_val, piv_type, piv_bar, chop, i_min_retr_w2, i_max_retr_w2, i_min_ext_w3, htf_bar_index, i_ew_max_age)
    if found_
        struct_ok = (dir_ == DIR_UP and zz_bull_struct) or (dir_ == DIR_DOWN and zz_bear_struct)
        if struct_ok
            ew_state   := EW_ACTIVE
            ew_dir     := dir_
            ew_w0      := w0_
            ew_w1      := w1_
            ew_w2      := w2_
            ew_w3      := w3_
            ew_w4      := w4_
            ew_invalid := invalid_
            ew_age     := 0
            pivs_since_last_ew_scan := 0
    else
        pivs_since_last_ew_scan := 0

if (ew_state == EW_ACTIVE or ew_state == EW_WAITING) and new_htf_close
    ew_age += 1

if new_htf_close and ew_state == EW_ACTIVE and not na(ew_invalid)
    if (ew_dir == DIR_UP and htf_c < ew_invalid) or (ew_dir == DIR_DOWN and htf_c > ew_invalid)
        ew_state := EW_NONE
        ew_dir := DIR_NONE
        ew_w0 := na
        ew_w1 := na
        ew_w2 := na
        ew_w3 := na
        ew_w4 := na
        ew_invalid := na
        ew_age := 0
        targets_locked := false
        T1 := na
        T2 := na
        T3 := na
        T1_lock := na
        T2_lock := na
        T3_lock := na
        fib_50 := na
        fib_618 := na
        fib_786 := na
        ext_127 := na
        ext_162 := na
        ext_200 := na
        pivs_since_last_ew_scan := 0

if ew_state == EW_ACTIVE and ew_age > i_ew_max_age
    ew_state := EW_NONE
    ew_dir := DIR_NONE
    ew_w0 := na
    ew_w1 := na
    ew_w2 := na
    ew_w3 := na
    ew_w4 := na
    ew_invalid := na
    ew_age := 0
    targets_locked := false
    T1 := na
    T2 := na
    T3 := na
    T1_lock := na
    T2_lock := na
    T3_lock := na
    fib_50 := na
    fib_618 := na
    fib_786 := na
    ext_127 := na
    ext_162 := na
    ext_200 := na
    pivs_since_last_ew_scan := 0

if ew_state == EW_NONE and targets_locked
    targets_locked := false
    T1 := na
    T2 := na
    T3 := na
    T1_lock := na
    T2_lock := na
    T3_lock := na

// Clear cached EW dashboard rows when EW deactivates
if ew_state != EW_ACTIVE
    prev_ew_txt  := ""
    prev_fib_txt := ""
    prev_ext_txt := ""

// ───────────────────────────────────────────────────────────────────────────────
// Fibonacci and Extension Level Calculation
// ───────────────────────────────────────────────────────────────────────────────
if ew_state == EW_ACTIVE and not na(ew_w0) and not na(ew_w1)
    w1_rng = math.abs(ew_w1 - ew_w0)
    
    if ew_dir == DIR_UP
        fib_50  := ew_w1 - w1_rng * 0.5
        fib_618 := ew_w1 - w1_rng * 0.618
        fib_786 := ew_w1 - w1_rng * 0.786
        ext_127 := ew_w1 + w1_rng * 1.272
        ext_162 := ew_w1 + w1_rng * 1.618
        ext_200 := ew_w1 + w1_rng * 2.0
    else
        fib_50  := ew_w1 + w1_rng * 0.5
        fib_618 := ew_w1 + w1_rng * 0.618
        fib_786 := ew_w1 + w1_rng * 0.786
        ext_127 := ew_w1 - w1_rng * 1.272
        ext_162 := ew_w1 - w1_rng * 1.618
        ext_200 := ew_w1 - w1_rng * 2.0

    if not targets_locked
        T1 := ext_127
        T2 := ext_162
        T3 := ext_200
else
    fib_50 := na
    fib_618 := na
    fib_786 := na
    ext_127 := na
    ext_162 := na
    ext_200 := na
    if ew_state != EW_ACTIVE
        T1 := na
        T2 := na
        T3 := na

// ───────────────────────────────────────────────────────────────────────────────
// Target Locking Logic
// ───────────────────────────────────────────────────────────────────────────────
lock_condition = ew_state == EW_ACTIVE
lock_condition := lock_condition and not targets_locked
lock_condition := lock_condition and not na(L2_lock)
lock_condition := lock_condition and not na(ew_w0)
lock_condition := lock_condition and not na(ew_w1)
lock_condition := lock_condition and not na(ew_w2)
lock_condition := lock_condition and not na(ew_w3)
lock_condition := lock_condition and ew_w3 != ew_w2
lock_condition := lock_condition and ew_age >= 1
lock_condition := lock_condition and htf_bars_since_pivot >= 1
w1_len = math.abs(ew_w1 - ew_w0)
w3_len = math.abs(ew_w3 - ew_w2)
lock_condition := lock_condition and w3_len >= w1_len * 1.05
lock_condition := lock_condition and ((ew_dir == DIR_UP and close >= ew_w3 - atr_buffer) or (ew_dir == DIR_DOWN and close <= ew_w3 + atr_buffer))
lock_condition := lock_condition and ((ew_dir == DIR_UP and close >= L2_lock - atr_buffer) or (ew_dir == DIR_DOWN and close <= L2_lock + atr_buffer))

if not targets_locked and lock_condition
    targets_locked := true
    T1_lock := T1
    T2_lock := T2
    T3_lock := T3

if targets_locked
    T1 := T1_lock
    T2 := T2_lock
    T3 := T3_lock

// ───────────────────────────────────────────────────────────────────────────────
// Breakout Detection
// ───────────────────────────────────────────────────────────────────────────────
brk1 = is_long and levels_valid and not na(L1_lock) and ta.crossover(close, L1_lock + atr_min_break)
brk2 = is_long and levels_valid and not na(L2_lock) and ta.crossover(close, L2_lock + atr_min_break)
brk3 = is_long and levels_valid and not na(L3_lock) and ta.crossover(close, L3_lock + atr_min_break)

brk1d = is_short and levels_valid and not na(L1_lock) and ta.crossunder(close, L1_lock - atr_min_break)
brk2d = is_short and levels_valid and not na(L2_lock) and ta.crossunder(close, L2_lock - atr_min_break)
brk3d = is_short and levels_valid and not na(L3_lock) and ta.crossunder(close, L3_lock - atr_min_break)

// ───────────────────────────────────────────────────────────────────────────────
// Hold Tracking
// ───────────────────────────────────────────────────────────────────────────────
if is_long and levels_valid and not na(L1_lock) and not na(L2_lock) and not na(L3_lock)
    if close < L1_lock - atr_buffer
        hold_L1 := 0
    else if not brk1 and math.abs(close - L1_lock) > atr_buffer
        hold_L1 := 0
    else
        hold_L1 := brk1 ? 1 : hold_L1 > 0 and close >= L1_lock and math.abs(close - L1_lock) <= atr_buffer ? math.min(hold_L1 + 1, i_bars_hold) : hold_L1
    
    if close < L2_lock - atr_buffer
        hold_L2 := 0
    else if not brk2 and math.abs(close - L2_lock) > atr_buffer
        hold_L2 := 0
    else
        hold_L2 := brk2 ? 1 : hold_L2 > 0 and close >= L2_lock and math.abs(close - L2_lock) <= atr_buffer ? math.min(hold_L2 + 1, i_bars_hold) : hold_L2
    
    if close < L3_lock - atr_buffer
        hold_L3 := 0
    else if not brk3 and math.abs(close - L3_lock) > atr_buffer
        hold_L3 := 0
    else
        hold_L3 := brk3 ? 1 : hold_L3 > 0 and close >= L3_lock and math.abs(close - L3_lock) <= atr_buffer ? math.min(hold_L3 + 1, i_bars_hold) : hold_L3
else if is_short and levels_valid and not na(L1_lock) and not na(L2_lock) and not na(L3_lock)
    if close > L1_lock + atr_buffer
        hold_L1 := 0
    else if not brk1d and math.abs(close - L1_lock) > atr_buffer
        hold_L1 := 0
    else
        hold_L1 := brk1d ? -1 : hold_L1 < 0 and close <= L1_lock and math.abs(close - L1_lock) <= atr_buffer ? math.max(hold_L1 - 1, -i_bars_hold) : hold_L1
    
    if close > L2_lock + atr_buffer
        hold_L2 := 0
    else if not brk2d and math.abs(close - L2_lock) > atr_buffer
        hold_L2 := 0
    else
        hold_L2 := brk2d ? -1 : hold_L2 < 0 and close <= L2_lock and math.abs(close - L2_lock) <= atr_buffer ? math.max(hold_L2 - 1, -i_bars_hold) : hold_L2
    
    if close > L3_lock + atr_buffer
        hold_L3 := 0
    else if not brk3d and math.abs(close - L3_lock) > atr_buffer
        hold_L3 := 0
    else
        hold_L3 := brk3d ? -1 : hold_L3 < 0 and close <= L3_lock and math.abs(close - L3_lock) <= atr_buffer ? math.max(hold_L3 - 1, -i_bars_hold) : hold_L3

valid_L1_hold = math.abs(hold_L1) >= i_bars_hold
valid_L2_hold = math.abs(hold_L2) >= i_bars_hold
valid_L3_hold = math.abs(hold_L3) >= i_bars_hold

// ───────────────────────────────────────────────────────────────────────────────
// Confidence Score (0–100)
// ───────────────────────────────────────────────────────────────────────────────
conf_score = 0

// HTF + LTF Trend Alignment (max 25)
if (bull and htf_bull) or (bear and htf_bear)
    conf_score += 25
else if bull or bear
    conf_score += 10

// ZigZag Structural Trend (max 20)
if zz_bull_struct or zz_bear_struct
    conf_score += 20

// Elliott Wave Quality (max 25) - Requires structure alignment
if ew_state == EW_ACTIVE and ((ew_dir == DIR_UP and zz_bull_struct) or (ew_dir == DIR_DOWN and zz_bear_struct))
    conf_score += 20
    if targets_locked
        conf_score += 5

// Key Level Validation (max 20)
if valid_L2_hold
    conf_score += 15
else if valid_L1_hold
    conf_score += 10

// Momentum Strength via EMA Spread (max 10)
if t_type == "POWER"
    conf_score += 10
else if t_type == "MOMENTUM"
    conf_score += 5

// Clamp score
conf_score := math.min(conf_score, 100)

conf_txt = "Confidence: " + str.tostring(conf_score) + "%"

conf_clr =
     conf_score >= 85 ? CLR_BULL :
     conf_score >= 70 ? color.rgb(180, 140, 0) :
     conf_score >= 55 ? CLR_CHOP :
     CLR_GRAY

// ───────────────────────────────────────────────────────────────────────────────
// Dashboard Display
// ───────────────────────────────────────────────────────────────────────────────
if barstate.islast
    if not dashboard_initialized
        table.clear(tbl, 0, 0)
    force_redraw = not dashboard_initialized or new_htf_close
    
    if force_redraw
        row = 0
        curr_trend = t_dir + " | " + t_type
        curr_levels = str.tostring(L1, FMT) + " / " + str.tostring(L2, FMT) + " / " + str.tostring(L3, FMT)
        t_src = targets_locked ? "(LOCKED)" : ew_active ? "(EW)" : "(N/A)"
        t_arr = "→"
        if ew_dir == DIR_UP
            t_arr := "↑"
        else if ew_dir == DIR_DOWN
            t_arr := "↓"
        else if bull
            t_arr := "↑"
        else if bear
            t_arr := "↓"
        
        curr_targets = ""
        if (ew_state == EW_ACTIVE or targets_locked) and not na(T1) and not na(T2) and not na(T3)
            curr_targets := "T1/T2/T3 " + t_src + t_arr + ": " + str.tostring(T1, FMT) + " / " + str.tostring(T2, FMT) + " / " + str.tostring(T3, FMT)
        
        curr_zz_last = "N/A"
        if not na(zz_last_val) and not na(zz_last_age)
            curr_zz_last := zz_last_type + " @ " + str.tostring(zz_last_val, FMT) + " | Age: " + str.tostring(zz_last_age)
        curr_zz_highs = f_fmt_list(zz_highs_lock)
        curr_zz_lows = f_fmt_list(zz_lows_lock)
        tr_now = high - low
        atr_p = close > 0 ? atr / close * 100 : 0
        curr_atr = str.tostring(atr, FMT) + " (" + str.tostring(atr_p, "#.#") + "%) | TR: " + str.tostring(tr_now, FMT)
        curr_atr_trig = lbl_l + " > " + str.tostring(atr_call, FMT) + " | " + lbl_s + " < " + str.tostring(atr_put, FMT)
        
        curr_ew = ""
        if ew_state == EW_ACTIVE and not na(ew_w1) and not na(ew_w2) and not na(ew_w3) and not na(ew_w4)
            ew_dir_str = ew_dir == DIR_UP ? "UP" : "DOWN"
            curr_ew := "EW " + ew_dir_str + ": " + str.tostring(ew_w1, FMT) + "/" + str.tostring(ew_w2, FMT) + "/" + str.tostring(ew_w3, FMT) + "/" + str.tostring(ew_w4, FMT)
        
        curr_fib = ""
        if ew_state == EW_ACTIVE and not na(fib_50) and not na(fib_618) and not na(fib_786)
            curr_fib := "Fib: .5=" + str.tostring(fib_50, FMT) + " .618=" + str.tostring(fib_618, FMT) + " .786=" + str.tostring(fib_786, FMT)
        
        curr_ext = ""
        if ew_state == EW_ACTIVE and not na(ext_127) and not na(ext_162) and not na(ext_200)
            curr_ext := "Ext: 1.27=" + str.tostring(ext_127, FMT) + " 1.62=" + str.tostring(ext_162, FMT) + " 2.0=" + str.tostring(ext_200, FMT)
        
        table.cell(tbl, 0, row, syminfo.ticker + " | Key Levels", text_color=color.white, bgcolor=CLR_HEADER)
        row += 1
        if rdy_txt != prev_rdy_txt or not dashboard_initialized
            table.cell(tbl, 0, row, "Ready: " + rdy_txt, text_color=color.white, bgcolor=rdy_clr)
            row += 1
            prev_rdy_txt := rdy_txt
        
        if curr_trend != prev_trend or not dashboard_initialized
            table.cell(tbl, 0, row, "Trend: " + curr_trend, text_color=color.white, bgcolor=t_clr)
            row += 1
            prev_trend := curr_trend
        
        if curr_levels != prev_levels or not dashboard_initialized
            table.cell(tbl, 0, row, "L1/L2/L3: " + curr_levels, text_color=color.white, bgcolor=CLR_LEVEL)
            row += 1
            prev_levels := curr_levels
        
        if curr_targets != "" and (curr_targets != prev_targets or not dashboard_initialized)
            table.cell(tbl, 0, row, curr_targets, text_color=color.white, bgcolor=CLR_TARGET)
            row += 1
            prev_targets := curr_targets
        
        if zz_structure != prev_zz_struct or not dashboard_initialized
            table.cell(tbl, 0, row, "ZZ: " + zz_structure, text_color=color.white, bgcolor=zz_struct_clr)
            row += 1
            prev_zz_struct := zz_structure
        
        if curr_zz_last != prev_zz_last or not dashboard_initialized
            table.cell(tbl, 0, row, "Last: " + curr_zz_last, text_color=color.white, bgcolor=zz_struct_clr)
            row += 1
            prev_zz_last := curr_zz_last
        
        if curr_zz_highs != prev_zz_highs or not dashboard_initialized
            table.cell(tbl, 0, row, "Highs: " + curr_zz_highs, text_color=color.white, bgcolor=CLR_BEAR)
            row += 1
            prev_zz_highs := curr_zz_highs
        
        if curr_zz_lows != prev_zz_lows or not dashboard_initialized
            table.cell(tbl, 0, row, "Lows: " + curr_zz_lows, text_color=color.white, bgcolor=CLR_BULL)
            row += 1
            prev_zz_lows := curr_zz_lows
        
        if curr_atr != prev_atr_txt or not dashboard_initialized
            table.cell(tbl, 0, row, "ATR: " + curr_atr, text_color=color.white, bgcolor=CLR_ATR)
            row += 1
            prev_atr_txt := curr_atr
        
        if curr_atr_trig != prev_atr_trig or not dashboard_initialized
            table.cell(tbl, 0, row, curr_atr_trig, text_color=color.white, bgcolor=CLR_ATR)
            row += 1
            prev_atr_trig := curr_atr_trig
        
        if t_risk != prev_risk or not dashboard_initialized
            table.cell(tbl, 0, row, "Risk: " + t_risk, text_color=color.white, bgcolor=t_clr)
            row += 1
            prev_risk := t_risk
        
        // Confidence Score
        if conf_txt != prev_conf_txt or not dashboard_initialized
            table.cell(tbl, 0, row, conf_txt, text_color=color.white, bgcolor=conf_clr)
            row += 1
            prev_conf_txt := conf_txt
        
        if i_show_ew_fib and ew_state == EW_ACTIVE
            if curr_ew != prev_ew_txt or not dashboard_initialized
                table.cell(tbl, 0, row, curr_ew, text_color=color.white, bgcolor=CLR_EW)
                row += 1
                prev_ew_txt := curr_ew

            if curr_fib != "" and (curr_fib != prev_fib_txt or not dashboard_initialized)
                table.cell(tbl, 0, row, curr_fib, text_color=color.white, bgcolor=CLR_FIB)
                row += 1
                prev_fib_txt := curr_fib

            if curr_ext != "" and (curr_ext != prev_ext_txt or not dashboard_initialized)
                table.cell(tbl, 0, row, curr_ext, text_color=color.white, bgcolor=CLR_EXT)
                row += 1
                prev_ext_txt := curr_ext
        
        if (buy_dip != prev_buy_dip or bullish_burst != prev_bull_burst or bearish_burst != prev_bear_burst) or not dashboard_initialized
            table.cell(tbl, 0, row, "Buy Dip: " + (buy_dip ? "YES" : "NO") + " | Bull Burst: " + (bullish_burst ? "YES" : "NO") + " | Bear Burst: " + (bearish_burst ? "YES" : "NO"), text_color=color.white, bgcolor=buy_dip or bullish_burst or bearish_burst? CLR_BULL : CLR_GRAY)
            row += 1
        
        if buy_dip != prev_buy_dip or not dashboard_initialized
            prev_buy_dip := buy_dip

        if bullish_burst != prev_bull_burst or not dashboard_initialized
            prev_bull_burst := bullish_burst
        
        if bearish_burst != prev_bear_burst or not dashboard_initialized
            prev_bear_burst := bearish_burst
        
        dashboard_initialized := true
