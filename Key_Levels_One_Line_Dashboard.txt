//@version=6
indicator('Key Levels - One-Line Dashboard', overlay = true, max_labels_count = 500, max_bars_back = 3000)
// ══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ══════════════════════════════════════════════════════════════════════════════
// ── Level Settings ────────────────────────────────────────────────────────────
i_tf = input.string('D', 'Key Level Base TF', options = ['D', 'W', 'M'], group = 'Level Settings')
i_lookback_htf = input.int(18, 'HTF Lookback Candles', minval = 3, maxval = 240, group = 'Level Settings')

// ── ZigZag & Elliott Wave ─────────────────────────────────────────────────────
i_zz_depth = input.int(8, 'ZigZag Pivot Depth', minval = 3, maxval = 20, group = 'Elliott Wave')
i_min_retr_w2 = input.float(0.30, 'Min W2 Retrace', minval = 0.1, maxval = 0.9, step = 0.01, group = 'Elliott Wave')
i_max_retr_w2 = input.float(0.90, 'Max W2 Retrace', minval = 0.5, maxval = 1.0, step = 0.01, group = 'Elliott Wave')
i_min_ext_w3 = input.float(0.80, 'Min W3 Extension', minval = 0.5, maxval = 2.0, step = 0.01, group = 'Elliott Wave')
i_ew_max_age = input.int(10, 'Max EW ACTIVE Age (HTF bars)', minval = 3, maxval = 30, group = 'Elliott Wave')

// ── ATR Settings ─────────────────────────────────────────────────────────────
i_atr_len = input.int(14, 'ATR Length', minval = 5, maxval = 50, group = 'ATR')

// ── Display ──────────────────────────────────────────────────────────
i_show_ew_fib = input.bool(true, 'Show EW & Fib in Dashboard', group = 'Display')

// ── Event Risk ──────────────────────────────────────────────────────────
i_enable_earnings = input.bool(false, 'Enable Earnings Block', group = 'Event Risk')

// ══════════════════════════════════════════════════════════════════════════════
// CONSTANTS
// ══════════════════════════════════════════════════════════════════════════════
FMT = '#.##'
MAX_PIVS = 20

// ── State Enums ───────────────────────────────────────────────────────────────
EW_NONE = 0
EW_ACTIVE = 1

DIR_UP = 1
DIR_DOWN = 2

// ══════════════════════════════════════════════════════════════════════════════
// COLORS
// ══════════════════════════════════════════════════════════════════════════════
CLR_BULL = color.rgb(0, 180, 80)
CLR_BEAR = color.rgb(200, 50, 50)
CLR_CHOP = color.rgb(255, 165, 0)
CLR_HEADER = color.rgb(255, 140, 0)
CLR_LEVEL = color.rgb(0, 150, 70)
CLR_ATR = color.rgb(120, 70, 160)
CLR_EW = color.rgb(40, 80, 120)
CLR_FIB = color.rgb(20, 60, 120)
CLR_GRAY = color.rgb(80, 80, 80)

// ══════════════════════════════════════════════════════════════════════════════
// PERSISTENT STATE VARIABLES
// ══════════════════════════════════════════════════════════════════════════════
// ── Pivot Arrays ──────────────────────────────────────────────────────────────
var array<float> piv_val = array.new_float()
var array<int> piv_type = array.new_int()
var array<int> piv_bar = array.new_int()

// ── ZigZag Structure ──────────────────────────────────────────────────────────
var array<float> zz_highs_lock = array.new_float()
var array<float> zz_lows_lock = array.new_float()
var string zz_structure = 'N/A'
var color zz_struct_clr = CLR_CHOP
var float zz_last_val = na
var string zz_last_type = 'N/A'
var int zz_last_age = na
var bool zz_dirty = false
var string cached_zz_highs = 'N/A'
var string cached_zz_lows = 'N/A'

// ── Key Levels ────────────────────────────────────────────────────────────────
var float L1 = na
var float L2 = na
var float L3 = na

// ── Elliott Wave State ────────────────────────────────────────────────────────
var int ew_state = EW_NONE
var int ew_dir = na
var float ew_w0 = na
var float ew_w1 = na
var float ew_w2 = na
var float ew_w3 = na
var float ew_w4 = na
var int ew_age = 0
var int ew_start_bar = na

// ── Fibonacci Levels ──────────────────────────────────────────────────────────
var float fib_50 = na
var float fib_618 = na
var float fib_786 = na

// ── UI Components ─────────────────────────────────────────────────────────────
var table tbl = table.new(position.bottom_right, 1, 14, border_width = 1)

// ──────────────────────────────────────────────────────────────────────────────
// Function: Detect Elliott Wave Pattern (optimized loop direction)
// ──────────────────────────────────────────────────────────────────────────────
f_detect_ew_strict(piv_val, piv_type, piv_bar, chop, atr, min_retr_w2, max_retr_w2, min_ext_w3) =>
    bool _found = false
    int _dir = na
    float _w0 = na
    float _w1 = na
    float _w2 = na
    float _w3 = na
    float _w4 = na

    if not chop
        n = array.size(piv_val)
        if n >= 5
            // Scan from newest to oldest, break on first valid pattern
            start_ix = n - 5
            end_ix = math.max(n - 15, 0)
            num_iters = start_ix - end_ix + 1

            for k = 0 to num_iters - 1 by 1
                ix = start_ix - k
                pattern_bar = array.get(piv_bar, ix)
                v0 = array.get(piv_val, ix)
                v1 = array.get(piv_val, ix + 1)
                v2 = array.get(piv_val, ix + 2)
                v3 = array.get(piv_val, ix + 3)
                v4 = array.get(piv_val, ix + 4)

                t0 = array.get(piv_type, ix)
                t1 = array.get(piv_type, ix + 1)
                t2 = array.get(piv_type, ix + 2)
                t3 = array.get(piv_type, ix + 3)
                t4 = array.get(piv_type, ix + 4)

                // UP IMPULSE: 0-1-0-1-0
                if t0 == 0 and t1 == 1 and t2 == 0 and t3 == 1 and t4 == 0
                    w1 = v1 - v0
                    w2 = v1 - v2
                    w3 = v3 - v2
                    r2 = w1 != 0 ? w2 / w1 : 0
                    x3 = w1 != 0 ? w3 / w1 : 0
                    
                    min_w1 = math.max(atr, syminfo.mintick) * 1.5
                    if math.abs(w1) < min_w1
                        continue

                    if r2 >= min_retr_w2 and r2 <= max_retr_w2 and x3 >= min_ext_w3 and w3 > w1 and v4 > v2 and v4 > v0
                        _found := true
                        _dir := DIR_UP
                        _w0 := v0
                        _w1 := v1
                        _w2 := v2
                        _w3 := v3
                        _w4 := v4
                        break

                // DOWN IMPULSE: 1-0-1-0-1
                if t0 == 1 and t1 == 0 and t2 == 1 and t3 == 0 and t4 == 1
                    w1 = v0 - v1
                    w2 = v2 - v1
                    w3 = v2 - v3
                    r2 = w1 != 0 ? w2 / w1 : 0
                    x3 = w1 != 0 ? w3 / w1 : 0

                    min_w1 = math.max(atr, syminfo.mintick) * 1.5
                    if math.abs(w1) < min_w1
                        continue

                    if r2 >= min_retr_w2 and r2 <= max_retr_w2 and x3 >= min_ext_w3 and w3 > w1 and v4 < v2 and v4 < v0
                        _found := true
                        _dir := DIR_DOWN
                        _w0 := v0
                        _w1 := v1
                        _w2 := v2
                        _w3 := v3
                        _w4 := v4
                        break

    [_found, _dir, _w0, _w1, _w2, _w3, _w4]

// ──────────────────────────────────────────────────────────────────────────────
// Function: Format Array as String List
// ──────────────────────────────────────────────────────────────────────────────
f_fmt_list(arr) =>
    if array.size(arr) == 0
        'N/A'
    else
        string s = ''
        for i = 0 to array.size(arr) - 1 by 1
            s := s + (i > 0 ? ' | ' : '') + str.tostring(array.get(arr, i), FMT)
            s
        s

// ══════════════════════════════════════════════════════════════════════════════
// HIGHER TIMEFRAME DATA
// ══════════════════════════════════════════════════════════════════════════════
bars_lb = math.max(1, math.min(i_lookback_htf, 3000))
[htf_bar_index, htf_h, htf_l, htf_c, htf_rng_h, htf_rng_l, atr, htf_volume, vol_sma, ema8, ema10, ema21, ema34, sma50, sma200, rsi20] = request.security(syminfo.tickerid, i_tf, [bar_index, high, low, close, ta.highest(high, bars_lb), ta.lowest(low, bars_lb), ta.atr(i_atr_len), volume, ta.sma(volume, 20), ta.ema(close, 8), ta.ema(close, 10), ta.ema(close, 21), ta.ema(close, 34), ta.sma(close, 50), ta.sma(close, 200), ta.rsi(close, 20)], barmerge.gaps_off, barmerge.lookahead_off)
new_htf_close = ta.change(htf_bar_index) != 0

// ══════════════════════════════════════════════════════════════════════════════
// EARNINGS
// ══════════════════════════════════════════════════════════════════════════════
is_daily_context = timeframe.isdaily or timeframe.isweekly or timeframe.ismonthly
earnings_actual = i_enable_earnings and is_daily_context ? request.earnings(syminfo.tickerid, earnings.actual) : na
var float earnings_date_to_use = na
earnings_source_txt = ' (Est.)'
var int last_earnings_bar = na
var float last_earnings_value = na
if not na(earnings_actual) and (na(last_earnings_value) or earnings_actual != last_earnings_value)
    last_earnings_bar := bar_index
    last_earnings_value := earnings_actual
    last_earnings_value

if is_daily_context and not na(last_earnings_bar) and last_earnings_bar > 0
    bars_since_earnings = bar_index - last_earnings_bar
    // Convert bars to days (approximate: depends on timeframe)
    tf_days_per_bar = timeframe.in_seconds() / 86400
    days_since_earnings = bars_since_earnings * tf_days_per_bar
    estimated_days_to_next = 90 - days_since_earnings

    if estimated_days_to_next > 0 and estimated_days_to_next <= 90
        earnings_date_to_use := time + estimated_days_to_next * 24 * 60 * 60 * 1000
        earnings_date_to_use

var float days_to_earnings = na
earnings_block_active = false
earnings_txt = 'N/A'
earnings_clr = CLR_GRAY

if i_enable_earnings
    if is_daily_context and not na(earnings_date_to_use) and earnings_date_to_use > 0
        current_time = time
        days_diff = (earnings_date_to_use - current_time) / (1000 * 60 * 60 * 24) // Convert ms to days
        days_to_earnings := math.floor(days_diff)

        // Block new trades if ≤ 5 days to earnings
        earnings_block_active := days_to_earnings <= 5 and days_to_earnings >= 0
        if days_to_earnings < 0
            earnings_txt := 'Earnings: Past' + earnings_source_txt
            earnings_clr := CLR_GRAY
        else if earnings_block_active
            earnings_txt := 'Earnings: ' + str.tostring(days_to_earnings) + ' days ⚠️' + earnings_source_txt
            earnings_clr := CLR_BEAR
        else
            earnings_txt := 'Earnings: ' + str.tostring(days_to_earnings) + ' days' + earnings_source_txt
            earnings_clr := CLR_GRAY
    else if not is_daily_context
        earnings_txt := 'Earnings: Daily TF only'
        earnings_clr := CLR_GRAY
    else
        earnings_txt := 'Earnings: No date set'
        earnings_clr := CLR_GRAY

// ══════════════════════════════════════════════════════════════════════════════
// CORE CALCULATIONS
// ══════════════════════════════════════════════════════════════════════════════
htf_piv_h = ta.pivothigh(htf_h, i_zz_depth, i_zz_depth)
htf_piv_l = ta.pivotlow(htf_l, i_zz_depth, i_zz_depth)
atr02 = atr * 0.2

// ══════════════════════════════════════════════════════════════════════════════
// VOLUME CONFIRMATION LAYER
// ══════════════════════════════════════════════════════════════════════════════
vol_ratio = vol_sma > 0 ? htf_volume / vol_sma : 1.0
vol_state = vol_ratio > 1.3 ? 'EXPANDING' : vol_ratio >= 0.8 ? 'NORMAL' : 'DRY'
vol_clr = vol_state == 'EXPANDING' ? CLR_BULL : vol_state == 'NORMAL' ? CLR_GRAY : CLR_BEAR

// ══════════════════════════════════════════════════════════════════════════════
// TREND STRENGTH LAYER (ADX)
// ══════════════════════════════════════════════════════════════════════════════
[dip, dim, adx_val] = request.security(syminfo.tickerid, i_tf, ta.dmi(14, 14))
trend_str_state = adx_val >= 25 ? 'STRONG' : adx_val >= 20 ? 'NEUTRAL' : 'WEAK'
trend_str_clr = trend_str_state == 'STRONG' ? CLR_BULL : trend_str_state == 'NEUTRAL' ? CLR_GRAY : CLR_BEAR

// Trend
bull = htf_c >= ema8 and ema8 >= ema21 and ema21 >= ema34
bear = htf_c <= ema8 and ema8 <= ema21 and ema21 <= ema34
chop = not bull and not bear

t_clr = bull ? CLR_BULL : bear ? CLR_BEAR : CLR_CHOP
t_dir = bull ? 'BULL' : bear ? 'BEAR' : 'CHOP'

spread = atr > 0 ? math.abs(ema8 - ema34) / atr : 0
t_type = chop or spread < 0.3 ? 'CHOPPY' : spread < 0.6 ? 'NORMAL' : spread < 1.0 ? 'MOMENTUM' : 'POWER'
t_risk = t_type == 'CHOPPY' ? 'Range (0%)' : t_type == 'NORMAL' ? 'Trend (2%)' : t_type == 'MOMENTUM' ? 'Clean (3%)' : 'Breakout (0%)'

rdy_txt = earnings_block_active ? 'BLOCKED' : chop ? 'WAIT' : bull ? 'LONG' : 'SHORT'
rdy_clr = earnings_block_active ? CLR_BEAR : chop ? CLR_CHOP : bull ? CLR_BULL : CLR_BEAR

// Dashboard signals (CANDIDATES - will be validated below)
buy_dip = ta.crossover(htf_c, sma200) and htf_c > ema10 and rsi20 < 70
bullish_burst = ta.crossover(htf_c, ema10) and htf_c > sma200 and htf_c > sma50 and rsi20 < 70
bearish_burst = ta.crossunder(htf_c, sma200) and htf_c < sma50 and rsi20 > 30

// ══════════════════════════════════════════════════════════════════════════════
// PIVOT MANAGEMENT
// ══════════════════════════════════════════════════════════════════════════════
var int last_piv_bar = na
cur_bar = htf_bar_index - i_zz_depth

if new_htf_close and (na(last_piv_bar) or cur_bar > last_piv_bar)
    if not na(htf_piv_h)
        cur_bar := htf_bar_index - i_zz_depth
        array.push(piv_val, htf_piv_h)
        array.push(piv_type, 1)
        array.push(piv_bar, cur_bar)
        last_piv_bar := cur_bar
        zz_dirty := true
    else if not na(htf_piv_l)
        cur_bar := htf_bar_index - i_zz_depth
        array.push(piv_val, htf_piv_l)
        array.push(piv_type, 0)
        array.push(piv_bar, cur_bar)
        last_piv_bar := cur_bar
        zz_dirty := true

if array.size(piv_val) > MAX_PIVS
    while array.size(piv_val) > MAX_PIVS - 5
        array.shift(piv_val)
        array.shift(piv_type)
        array.shift(piv_bar)

// ══════════════════════════════════════════════════════════════════════════════
// LEVEL CALCULATION (direct quartile math - no array needed)
// ══════════════════════════════════════════════════════════════════════════════
if new_htf_close
    rng_m = (htf_rng_h + htf_rng_l) * 0.5
    L1 := math.round((htf_rng_l + (rng_m - htf_rng_l) * 0.5) * 100) / 100
    L2 := math.round(rng_m * 100) / 100
    L3 := math.round((rng_m + (htf_rng_h - rng_m) * 0.5) * 100) / 100

// ══════════════════════════════════════════════════════════════════════════════
// ZIGZAG STRUCTURE (Performance: cache format strings)
// ══════════════════════════════════════════════════════════════════════════════
if new_htf_close and zz_dirty
    array.clear(zz_highs_lock)
    array.clear(zz_lows_lock)

    n_piv = array.size(piv_val)
    if n_piv > 0
        for k = 0 to n_piv - 1 by 1
            if array.size(zz_highs_lock) >= 5 and array.size(zz_lows_lock) >= 5
                break
            i = n_piv - 1 - k
            typ = array.get(piv_type, i)
            val = array.get(piv_val, i)
            if typ == 1 and array.size(zz_highs_lock) < 5
                array.push(zz_highs_lock, val)
            if typ == 0 and array.size(zz_lows_lock) < 5
                array.push(zz_lows_lock, val)

    // Performance: Cache format strings here instead of dashboard
    cached_zz_highs := f_fmt_list(zz_highs_lock)
    cached_zz_lows := f_fmt_list(zz_lows_lock)
    zz_dirty := false

if new_htf_close
    if array.size(zz_highs_lock) < 2 or array.size(zz_lows_lock) < 2
        zz_structure := 'N/A'
        zz_struct_clr := CLR_CHOP
    else if array.size(zz_highs_lock) >= 3 and array.size(zz_lows_lock) >= 2
        h0 = array.get(zz_highs_lock, 0)
        h1 = array.get(zz_highs_lock, 1)
        h2 = array.get(zz_highs_lock, 2)
        l0 = array.get(zz_lows_lock, 0)
        l1 = array.get(zz_lows_lock, 1)

        if h0 > h1 + atr02 and h1 > h2 + atr02 and l0 > l1 + atr02
            zz_structure := 'HH/HL'
            zz_struct_clr := CLR_BULL
        else if h0 < h1 - atr02 and h1 < h2 - atr02 and l0 < l1 - atr02
            zz_structure := 'LH/LL'
            zz_struct_clr := CLR_BEAR
        else
            zz_structure := 'RANGE'
            zz_struct_clr := CLR_CHOP
    else
        zz_structure := 'FALL_RANGE'
        zz_struct_clr := CLR_CHOP

zz_bull_struct = zz_structure == 'HH/HL'
zz_bear_struct = zz_structure == 'LH/LL'

// ── Last ZigZag Pivot
// Tracks most recent HTF-confirmed pivot
if new_htf_close and array.size(piv_val) > 0
    last_ix = array.size(piv_val) - 1
    zz_last_val := array.get(piv_val, last_ix)
    zz_last_type := array.get(piv_type, last_ix) == 1 ? 'HIGH' : 'LOW'
    zz_last_age := htf_bar_index - array.get(piv_bar, last_ix)

if new_htf_close and ew_state == EW_ACTIVE
    ew_age := htf_bar_index - ew_start_bar

can_detect_ew = ew_state == EW_NONE and array.size(piv_val) >= 5
max_pivot_age = i_ew_max_age * 2

if new_htf_close and can_detect_ew and (zz_bull_struct or zz_bear_struct)
    last_piv_bar := array.get(piv_bar, array.size(piv_bar) - 1)
    piv_age = htf_bar_index - last_piv_bar
    if piv_age <= max_pivot_age
        [found_, dir_, w0_, w1_, w2_, w3_, w4_] = f_detect_ew_strict(piv_val, piv_type, piv_bar, chop, atr, i_min_retr_w2, i_max_retr_w2, i_min_ext_w3)
        price_drift = found_ and atr > 0 ? math.abs(htf_c - w3_) / atr : 999
        if found_ and price_drift <= 5 and ((dir_ == DIR_UP and zz_bull_struct) or (dir_ == DIR_DOWN and zz_bear_struct))
            ew_state := EW_ACTIVE
            ew_dir := dir_
            ew_w0 := w0_
            ew_w1 := w1_
            ew_w2 := w2_
            ew_w3 := w3_
            ew_w4 := w4_
            ew_start_bar := htf_bar_index
            fib_50 := na
            fib_618 := na
            fib_786 := na

// ── EW OVEREXTENSION INVALIDATION ──
ew_overextended = ew_state == EW_ACTIVE and ((ew_dir == DIR_UP   and htf_c > ew_w4 + atr * 1.0) or (ew_dir == DIR_DOWN and htf_c < ew_w4 - atr * 1.0))

if new_htf_close and (ew_age >= i_ew_max_age or ew_overextended)
    ew_state := EW_NONE
    ew_dir := na
    ew_w0 := na
    ew_w1 := na
    ew_w2 := na
    ew_w3 := na
    ew_w4 := na
    fib_50 := na
    fib_618 := na
    fib_786 := na

// ══════════════════════════════════════════════════════════════════════════════
// FIBONACCI & TARGETS
// ══════════════════════════════════════════════════════════════════════════════
// Only recalculate fibs on HTF close to reduce intrabar noise
if ew_state == EW_ACTIVE and new_htf_close and ew_w1 != ew_w0 and atr > 0
    w1_len = math.abs(ew_w1 - ew_w0)
    if ew_dir == DIR_UP
        fib_50 := ew_w1 - w1_len * 0.5
        fib_618 := ew_w1 - w1_len * 0.618
        fib_786 := ew_w1 - w1_len * 0.786
    else
        fib_50 := ew_w1 + w1_len * 0.5
        fib_618 := ew_w1 + w1_len * 0.618
        fib_786 := ew_w1 + w1_len * 0.786

// Hide fib if price already crossed it
if ew_dir == DIR_UP and not na(fib_786) and htf_c < fib_786
    fib_50 := na
    fib_618 := na
    fib_786 := na

if ew_dir == DIR_DOWN and not na(fib_786) and htf_c > fib_786
    fib_50 := na
    fib_618 := na
    fib_786 := na

// ══════════════════════════════════════════════════════════════════════════════
// DASHBOARD
// ══════════════════════════════════════════════════════════════════════════════
force_redraw = new_htf_close or barstate.isfirst
curr_trend = t_dir + ' | ' + t_type + ' | ' + trend_str_state
curr_levels = not na(L1) ? str.tostring(L1, FMT) + ' / ' + str.tostring(L2, FMT) + ' / ' + str.tostring(L3, FMT) : 'N/A'
curr_zz_row = zz_structure + (not na(zz_last_val) ? ' | Last ' + zz_last_type + '@' + str.tostring(zz_last_val, FMT) + ' (' + str.tostring(zz_last_age) + ')' : '')
atr_p = htf_c > 0 ? atr / htf_c * 100 : 0
curr_atr_vol = str.tostring(atr, FMT) + ' (' + str.tostring(atr_p, '#.#') + '%) | Vol: ' + vol_state
curr_ew = ew_state == EW_ACTIVE ? 'EW (' + str.tostring(ew_age) + ' bars): ' +(ew_dir == DIR_UP ? 'UP ' : 'DOWN ') + str.tostring(ew_w1, FMT) + ' -> ' + str.tostring(ew_w2, FMT) + ' | ' + str.tostring(ew_w3, FMT) + ' -> ' + str.tostring(ew_w4, FMT): 'EW: None'
curr_fib = ew_state == EW_ACTIVE ? 'Fib : ' + str.tostring(fib_50, FMT) + ' | ' + str.tostring(fib_618, FMT) + ' | ' + str.tostring(fib_786, FMT) : ''
valid_long = bull and zz_bull_struct and not earnings_block_active
valid_short = bear and zz_bear_struct and not earnings_block_active
zz_ready = array.size(piv_val) >= 5
risk_pct = t_type == 'NORMAL' ? 2 : t_type == 'MOMENTUM' ? 3 : 0
signal_row = valid_long  ? 'Signal: LONG ('  + str.tostring(risk_pct) + '%)' : valid_short ? 'Signal: SHORT (' + str.tostring(risk_pct) + '%)' : bull ? 'Signal: SETUP LONG' : bear ? 'Signal: SETUP SHORT' : 'Signal: NONE'
signal_bg = valid_long ? CLR_BULL : valid_short ? CLR_BEAR : bull ? color.new(CLR_BULL, 40) : bear ? color.new(CLR_BEAR, 40) : CLR_GRAY

row = 0
table.cell(tbl, 0, row, syminfo.ticker + ' | Key Levels', text_color = color.white, bgcolor = CLR_HEADER)
row := row + 1
if force_redraw
    table.cell(tbl, 0, row, 'Ready: ' + rdy_txt, text_color = color.white, bgcolor = rdy_clr)
    row := row + 1

    table.cell(tbl, 0, row, 'Trend: ' + curr_trend, text_color = color.white, bgcolor = t_clr)
    row := row + 1

    table.cell(tbl, 0, row, 'ATR: ' + curr_atr_vol, text_color = color.white, bgcolor = CLR_ATR)
    row := row + 1

    table.cell(tbl, 0, row, 'L1/L2/L3: ' + curr_levels, text_color = color.white, bgcolor = CLR_LEVEL)
    row := row + 1

    table.cell(tbl, 0, row, 'ZZ: ' + curr_zz_row, text_color = color.white, bgcolor = zz_struct_clr)
    row := row + 1

    // Performance: Use cached format strings
    table.cell(tbl, 0, row, 'Highs: ' + cached_zz_highs, text_color = color.white, bgcolor = CLR_BEAR)
    row := row + 1

    table.cell(tbl, 0, row, 'Lows: ' + cached_zz_lows, text_color = color.white, bgcolor = CLR_BULL)
    row := row + 1

    table.cell(tbl, 0, row, signal_row, text_color = color.white, bgcolor = signal_bg)
    row := row + 1

    // Event Risk - Earnings
    if i_enable_earnings and earnings_txt != ''
        table.cell(tbl, 0, row, earnings_txt, text_color = color.white, bgcolor = earnings_clr)
        row := row + 1

    //EW Details
    if i_show_ew_fib and ew_state == EW_ACTIVE
        table.cell(tbl, 0, row, curr_ew, text_color = color.white, bgcolor = ew_state == EW_ACTIVE ? CLR_EW : CLR_GRAY)
        row := row + 1

        table.cell(tbl, 0, row, curr_fib, text_color = color.white, bgcolor = CLR_FIB)
        row := row + 1
