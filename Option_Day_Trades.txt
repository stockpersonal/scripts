//@version=5
indicator("Option Day Trades", overlay=true)

// ARCHITECTURE: [1] INPUTS â†’ [2] CONSTANTS â†’ [3] STATE VARS â†’ [4] SIGNAL LAYER â†’ [5] EVENT LAYER â†’ [6] FSM DISPATCHER â†’ [7] DEBUG

// [1] INPUTS
// Timeframes
calcTF         = input.timeframe("5", "Calc TF", group="Timeframes")
alertTF        = input.timeframe("1", "Alert TF", group="Timeframes")
// Trend Settings
fastEmaLen     = input.int(8, "Fast EMA", group="Trend")
midEmaLen      = input.int(21, "Mid EMA", group="Trend")
slowEmaLen     = input.int(34, "Slow EMA", group="Trend")
pullbackLen    = input.int(3, "Pullback Length", group="Trend")
// Filters
useVWAP        = input.bool(true, "Use VWAP Filter", group="Filters")
minDailyVol    = input.int(150000, "Min Daily Volume", group="Filters")
// Gap Analysis
useGapFilter   = input.bool(true, "Use Gap Filter", group="Gap Analysis", tooltip="Filter signals based on overnight gap direction")
gapThreshold   = input.float(0.3, "Gap Threshold %", group="Gap Analysis", minval=0.1, maxval=5.0, tooltip="TSLA/NVDA: 0.3 | MSTR: 1.0")
gapMode        = input.string("Trend", "Gap Filter Mode", group="Gap Analysis", options=["Trend", "Fade", "Info Only"], tooltip="Trend: Trade with gap | Fade: Trade against gap | Info Only: Just show in alerts")
// ORB Profile Config
useORB         = input.bool(true, "Use ORB Filter", group="Opening Range", tooltip="Require price to break opening range")
orbMinutes     = input.int(10, "ORB Period (minutes)", group="Opening Range", minval=5, maxval=60, tooltip="TSLA/NVDA: 10 | MSTR: 30")
orbMode        = input.string("Breakout", "ORB Mode", group="Opening Range", options=["Breakout", "Info Only"], tooltip="Breakout: Only trade breaks | Info Only: Just show levels")
forceProfile   = input.string("ROTATION", "Force ORB Profile", options=["AUTO","TREND","ROTATION"])
// Previous Day Levels
usePDLevels    = input.bool(true, "Use Prev Day H/L Filter", group="Prev Day Levels", tooltip="Filter based on previous day high/low")
pdBuffer       = input.float(0.15, "PD Level Buffer %", group="Prev Day Levels", minval=0.0, maxval=1.0, tooltip="TSLA: 0.15 | NVDA: 0.15")
// Market Regime
useMarketFilter = input.bool(false, "Use Market Filter", group="Market Regime", tooltip="Filter signals based on market trend (requires data subscription)")
marketSymbol    = input.symbol("SPY", "Market Index", group="Market Regime", tooltip="TSLA: SPY | NVDA: QQQ")
// Time of Day
useTODFilter    = input.bool(true, "Use Time Filter", group="Time of Day", tooltip="Avoid low-volume lunch period")
avoidLunchStart = input.int(11, "Avoid Lunch Start Hour", group="Time of Day", minval=10, maxval=13, tooltip="TSLA/NVDA: 11")
avoidLunchEnd   = input.int(12, "Avoid Lunch End Hour", group="Time of Day", minval=12, maxval=15, tooltip="TSLA/NVDA: 12")
// Visual Labels
showLabels      = input.bool(true, "Show Chart Labels", group="Display", tooltip="Show entry/exit labels on chart for EOD review")
showEntryLine   = input.bool(true, "Show Entry Line", group="Display", tooltip="Draw horizontal line at entry price")
showStopLine    = input.bool(true, "Show Stop Line", group="Display", tooltip="Draw horizontal line at stop loss")
showEarlyAlerts = input.bool(true, "Show EARLY Alerts", group="Display", tooltip="Get heads-up alerts before confirmation")
showDebug       = input.bool(true, "Show Debug Plots", group="Display", tooltip="Show state and event debug plots")
// Targets
t1Pct          = input.float(0.35, "T1 Underlying Move %", group="Targets", tooltip="TSLA/NVDA: 0.35 | MSTR: 1.0 | PLTR: 0.4")
t2Pct          = input.float(0.8, "T2 Underlying Move %", group="Targets", tooltip="TSLA/NVDA: 0.8 | MSTR: 2.5 | PLTR: 0.8")
t3Pct          = input.float(1.6, "T3 Underlying Move %", group="Targets", tooltip="TSLA/NVDA: 1.6 | MSTR: 5.0 | PLTR: 1.5")
optionDelta    = input.float(0.50, "Estimated Option Delta", group="Targets", minval=0.1, maxval=1.0, tooltip="ATM weeklies â‰ˆ 0.50")
// Risk Management
useAtrStop     = input.bool(true, "Use ATR Stop", group="Risk")
atrMultiplier  = input.float(0.8, "ATR Stop Multiplier", group="Risk", tooltip="TSLA/NVDA: 0.8 | MSTR: 1.5 | PLTR: 0.75")
tightStops     = input.bool(true, "Tight Stops (0DTE Mode)", group="Risk", tooltip="ON: Cut losses fast | OFF: Avoid noise")
// Session & Timing
avoidOpenMin    = input.int(15, "Avoid First X Minutes", group="Session", tooltip="Skip chaotic open. 0DTE: 15-30 min")
forceExitHour   = input.int(15, "Force Exit Hour", group="Session", tooltip="0DTE: Consider 15:30 or earlier")
forceExitMin    = input.int(45, "Force Exit Minute", group="Session", tooltip="Exit before gamma risk spikes")
confirmDelayMin = input.int(2, "Confirmation Delay (min)", group="Session")
maxEarlyMin     = input.int(7, "Max Early Window (min)", group="Session")
reentryDelayBars = input.int(0, "Re-entry Cooldown (bars)", group="Session", minval=0, maxval=10, tooltip="Wait X bars after exit before re-entry. 0=immediate")
lockBiasAfterLoss = input.bool(false, "Lock Bias After Loss", group="Session", tooltip="Prevent same-day trend flip after stop/T3 (reduces revenge trades)")
lockBiasAfterWin = input.bool(true, "Lock Bias After Win", group="Session", tooltip="Prevent opposite-direction trades after T3 winner (reduces overtrading)")
entryPriceTolerance = input.float(0.998, "Entry Price Tolerance", group="Session", minval=0.99, maxval=1.0, step=0.001, tooltip="Allow small tolerance on momentum (0.998 = 0.2% tolerance) to prevent delayed entries")

// [2] CONSTANTS
// FSM States
IDLE      = 0
EARLY     = 1
IN_TRADE  = 2
EXITED    = 3
// Direction Bias
BIAS_NONE = 0
BIAS_CALL = 1
BIAS_PUT  = 2
// Exit Reasons (for stats/analytics)
EXIT_NONE   = 0
EXIT_STOP   = 1
EXIT_T3     = 2
EXIT_FORCE  = 3
EXIT_VOL    = 4

// [3] STATE VARIABLES
// CALL STATE
var int   callState         = IDLE
var float callEntry         = na
var float callSL            = na
var int   callEntryBar      = na
var bool  callT1Hit         = false
var bool  callT2Hit         = false
var bool  callT3Hit         = false
var int   callCooldownUntil = na
var int   callEarlyBar      = na
var bool  callOrbPassed     = false
var int   lastEarlyCallAlertTime = na
var int   callExitReason    = EXIT_NONE
// PUT STATE
var int   putState          = IDLE
var float putEntry          = na
var float putSL             = na
var int   putEntryBar       = na
var bool  putT1Hit          = false
var bool  putT2Hit          = false
var bool  putT3Hit          = false
var int   putCooldownUntil  = na
var int   putEarlyBar       = na
var bool  putOrbPassed      = false
var int   lastEarlyPutAlertTime = na
var int   putExitReason     = EXIT_NONE
// SHARED STATE
var int   dayBias           = BIAS_NONE
// ORB STATE
var float orbHigh           = na
var float orbLow            = na
var bool  orbLocked         = false
// VISUAL STATE
var line  callEntryLine     = na
var line  callStopLine      = na
var line  putEntryLine      = na
var line  putStopLine       = na

// [4] SIGNAL LAYER (Pure Logic)
// Session times
sessionStart   = timestamp("America/New_York", year, month, dayofmonth, 9, 30)
sessionEnd     = timestamp("America/New_York", year, month, dayofmonth, 16, 0)
forceExitTime  = timestamp("America/New_York", year, month, dayofmonth, forceExitHour, forceExitMin)
openBufferTime = sessionStart + avoidOpenMin * 60 * 1000
// Day periods
lunchStart     = timestamp("America/New_York", year, month, dayofmonth, avoidLunchStart, 30)
lunchEnd       = timestamp("America/New_York", year, month, dayofmonth, avoidLunchEnd, 30)
inLunchHour    = time >= lunchStart and time <= lunchEnd
morningPower   = time >= openBufferTime and time < lunchStart
afternoonPower = time > lunchEnd and time < forceExitTime
// Session flags
inSession      = time >= sessionStart and time <= sessionEnd
isNewDay       = ta.change(time("D")) != 0
pastOpenBuffer = time >= openBufferTime
allowNewTrades = time < forceExitTime and pastOpenBuffer
// ORB profile config
symbolUpper      = str.upper(syminfo.ticker)
baseOrbProfile   = symbolUpper == "TSLA" ? "TREND" : symbolUpper == "NVDA" ? "ROTATION" : "ROTATION"
orbProfile       = forceProfile == "AUTO" ? baseOrbProfile : forceProfile == "TREND" ? "TREND" : "ROTATION"
orbMinutesUsed   = orbProfile == "TREND" ? 15 : orbProfile == "ROTATION" ? 10 : orbMinutes
confirmDelayUsed = orbProfile == "TREND" ? 3 : orbProfile == "ROTATION" ? 1 : confirmDelayMin
reclaimWindowOK  = orbProfile == "ROTATION" ? time < lunchStart : morningPower
// Bar math
confirmDelayBars  = timeframe.isminutes ? math.ceil(confirmDelayUsed * 60 / timeframe.multiplier) : confirmDelayUsed
maxEarlyBars      = timeframe.isminutes ? math.ceil(maxEarlyMin * 60 / timeframe.multiplier) : maxEarlyMin
earlyCooldownBars = timeframe.isminutes ? math.ceil(2 * 60 / timeframe.multiplier) : 2
// Data feeds
[closeCalc, emaFast, emaMid, emaSlow, vwapVal, sup, res, atrVal, atrSma] = request.security(syminfo.tickerid, calcTF, [close, ta.ema(close, fastEmaLen), ta.ema(close, midEmaLen), ta.ema(close, slowEmaLen), ta.vwap(hlc3), ta.lowest(low, pullbackLen), ta.highest(high, pullbackLen), ta.atr(14), ta.sma(ta.atr(14), 20)], barmerge.gaps_off, barmerge.lookahead_off)
closeExec = request.security(syminfo.tickerid, alertTF, close, barmerge.gaps_off, barmerge.lookahead_off)
[dailyVol, dailyVolSma, dailyOpen, prevDayClose, dailyHigh, dailyLow, prevDayHigh, prevDayLow, prevDailyVol] = request.security(syminfo.tickerid, "D", [volume, ta.sma(volume, 20), open, close[1], high, low, high[1], low[1], volume[1]], barmerge.gaps_off, barmerge.lookahead_off)
[mktClose, mktVwap, mktEmaFast, mktEmaSlow] = request.security(useMarketFilter ? marketSymbol : syminfo.tickerid, calcTF, [close, ta.vwap(hlc3), ta.ema(close, 9), ta.ema(close, 21)], barmerge.gaps_off, barmerge.lookahead_off)

// Volatility
volatilityDead = not na(atrVal) and not na(atrSma) and atrSma > 0 and atrVal < atrSma * 0.7
// Liquidity
liquidityOK = time < timestamp("America/New_York", year, month, dayofmonth, 10, 0) ? prevDailyVol >= minDailyVol : dailyVol >= minDailyVol

// Gap analysis
gapPct      = prevDayClose > 0 ? ((dailyOpen - prevDayClose) / prevDayClose) * 100 : 0
gapSize     = math.abs(gapPct)
isGapUp     = gapPct >= gapThreshold
isGapDown   = gapPct <= -gapThreshold
isNoGap     = gapSize < gapThreshold
gapType     = isGapUp ? "GAP UP +" + str.tostring(gapPct, "#.##") + "%" : isGapDown ? "GAP DOWN " + str.tostring(gapPct, "#.##") + "%" : "NO GAP"
gapSizeType = gapSize >= 2.0 ? "LARGE" : gapSize >= 1.0 ? "MEDIUM" : gapSize >= gapThreshold ? "SMALL" : "FLAT"
gapFilled   = isGapUp ? low <= prevDayClose : isGapDown ? high >= prevDayClose : false
gapAllowsCall = not useGapFilter or gapMode == "Info Only" or (gapMode == "Trend" and (isGapUp or isNoGap)) or (gapMode == "Fade" and (isGapDown or isNoGap))
gapAllowsPut  = not useGapFilter or gapMode == "Info Only" or (gapMode == "Trend" and (isGapDown or isNoGap)) or (gapMode == "Fade" and (isGapUp or isNoGap))

// ORB signals
orbEndTime          = sessionStart + orbMinutesUsed * 60 * 1000
inORBPeriod         = time >= sessionStart and time <= orbEndTime
orbComplete         = time > orbEndTime and not na(orbHigh) and not na(orbLow)
orbBreakoutUp       = orbComplete and close > orbHigh
orbBreakoutDown     = orbComplete and close < orbLow
orbMid              = orbComplete ? (orbHigh + orbLow) / 2 : 0
orbRangePct         = orbComplete and orbMid > 0 ? ((orbHigh - orbLow) / orbMid) * 100 : 0
orbValid            = orbComplete and orbRangePct >= 0.15
orbReclaimUpValid   = orbComplete and ta.crossover(close, orbHigh) and close > orbHigh * 1.0005 and not orbBreakoutUp and not volatilityDead and reclaimWindowOK
orbReclaimDownValid = orbComplete and ta.crossunder(close, orbLow) and close < orbLow * 0.9995 and not orbBreakoutDown and not volatilityDead and reclaimWindowOK
orbAllowsCallProfile = orbProfile == "TREND" ? (orbValid and orbBreakoutUp) : orbProfile == "ROTATION" ? (orbValid and (orbBreakoutUp or orbReclaimUpValid)) : (not useORB or orbMode == "Info Only" or (orbValid and orbBreakoutUp))
orbAllowsPutProfile  = orbProfile == "TREND" ? (orbValid and orbBreakoutDown) : orbProfile == "ROTATION" ? (orbValid and (orbBreakoutDown or orbReclaimDownValid)) : (not useORB or orbMode == "Info Only" or (orbValid and orbBreakoutDown))
orbAllowsCallActive  = not useORB or orbAllowsCallProfile
orbAllowsPutActive   = not useORB or orbAllowsPutProfile
orbInfo = orbComplete ? "ORB H:" + str.tostring(orbHigh, "#.##") + " L:" + str.tostring(orbLow, "#.##") + " (" + str.tostring(orbRangePct, "#.#") + "%)" : "ORB Building"

// Previous day levels
pdBufferPoints = prevDayClose * (pdBuffer / 100)
nearPDH  = closeCalc >= prevDayHigh - pdBufferPoints and closeCalc <= prevDayHigh + pdBufferPoints
nearPDL  = closeCalc >= prevDayLow - pdBufferPoints and closeCalc <= prevDayLow + pdBufferPoints
abovePDH = closeCalc > prevDayHigh + pdBufferPoints
belowPDL = closeCalc < prevDayLow - pdBufferPoints
pdAllowsCall = not usePDLevels or abovePDH or orbBreakoutUp or (not nearPDH and closeCalc > prevDayLow)
pdAllowsPut  = not usePDLevels or belowPDL or orbBreakoutDown or (not nearPDL and closeCalc < prevDayHigh)
pdInfo = "PDH:" + str.tostring(prevDayHigh, "#.##") + " PDL:" + str.tostring(prevDayLow, "#.##")

// Market regime
mktBullish    = mktClose > mktVwap and mktEmaFast > mktEmaSlow
mktBearish    = mktClose < mktVwap and mktEmaFast < mktEmaSlow
mktAllowsCall = not useMarketFilter or mktBullish
mktAllowsPut  = not useMarketFilter or mktBearish
mktTrend      = useMarketFilter ? (mktBullish ? "MKT:BULL" : mktBearish ? "MKT:BEAR" : "MKT:NEUTRAL") : "MKT:OFF"

// Time of day
todAllowsTrade = not useTODFilter or not inLunchHour
todInfo = inLunchHour ? "LUNCH" : morningPower ? "AM-POWER" : afternoonPower ? "PM-POWER" : "SESSION"

// Trend signals
bullTrend = emaFast > emaMid and emaMid > emaSlow and closeCalc > emaFast
bearTrend = emaFast < emaMid and emaMid < emaSlow and closeCalc < emaFast
vwapBull  = not useVWAP or closeCalc > vwapVal
vwapBear  = not useVWAP or closeCalc < vwapVal

// Combined entry signals
callSetupValid        = bullTrend and vwapBull and closeCalc >= emaMid and liquidityOK and gapAllowsCall and orbAllowsCallActive and pdAllowsCall and mktAllowsCall and todAllowsTrade
putSetupValid         = bearTrend and vwapBear and closeCalc <= emaMid and liquidityOK and gapAllowsPut and orbAllowsPutActive and pdAllowsPut and mktAllowsPut and todAllowsTrade
callSetupValidConfirm = orbProfile == "ROTATION" ? (bullTrend and liquidityOK and gapAllowsCall and pdAllowsCall and mktAllowsCall and todAllowsTrade) : callSetupValid
putSetupValidConfirm  = orbProfile == "ROTATION" ? (bearTrend and liquidityOK and gapAllowsPut and pdAllowsPut and mktAllowsPut and todAllowsTrade) : putSetupValid

// Helper functions
calcOptionPnl(entry, exit, isCall, t2Hit) =>
    uPct = isCall ? ((exit - entry) / entry) * 100 : ((entry - exit) / entry) * 100
    oPct = uPct * (t2Hit ? optionDelta * 1.25 : optionDelta)
    [uPct, oPct]

calcStopLoss(entryPrice, isCall, supportLevel, resistLevel, atr, isMorning, isAfternoon) =>
    atrMult = isMorning ? atrMultiplier * 0.8 : isAfternoon ? atrMultiplier * 1.1 : atrMultiplier
    rawSL = isCall ? supportLevel : resistLevel
    atrSL = isCall ? entryPrice - atr * atrMult : entryPrice + atr * atrMult
    sl = useAtrStop ? (tightStops ? (isCall ? math.max(rawSL, atrSL) : math.min(rawSL, atrSL)) : (isCall ? math.min(rawSL, atrSL) : math.max(rawSL, atrSL))) : rawSL
    minDist = atr * 0.25
    sl := isCall ? math.min(sl, entryPrice - minDist) : math.max(sl, entryPrice + minDist)
    hardStop = isCall ? entryPrice * 0.995 : entryPrice * 1.005
    sl := isCall ? math.max(sl, hardStop) : math.min(sl, hardStop)
    sl

updateBiasOnExit(exitReason, direction, currentBias) =>
    isWin = exitReason == EXIT_T3
    isLoss = exitReason == EXIT_STOP
    newBias = isWin and lockBiasAfterWin ? direction : isLoss and lockBiasAfterLoss ? currentBias : isWin ? BIAS_NONE : direction
    newBias


// [5] EVENT LAYER (One-bar truths)
// Helper conditions
callAllowed = (dayBias == BIAS_NONE or dayBias == BIAS_CALL) and putState != EARLY
putAllowed  = (dayBias == BIAS_NONE or dayBias == BIAS_PUT) and callState != EARLY
earlyCallCooldownOK = na(lastEarlyCallAlertTime) or bar_index - lastEarlyCallAlertTime > earlyCooldownBars
earlyPutCooldownOK  = na(lastEarlyPutAlertTime) or bar_index - lastEarlyPutAlertTime > earlyCooldownBars
canConfirmCall = not na(callEarlyBar) and bar_index - callEarlyBar >= confirmDelayBars and bar_index - callEarlyBar <= maxEarlyBars
canConfirmPut  = not na(putEarlyBar) and bar_index - putEarlyBar >= confirmDelayBars and bar_index - putEarlyBar <= maxEarlyBars
reentryCallAllowed = na(callCooldownUntil) or bar_index >= callCooldownUntil
reentryPutAllowed  = na(putCooldownUntil) or bar_index >= putCooldownUntil
entryPriceOKCall = closeExec >= closeCalc * entryPriceTolerance
entryPriceOKPut  = closeExec <= closeCalc / entryPriceTolerance
// CALL events
callEarlyEvent        = callState == IDLE and callSetupValid and inSession and allowNewTrades and not volatilityDead and callAllowed and earlyCallCooldownOK
callEarlyInvalidEvent = callState == EARLY and bar_index > callEarlyBar + 1 and (not bullTrend or not vwapBull)
callEarlyExpireEvent  = callState == EARLY and not na(callEarlyBar) and bar_index - callEarlyBar > maxEarlyBars
callEntryEvent   = callState == EARLY and canConfirmCall and callSetupValidConfirm and callOrbPassed and inSession and allowNewTrades and not volatilityDead and putState != IN_TRADE and entryPriceOKCall
callReentryEvent = callState == EXITED and reentryCallAllowed and callSetupValid and inSession and allowNewTrades and not volatilityDead and (not lockBiasAfterLoss or dayBias == BIAS_CALL)
callStopEvent      = callState == IN_TRADE and bar_index > callEntryBar and low <= callSL
callT3Event        = callState == IN_TRADE and callT2Hit and not callT3Hit and closeExec >= callEntry * (1 + t3Pct/100)
callForceExitEvent = callState == IN_TRADE and time >= forceExitTime and closeExec > callSL
callVolExitEvent   = callState == IN_TRADE and volatilityDead and closeExec > callSL
callT1Event = callState == IN_TRADE and not callT1Hit and closeExec >= callEntry * (1 + t1Pct/100)
callT2Event = callState == IN_TRADE and callT1Hit and not callT2Hit and closeExec >= callEntry * (1 + t2Pct/100)
// PUT events
putEarlyEvent        = putState == IDLE and putSetupValid and inSession and allowNewTrades and not volatilityDead and putAllowed and earlyPutCooldownOK
putEarlyInvalidEvent = putState == EARLY and bar_index > putEarlyBar + 1 and (not bearTrend or not vwapBear)
putEarlyExpireEvent  = putState == EARLY and not na(putEarlyBar) and bar_index - putEarlyBar > maxEarlyBars
putEntryEvent   = putState == EARLY and canConfirmPut and putSetupValidConfirm and putOrbPassed and inSession and allowNewTrades and not volatilityDead and callState != IN_TRADE and entryPriceOKPut
putReentryEvent = putState == EXITED and reentryPutAllowed and putSetupValid and inSession and allowNewTrades and not volatilityDead and (not lockBiasAfterLoss or dayBias == BIAS_PUT)
putStopEvent      = putState == IN_TRADE and bar_index > putEntryBar and high >= putSL
putT3Event        = putState == IN_TRADE and putT2Hit and not putT3Hit and closeExec <= putEntry * (1 - t3Pct/100)
putForceExitEvent = putState == IN_TRADE and time >= forceExitTime and closeExec < putSL
putVolExitEvent   = putState == IN_TRADE and volatilityDead and closeExec < putSL
putT1Event = putState == IN_TRADE and not putT1Hit and closeExec <= putEntry * (1 - t1Pct/100)
putT2Event = putState == IN_TRADE and putT1Hit and not putT2Hit and closeExec <= putEntry * (1 - t2Pct/100)

// [6] FSM DISPATCHER (CONFIRMED BARS ONLY)
if barstate.isconfirmed
    // DAILY RESET
    if isNewDay
        callState := IDLE
        callEntry := na
        callSL := na
        callEntryBar := na
        callT1Hit := false
        callT2Hit := false
        callT3Hit := false
        callCooldownUntil := na
        callEarlyBar := na
        callOrbPassed := false
        lastEarlyCallAlertTime := na
        callExitReason := EXIT_NONE
        putState := IDLE
        putEntry := na
        putSL := na
        putEntryBar := na
        putT1Hit := false
        putT2Hit := false
        putT3Hit := false
        putCooldownUntil := na
        putEarlyBar := na
        putOrbPassed := false
        lastEarlyPutAlertTime := na
        putExitReason := EXIT_NONE
        orbHigh := na
        orbLow := na
        orbLocked := false
        dayBias := BIAS_NONE
        line.delete(callEntryLine)
        line.delete(callStopLine)
        line.delete(putEntryLine)
        line.delete(putStopLine)
        callEntryLine := na
        callStopLine := na
        putEntryLine := na
        putStopLine := na

    // ORB BUILDING
    if inORBPeriod
        orbHigh := na(orbHigh) ? high : math.max(orbHigh, high)
        orbLow := na(orbLow) ? low : math.min(orbLow, low)
    else if not orbLocked and not na(orbHigh) and not na(orbLow)
        orbLocked := true

    if orbProfile == "TREND" and orbBreakoutUp
        callOrbPassed := true
    if orbProfile == "TREND" and orbBreakoutDown
        putOrbPassed := true

    // CALL FSM
    if callEarlyInvalidEvent
        callState := IDLE
        callEarlyBar := na
        callOrbPassed := false
    else if callEarlyExpireEvent
        callState := IDLE
        callEarlyBar := na
        callOrbPassed := false
    else if callStopEvent
        [uPnl, oPnl] = calcOptionPnl(callEntry, closeExec, true, callT2Hit)
        callState := EXITED
        callExitReason := EXIT_STOP
        callCooldownUntil := bar_index + reentryDelayBars
        dayBias := updateBiasOnExit(EXIT_STOP, BIAS_CALL, dayBias)
        alert("[STOP] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | " + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, high, "STOP âœ—\n" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_down, color=color.orange, textcolor=color.white, size=size.small)
        callEntry := na
        callOrbPassed := false
    else if callT3Event
        callT3Hit := true
        [uPnl, oPnl] = calcOptionPnl(callEntry, closeExec, true, callT2Hit)
        callState := EXITED
        callExitReason := EXIT_T3
        callCooldownUntil := bar_index + reentryDelayBars
        dayBias := updateBiasOnExit(EXIT_T3, BIAS_CALL, dayBias)
        alert("[T3] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | +" + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, low, "T3 ðŸŽ¯\n+" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_up, color=color.blue, textcolor=color.white, size=size.small)
        callEntry := na
        callOrbPassed := false
    else if callForceExitEvent
        [uPnl, oPnl] = calcOptionPnl(callEntry, closeExec, true, callT2Hit)
        callState := EXITED
        callExitReason := EXIT_FORCE
        callCooldownUntil := bar_index + reentryDelayBars
        dayBias := BIAS_CALL
        alert("[FORCE] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | " + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, high, "FORCE â±\n" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_down, color=color.gray, textcolor=color.white, size=size.small)
        callEntry := na
        callOrbPassed := false
    else if callVolExitEvent
        [uPnl, oPnl] = calcOptionPnl(callEntry, closeExec, true, callT2Hit)
        callState := EXITED
        callExitReason := EXIT_VOL
        callCooldownUntil := bar_index + reentryDelayBars
        dayBias := BIAS_CALL
        alert("[VOL] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | " + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, high, "VOL â±\n" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_down, color=color.gray, textcolor=color.white, size=size.small)
        callEntry := na
        callOrbPassed := false
    else if callT2Event
        callT2Hit := true
        [uPnl, oPnl] = calcOptionPnl(callEntry, closeExec, true, true)
        alert("[T2] CALL " + syminfo.ticker + " | +" + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, low, "T2 âœ“\n+" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_up, color=color.teal, textcolor=color.white, size=size.tiny)
    else if callT1Event
        callT1Hit := true
        callSL := math.max(callSL, callEntry)
        [uPnl, oPnl] = calcOptionPnl(callEntry, closeExec, true, false)
        alert("[T1] CALL " + syminfo.ticker + " | +" + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, low, "T1 âœ“\n+" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_up, color=color.lime, textcolor=color.black, size=size.tiny)
    else if callEntryEvent
        callState := IN_TRADE
        callEntry := closeExec
        callEntryBar := bar_index
        callT1Hit := false
        callT2Hit := false
        callT3Hit := false
        callExitReason := EXIT_NONE
        dayBias := BIAS_CALL
        callSL := calcStopLoss(callEntry, true, sup, res, atrVal, morningPower, afternoonPower)
        gapInfo = " | " + gapType + " (" + gapSizeType + ")" + (gapFilled ? " [FILLED]" : " [OPEN]")
        ctxInfo = " | " + orbInfo + " | " + pdInfo + " | " + mktTrend + " | " + todInfo
        alert("[CALL] " + syminfo.ticker + " @ " + str.tostring(callEntry, "#.##") + " SL:" + str.tostring(callSL, "#.##") + gapInfo + ctxInfo, alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, low, "â–² CALL\n" + str.tostring(callEntry, "#.##") + "\nSL:" + str.tostring(callSL, "#.##"), style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)
        if showEntryLine
            line.delete(callEntryLine)
            callEntryLine := line.new(bar_index, callEntry, bar_index + 50, callEntry, color=color.green, style=line.style_solid, width=2)
        if showStopLine
            line.delete(callStopLine)
            callStopLine := line.new(bar_index, callSL, bar_index + 50, callSL, color=color.red, style=line.style_dashed, width=1)
    else if callReentryEvent
        callState := EARLY
        callEarlyBar := bar_index
        lastEarlyCallAlertTime := bar_index
        callOrbPassed := orbProfile == "ROTATION" ? orbAllowsCallActive : callOrbPassed
    else if callEarlyEvent
        callState := EARLY
        callEarlyBar := bar_index
        lastEarlyCallAlertTime := bar_index
        callOrbPassed := orbProfile == "ROTATION" ? orbAllowsCallActive : false
        if showEarlyAlerts
            alert("[EARLY] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##"), alert.freq_once_per_bar)

    // PUT FSM
    if putEarlyInvalidEvent
        putState := IDLE
        putEarlyBar := na
        putOrbPassed := false
    else if putEarlyExpireEvent
        putState := IDLE
        putEarlyBar := na
        putOrbPassed := false
    else if putStopEvent
        [uPnl, oPnl] = calcOptionPnl(putEntry, closeExec, false, putT2Hit)
        putState := EXITED
        putExitReason := EXIT_STOP
        putCooldownUntil := bar_index + reentryDelayBars
        dayBias := updateBiasOnExit(EXIT_STOP, BIAS_PUT, dayBias)
        alert("[STOP] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | " + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, low, "STOP âœ—\n" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_up, color=color.orange, textcolor=color.white, size=size.small)
        putEntry := na
        putOrbPassed := false
    else if putT3Event
        putT3Hit := true
        [uPnl, oPnl] = calcOptionPnl(putEntry, closeExec, false, putT2Hit)
        putState := EXITED
        putExitReason := EXIT_T3
        putCooldownUntil := bar_index + reentryDelayBars
        dayBias := updateBiasOnExit(EXIT_T3, BIAS_PUT, dayBias)
        alert("[T3] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | +" + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, high, "T3 ðŸŽ¯\n+" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_down, color=color.purple, textcolor=color.white, size=size.small)
        putEntry := na
        putOrbPassed := false
    else if putForceExitEvent
        [uPnl, oPnl] = calcOptionPnl(putEntry, closeExec, false, putT2Hit)
        putState := EXITED
        putExitReason := EXIT_FORCE
        putCooldownUntil := bar_index + reentryDelayBars
        dayBias := BIAS_PUT
        alert("[FORCE] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | " + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, low, "FORCE â±\n" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_up, color=color.gray, textcolor=color.white, size=size.small)
        putEntry := na
        putOrbPassed := false
    else if putVolExitEvent
        [uPnl, oPnl] = calcOptionPnl(putEntry, closeExec, false, putT2Hit)
        putState := EXITED
        putExitReason := EXIT_VOL
        putCooldownUntil := bar_index + reentryDelayBars
        dayBias := BIAS_PUT
        alert("[VOL] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | " + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, low, "VOL â±\n" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_up, color=color.gray, textcolor=color.white, size=size.small)
        putEntry := na
        putOrbPassed := false
    else if putT2Event
        putT2Hit := true
        [uPnl, oPnl] = calcOptionPnl(putEntry, closeExec, false, true)
        alert("[T2] PUT " + syminfo.ticker + " | +" + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, high, "T2 âœ“\n+" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_down, color=color.fuchsia, textcolor=color.white, size=size.tiny)
    else if putT1Event
        putT1Hit := true
        putSL := math.min(putSL, putEntry)
        [uPnl, oPnl] = calcOptionPnl(putEntry, closeExec, false, false)
        alert("[T1] PUT " + syminfo.ticker + " | +" + str.tostring(oPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, high, "T1 âœ“\n+" + str.tostring(oPnl, "#.#") + "%", style=label.style_label_down, color=color.maroon, textcolor=color.white, size=size.tiny)
    else if putEntryEvent
        putState := IN_TRADE
        putEntry := closeExec
        putEntryBar := bar_index
        putT1Hit := false
        putT2Hit := false
        putT3Hit := false
        putExitReason := EXIT_NONE
        dayBias := BIAS_PUT
        putSL := calcStopLoss(putEntry, false, sup, res, atrVal, morningPower, afternoonPower)
        gapInfo = " | " + gapType + " (" + gapSizeType + ")" + (gapFilled ? " [FILLED]" : " [OPEN]")
        ctxInfo = " | " + orbInfo + " | " + pdInfo + " | " + mktTrend + " | " + todInfo
        alert("[PUT] " + syminfo.ticker + " @ " + str.tostring(putEntry, "#.##") + " SL:" + str.tostring(putSL, "#.##") + gapInfo + ctxInfo, alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, high, "â–¼ PUT\n" + str.tostring(putEntry, "#.##") + "\nSL:" + str.tostring(putSL, "#.##"), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)
        if showEntryLine
            line.delete(putEntryLine)
            putEntryLine := line.new(bar_index, putEntry, bar_index + 50, putEntry, color=color.red, style=line.style_solid, width=2)
        if showStopLine
            line.delete(putStopLine)
            putStopLine := line.new(bar_index, putSL, bar_index + 50, putSL, color=color.green, style=line.style_dashed, width=1)
    else if putReentryEvent
        putState := EARLY
        putEarlyBar := bar_index
        lastEarlyPutAlertTime := bar_index
        putOrbPassed := orbProfile == "ROTATION" ? orbAllowsPutActive : putOrbPassed
    else if putEarlyEvent
        putState := EARLY
        putEarlyBar := bar_index
        lastEarlyPutAlertTime := bar_index
        putOrbPassed := orbProfile == "ROTATION" ? orbAllowsPutActive : false
        if showEarlyAlerts
            alert("[EARLY] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##"), alert.freq_once_per_bar)

    // SESSION END CLEANUP
    if not inSession
        if callState == EXITED
            callState := IDLE
            callOrbPassed := false
        if putState == EXITED
            putState := IDLE
            putOrbPassed := false


// [7] DEBUG PLOTS
plotchar(showDebug and callState == EARLY,    char='E', title="CALL EARLY",    location=location.belowbar, color=color.yellow)
plotchar(showDebug and callState == IN_TRADE, char='I', title="CALL IN TRADE", location=location.belowbar, color=color.green)
plotchar(showDebug and callState == EXITED,   char='X', title="CALL EXITED",   location=location.belowbar, color=color.gray)
plotchar(showDebug and putState == EARLY,    char='e', title="PUT EARLY",    location=location.abovebar, color=color.yellow)
plotchar(showDebug and putState == IN_TRADE, char='i', title="PUT IN TRADE", location=location.abovebar, color=color.red)
plotchar(showDebug and putState == EXITED,   char='x', title="PUT EXITED",   location=location.abovebar, color=color.gray)
plotshape(showDebug ? callEntryEvent : na, "CALL ENTRY", style=shape.triangleup,   location=location.belowbar, color=color.green,  size=size.small)
plotshape(showDebug ? callStopEvent : na,  "CALL STOP",  style=shape.xcross,       location=location.belowbar, color=color.red,    size=size.small)
plotshape(showDebug ? putEntryEvent : na,  "PUT ENTRY",  style=shape.triangledown, location=location.abovebar, color=color.red,    size=size.small)
plotshape(showDebug ? putStopEvent : na,   "PUT STOP",   style=shape.xcross,       location=location.abovebar, color=color.orange, size=size.small)
plotshape(showDebug and callEarlyEvent, title="EARLY CALL", style=shape.circle, location=location.belowbar, color=color.yellow, size=size.tiny)
plotshape(showDebug and putEarlyEvent,  title="EARLY PUT",  style=shape.circle, location=location.abovebar, color=color.yellow, size=size.tiny)
