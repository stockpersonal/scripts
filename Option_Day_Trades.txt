//@version=5
indicator("Option Day Trades", overlay=true)

// INPUTS
calcTF         = input.timeframe("5", "Calc TF", group="Timeframes")
alertTF        = input.timeframe("1", "Alert TF", group="Timeframes")
fastEmaLen     = input.int(8, "Fast EMA", group="Trend")
midEmaLen      = input.int(21, "Mid EMA", group="Trend")
slowEmaLen     = input.int(34, "Slow EMA", group="Trend")
pullbackLen    = input.int(3, "Pullback Length", group="Trend")
useVWAP        = input.bool(true, "Use VWAP Filter", group="Filters")
minDailyVol    = input.int(150000, "Min Daily Volume", group="Filters")
useGapFilter   = input.bool(true, "Use Gap Filter", group="Gap Analysis", tooltip="Filter signals based on overnight gap direction")
gapThreshold   = input.float(0.3, "Gap Threshold %", group="Gap Analysis", minval=0.1, maxval=5.0, tooltip="TSLA/NVDA: 0.3 | MSTR: 1.0")
gapMode        = input.string("Trend", "Gap Filter Mode", group="Gap Analysis", options=["Trend", "Fade", "Info Only"], tooltip="Trend: Trade with gap | Fade: Trade against gap | Info Only: Just show in alerts")
useORB         = input.bool(true, "Use ORB Filter", group="Opening Range", tooltip="Require price to break opening range")
orbMinutes     = input.int(10, "ORB Period (minutes)", group="Opening Range", minval=5, maxval=60, tooltip="TSLA/NVDA: 10 | MSTR: 30")
orbMode        = input.string("Breakout", "ORB Mode", group="Opening Range", options=["Breakout", "Info Only"], tooltip="Breakout: Only trade breaks | Info Only: Just show levels")
usePDLevels    = input.bool(true, "Use Prev Day H/L Filter", group="Prev Day Levels", tooltip="Filter based on previous day high/low")
pdBuffer       = input.float(0.15, "PD Level Buffer %", group="Prev Day Levels", minval=0.0, maxval=1.0, tooltip="TSLA: 0.15 | NVDA: 0.15")
useMarketFilter = input.bool(false, "Use Market Filter", group="Market Regime", tooltip="Filter signals based on market trend (requires data subscription)")
marketSymbol    = input.symbol("SPY", "Market Index", group="Market Regime", tooltip="TSLA: SPY | NVDA: QQQ")
useTODFilter    = input.bool(true, "Use Time Filter", group="Time of Day", tooltip="Avoid low-volume lunch period")
avoidLunchStart = input.int(11, "Avoid Lunch Start Hour", group="Time of Day", minval=10, maxval=13, tooltip="TSLA/NVDA: 11")
avoidLunchEnd   = input.int(12, "Avoid Lunch End Hour", group="Time of Day", minval=12, maxval=15, tooltip="TSLA/NVDA: 12")
showLabels      = input.bool(true, "Show Chart Labels", group="Display", tooltip="Show entry/exit labels on chart for EOD review")
showEntryLine   = input.bool(true, "Show Entry Line", group="Display", tooltip="Draw horizontal line at entry price")
showStopLine    = input.bool(true, "Show Stop Line", group="Display", tooltip="Draw horizontal line at stop loss")
showEarlyAlerts = input.bool(false, "Show EARLY Alerts", group="Display", tooltip="Get heads-up alerts before confirmation")
t1Pct          = input.float(0.35, "T1 Underlying Move %", group="Targets", tooltip="TSLA/NVDA: 0.35 | MSTR: 1.0 | PLTR: 0.4")
t2Pct          = input.float(0.8, "T2 Underlying Move %", group="Targets", tooltip="TSLA/NVDA: 0.8 | MSTR: 2.5 | PLTR: 0.8")
t3Pct          = input.float(1.6, "T3 Underlying Move %", group="Targets", tooltip="TSLA/NVDA: 1.6 | MSTR: 5.0 | PLTR: 1.5")
optionDelta    = input.float(0.50, "Estimated Option Delta", group="Targets", minval=0.1, maxval=1.0, tooltip="ATM weeklies â‰ˆ 0.50")
useAtrStop     = input.bool(true, "Use ATR Stop", group="Risk")
atrMultiplier  = input.float(0.8, "ATR Stop Multiplier", group="Risk", tooltip="TSLA/NVDA: 0.8 | MSTR: 1.5 | PLTR: 0.75")
tightStops     = input.bool(true, "Tight Stops (0DTE Mode)", group="Risk", tooltip="ON: Cut losses fast | OFF: Avoid noise")
avoidOpenMin    = input.int(15, "Avoid First X Minutes", group="Session", tooltip="Skip chaotic open. 0DTE: 15-30 min")
forceExitHour   = input.int(15, "Force Exit Hour", group="Session", tooltip="0DTE: Consider 15:30 or earlier")
forceExitMin    = input.int(45, "Force Exit Minute", group="Session", tooltip="Exit before gamma risk spikes")
confirmDelayMin = input.int(2, "Confirmation Delay (min)", group="Session")
maxEarlyMin     = input.int(7, "Max Early Window (min)", group="Session")
reentryDelayBars = input.int(0, "Re-entry Cooldown (bars)", group="Session", minval=0, maxval=10, tooltip="Wait X bars after exit before re-entry. 0=immediate")

// AUTO PRESETS & CONSTANTS
symbolUpper = str.upper(syminfo.ticker)
isTSLA = symbolUpper == "TSLA"
isNVDA = symbolUpper == "NVDA"
orbProfile = isTSLA ? "TREND" : isNVDA ? "ROTATION" : "DEFAULT"

// Presets (directly applied)
orbMinutesUsed     = isTSLA ? 15 : isNVDA ? 10 : orbMinutes
confirmDelayPreset = isTSLA ? 3 : isNVDA ? 1 : confirmDelayMin
maxEarlyPreset     = isTSLA ? 8 : isNVDA ? 6 : maxEarlyMin
atrMultUsed        = isTSLA ? 0.9 : isNVDA ? 0.75 : atrMultiplier
tightStopsUsed     = isTSLA ? false : isNVDA ? true : tightStops
t1Used             = isTSLA ? 0.4 : isNVDA ? 0.3 : t1Pct
t2Used             = isTSLA ? 1.0 : isNVDA ? 0.75 : t2Pct
t3Used             = isTSLA ? 1.8 : isNVDA ? 1.4 : t3Pct
avoidOpenPreset    = isTSLA ? 20 : isNVDA ? 15 : avoidOpenMin
forceExitHourPreset  = isTSLA ? 15 : isNVDA ? 15 : forceExitHour
forceExitMinPreset   = isTSLA ? 40 : isNVDA ? 45 : forceExitMin

// State constants
IDLE = 0
EARLY = 1
IN_TRADE = 2
EXITED = 3
BIAS_NONE = 0
BIAS_CALL = 1
BIAS_PUT = 2

// SESSION & TIME
sessionStart   = timestamp("America/New_York", year, month, dayofmonth, 9, 30)
sessionEnd     = timestamp("America/New_York", year, month, dayofmonth, 16, 0)
forceExitTime  = timestamp("America/New_York", year, month, dayofmonth, forceExitHourPreset, forceExitMinPreset)
openBufferTime = sessionStart + avoidOpenPreset * 60 * 1000
inSession      = time >= sessionStart and time <= sessionEnd
isNewDay       = ta.change(time("D")) != 0
allowNewTrades = time < forceExitTime and time >= openBufferTime
confirmDelayBars  = math.ceil(confirmDelayPreset * 60 / timeframe.multiplier)
maxEarlyBars      = math.ceil(maxEarlyPreset * 60 / timeframe.multiplier)
earlyCooldownBars = math.ceil(120 / timeframe.multiplier)

// DATA FEEDS
[closeCalc, emaFast, emaMid, emaSlow, vwapVal, sup, res, atrVal, highCalc, lowCalc] = request.security(
     syminfo.tickerid, calcTF, 
     [close, ta.ema(close, fastEmaLen), ta.ema(close, midEmaLen), ta.ema(close, slowEmaLen), 
      ta.vwap(hlc3), ta.lowest(low, pullbackLen), ta.highest(high, pullbackLen), ta.atr(14), high, low], 
     barmerge.gaps_off, barmerge.lookahead_off)
closeExec = request.security(syminfo.tickerid, alertTF, close, barmerge.gaps_off, barmerge.lookahead_off)
[dailyVol, dailyVolSma, dailyOpen, dailyHigh, dailyLow, prevDayHigh, prevDayLow, prevDailyVol] = request.security(syminfo.tickerid, "D", [volume, ta.sma(volume, 20), open, high, low, high[1], low[1], volume[1]], barmerge.gaps_off, barmerge.lookahead_off)
prevDayClose = request.security(syminfo.tickerid, "D", close[1], barmerge.gaps_off, barmerge.lookahead_off)

// FILTERS
// Liquidity
isEarlySession = time < timestamp("America/New_York", year, month, dayofmonth, 10, 0)
rvol           = dailyVolSma > 0 ? dailyVol / dailyVolSma : 0
liquidityOK    = isEarlySession ? prevDailyVol >= minDailyVol : (dailyVol >= minDailyVol and rvol >= 1)

// Gap Analysis
gapPct     = prevDayClose > 0 ? ((dailyOpen - prevDayClose) / prevDayClose) * 100 : 0
gapSize    = math.abs(gapPct)
isGapUp    = gapPct >= gapThreshold
isGapDown  = gapPct <= -gapThreshold
isNoGap    = gapSize < gapThreshold
gapType    = isGapUp ? "GAP UP +" + str.tostring(gapPct, "#.##") + "%" : isGapDown ? "GAP DOWN " + str.tostring(gapPct, "#.##") + "%" : "NO GAP"
gapSizeType = gapSize >= 2.0 ? "LARGE" : gapSize >= 1.0 ? "MEDIUM" : gapSize >= gapThreshold ? "SMALL" : "FLAT"
gapFilled  = isGapUp ? dailyLow <= prevDayClose : isGapDown ? dailyHigh >= prevDayClose : true
gapInfoOnly = not useGapFilter or gapMode == "Info Only"
gapAllowsCall = gapInfoOnly or (gapMode == "Trend" and (isGapUp or isNoGap)) or (gapMode == "Fade" and (isGapDown or isNoGap))
gapAllowsPut  = gapInfoOnly or (gapMode == "Trend" and (isGapDown or isNoGap)) or (gapMode == "Fade" and (isGapUp or isNoGap))

// Opening Range Breakout
orbEndTime  = sessionStart + orbMinutesUsed * 60 * 1000
inORBPeriod = time >= sessionStart and time <= orbEndTime
var float orbHigh = na, var float orbLow = na, var bool orbLocked = false
if inORBPeriod
    orbHigh := na(orbHigh) ? highCalc : math.max(orbHigh, highCalc)
    orbLow  := na(orbLow) ? lowCalc : math.min(orbLow, lowCalc)
else if not orbLocked and not na(orbHigh) and not na(orbLow)
    orbLocked := true
orbComplete     = time > orbEndTime and not na(orbHigh) and not na(orbLow)
orbBreakoutUp   = orbComplete and closeCalc > orbHigh
orbBreakoutDown = orbComplete and closeCalc < orbLow
orbRangePct     = orbComplete and orbLow > 0 ? ((orbHigh - orbLow) / orbLow) * 100 : 0
// Improved ORB reclaim detection: catches intra-bar reclaims better
orbReclaimUp    = orbComplete and (ta.crossover(closeCalc, orbHigh) or (closeCalc >= orbHigh and closeCalc[1] < orbHigh))
orbReclaimDown  = orbComplete and (ta.crossunder(closeCalc, orbLow) or (closeCalc <= orbLow and closeCalc[1] > orbLow))
orbAllowsCallActive = not useORB or orbMode == "Info Only" or (orbProfile == "TREND" ? orbBreakoutUp : orbProfile == "ROTATION" ? (orbBreakoutUp or orbReclaimUp) : orbBreakoutUp)
orbAllowsPutActive  = not useORB or orbMode == "Info Only" or (orbProfile == "TREND" ? orbBreakoutDown : orbProfile == "ROTATION" ? (orbBreakoutDown or orbReclaimDown) : orbBreakoutDown)
orbInfo = orbComplete ? "ORB H:" + str.tostring(orbHigh, "#.##") + " L:" + str.tostring(orbLow, "#.##") + " (" + str.tostring(orbRangePct, "#.#") + "%)" : "ORB Building"

// Previous Day High/Low
pdBufferPoints = prevDayClose * (pdBuffer / 100)
nearPDH  = closeCalc >= prevDayHigh - pdBufferPoints and closeCalc <= prevDayHigh + pdBufferPoints
nearPDL  = closeCalc >= prevDayLow - pdBufferPoints and closeCalc <= prevDayLow + pdBufferPoints
abovePDH = closeCalc > prevDayHigh + pdBufferPoints
belowPDL = closeCalc < prevDayLow - pdBufferPoints
pdAllowsCall = not usePDLevels or abovePDH or (not nearPDH and closeCalc > prevDayLow)
pdAllowsPut  = not usePDLevels or belowPDL or (not nearPDL and closeCalc < prevDayHigh)
pdInfo = "PDH:" + str.tostring(prevDayHigh, "#.##") + " PDL:" + str.tostring(prevDayLow, "#.##")

// Market Regime
[mktClose, mktVwap, mktEmaFast, mktEmaSlow] = request.security(useMarketFilter ? marketSymbol : syminfo.tickerid, calcTF, [close, ta.vwap(hlc3), ta.ema(close, 9), ta.ema(close, 21)], barmerge.gaps_off, barmerge.lookahead_off)
mktBullish = mktClose > mktVwap and mktEmaFast > mktEmaSlow
mktBearish = mktClose < mktVwap and mktEmaFast < mktEmaSlow
mktAllowsCall = not useMarketFilter or mktBullish or (not mktBullish and not mktBearish)
mktAllowsPut  = not useMarketFilter or mktBearish or (not mktBullish and not mktBearish)
mktTrend = useMarketFilter ? (mktBullish ? "MKT:BULL" : mktBearish ? "MKT:BEAR" : "MKT:NEUTRAL") : "MKT:OFF"

// Time of Day
lunchStart  = timestamp("America/New_York", year, month, dayofmonth, avoidLunchStart, 30)
lunchEnd    = timestamp("America/New_York", year, month, dayofmonth, avoidLunchEnd, 30)
inLunchHour = time >= lunchStart and time <= lunchEnd
todAllowsTrade = not useTODFilter or not inLunchHour
todInfo = inLunchHour ? "LUNCH" : time >= openBufferTime and time < lunchStart ? "AM-POWER" : time > lunchEnd and time < forceExitTime ? "PM-POWER" : "SESSION"

// ENTRY CONDITIONS
bullTrend = emaFast > emaMid and emaMid > emaSlow and closeCalc > emaFast
bearTrend = emaFast < emaMid and emaMid < emaSlow and closeCalc < emaFast
baseFilters = liquidityOK and todAllowsTrade
callValid = bullTrend and (not useVWAP or closeCalc > vwapVal) and baseFilters and gapAllowsCall and orbAllowsCallActive and pdAllowsCall and mktAllowsCall
putValid  = bearTrend and (not useVWAP or closeCalc < vwapVal) and baseFilters and gapAllowsPut and orbAllowsPutActive and pdAllowsPut and mktAllowsPut
callValidConfirm = orbProfile == "ROTATION" ? (bullTrend and baseFilters and gapAllowsCall and pdAllowsCall and mktAllowsCall) : callValid
putValidConfirm  = orbProfile == "ROTATION" ? (bearTrend and baseFilters and gapAllowsPut and pdAllowsPut and mktAllowsPut) : putValid

plotshape(callValid, title="CALL VALID", style=shape.circle, location=location.belowbar, color=color.new(color.green, 0), size=size.tiny)
plotshape(putValid, title="PUT VALID", style=shape.circle, location=location.abovebar, color=color.new(color.red, 0), size=size.tiny)

// STATE VARIABLES
var int callState = IDLE, var float callEntry = na, var float callSL = na
var bool callT1Hit = false, var bool callT2Hit = false, var bool callT3Hit = false, var bool callStopHit = false
var int callLastExitBar = na, var int callEntryBar = na, var int callEarlyBar = na, var bool callOrbPassed = false
var bool callWasAboveT1 = false  // Track if price was above T1 after T2 hit (for profit protection)
var float callT1Level = na  // Store T1 level to avoid recalculation

var int putState = IDLE, var float putEntry = na, var float putSL = na
var bool putT1Hit = false, var bool putT2Hit = false, var bool putT3Hit = false, var bool putStopHit = false
var int putLastExitBar = na, var int putEntryBar = na, var int putEarlyBar = na, var bool putOrbPassed = false
var bool putWasBelowT1 = false  // Track if price was below T1 after T2 hit (for profit protection)
var float putT1Level = na  // Store T1 level to avoid recalculation

var int dayBias = BIAS_NONE
var int lastEarlyCallAlertTime = na, var int lastEarlyPutAlertTime = na
var bool callTradedToday = false, var bool putTradedToday = false
var line callEntryLine = na, var line callStopLine = na, var line putEntryLine = na, var line putStopLine = na

// DAILY RESET
if isNewDay
    callState := IDLE, callEntry := na, callSL := na, callLastExitBar := na, callEntryBar := na, callEarlyBar := na
    callT1Hit := false, callT2Hit := false, callT3Hit := false, callStopHit := false, callOrbPassed := false
    callWasAboveT1 := false, callT1Level := na
    putState := IDLE, putEntry := na, putSL := na, putLastExitBar := na, putEntryBar := na, putEarlyBar := na
    putT1Hit := false, putT2Hit := false, putT3Hit := false, putStopHit := false, putOrbPassed := false
    putWasBelowT1 := false, putT1Level := na
    orbHigh := na, orbLow := na, orbLocked := false, dayBias := BIAS_NONE
    lastEarlyCallAlertTime := na, lastEarlyPutAlertTime := na
    callTradedToday := false, putTradedToday := false
    line.delete(callEntryLine), line.delete(callStopLine), line.delete(putEntryLine), line.delete(putStopLine)
    callEntryLine := na, callStopLine := na, putEntryLine := na, putStopLine := na

// STATE MACHINE
if barstate.isconfirmed or barstate.isrealtime
    // Calculate option delta safe once per bar (used in multiple places)
    optionDeltaSafe = math.max(optionDelta, 0.1)  // Ensure minimum 0.1 to prevent division issues
    
    // CALL
    callAllowed = (dayBias == BIAS_NONE or dayBias == BIAS_CALL) and putState != EARLY
    earlyCallCooldownOK = na(lastEarlyCallAlertTime) or bar_index - lastEarlyCallAlertTime > earlyCooldownBars
    
    // IDLE â†’ EARLY
    if callState == IDLE and not callTradedToday and callValid and inSession and allowNewTrades and callAllowed and earlyCallCooldownOK
        callState := EARLY, callEarlyBar := bar_index, lastEarlyCallAlertTime := bar_index
        // For ROTATION profile, ORB must be passed; for others, ORB is checked in callValidConfirm
        callOrbPassed := orbProfile != "ROTATION" ? true : orbAllowsCallActive
        if showEarlyAlerts
            alert("[EARLY CALL] " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Watching for confirmation...", alert.freq_once_per_bar)
    
    // EARLY â†’ IDLE (Invalidation or Expiration)
    if callState == EARLY and (not callValidConfirm or (not na(callEarlyBar) and bar_index - callEarlyBar > maxEarlyBars))
        callState := IDLE, callEarlyBar := na, callOrbPassed := false
    
    // EARLY â†’ IN_TRADE
    canConfirmCall = not na(callEarlyBar) and bar_index - callEarlyBar >= confirmDelayBars
    if callState == EARLY and canConfirmCall and callValidConfirm and callOrbPassed and inSession and allowNewTrades and putState != IN_TRADE
        callState := IN_TRADE, callEntry := closeExec, callEntryBar := bar_index, dayBias := BIAS_CALL, callTradedToday := true
        callT1Hit := false, callT2Hit := false, callT3Hit := false, callStopHit := false, callWasAboveT1 := false
        callT1Level := callEntry * (1 + t1Used/100)  // Calculate and store T1 level once
        // Calculate stop loss for CALL (below entry)
        rawSL = math.min(sup, callEntry * 0.99)  // Cap at 1% below entry as safety
        atrValSafe = math.max(na(atrVal) ? 0 : atrVal, callEntry * 0.001)  // Minimum 0.1% of entry price
        atrSL = callEntry - atrValSafe * atrMultUsed
        callSL := useAtrStop ? (tightStopsUsed ? math.max(rawSL, atrSL) : math.min(rawSL, atrSL)) : rawSL
        callSL := math.min(callSL, callEntry * 0.99)  // Final safety check: ensure stop is always below entry
        gapInfoAlert = " | " + gapType + " (" + gapSizeType + ")" + (gapFilled ? " [FILLED]" : " [OPEN]")
        contextInfo = gapInfoAlert + " | " + orbInfo + " | " + pdInfo + " | " + mktTrend + " | " + todInfo
        alert("[CONFIRMED CALL] " + syminfo.ticker + " Entry: " + str.tostring(callEntry, "#.##") + " SL: " + str.tostring(callSL, "#.##") + contextInfo, alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, low, "â–² CALL\n" + str.tostring(callEntry, "#.##") + "\nSL: " + str.tostring(callSL, "#.##"), style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)
        if showEntryLine
            line.delete(callEntryLine), callEntryLine := line.new(bar_index, callEntry, bar_index + 1000, callEntry, color=color.green, style=line.style_solid, width=2, extend=extend.right)
        if showStopLine
            line.delete(callStopLine), callStopLine := line.new(bar_index, callSL, bar_index + 1000, callSL, color=color.red, style=line.style_dashed, width=1, extend=extend.right)
    
    // IN_TRADE: Targets & Stop
    if callState == IN_TRADE
        callPnl = ((closeExec - callEntry) / callEntry) * 100
        callOptPnl = callPnl / optionDeltaSafe
        if not callT1Hit and closeExec >= callT1Level
            callT1Hit := true
            alert("[T1 HIT] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Underlying: +" + str.tostring(callPnl, "#.##") + "% | Est Option: +" + str.tostring(callOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, low, "T1 âœ“\n+" + str.tostring(callOptPnl, "#.#") + "%", style=label.style_label_up, color=color.lime, textcolor=color.black, size=size.tiny)
        if callT1Hit and not callT2Hit and closeExec >= callEntry * (1 + t2Used/100)
            callT2Hit := true
            alert("[T2 HIT] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Underlying: +" + str.tostring(callPnl, "#.##") + "% | Est Option: +" + str.tostring(callOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, low, "T2 âœ“\n+" + str.tostring(callOptPnl, "#.#") + "%", style=label.style_label_up, color=color.teal, textcolor=color.white, size=size.tiny)
        // Track if price was above T1 after T2 hit (for profit protection)
        if callT2Hit and not callT3Hit and closeExec > callT1Level
            callWasAboveT1 := true
        if callT2Hit and not callT3Hit and closeExec >= callEntry * (1 + t3Used/100)
            callT3Hit := true
            alert("[T3 HIT] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Underlying: +" + str.tostring(callPnl, "#.##") + "% | Est Option: +" + str.tostring(callOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, low, "T3 ðŸŽ¯\n+" + str.tostring(callOptPnl, "#.#") + "%", style=label.style_label_up, color=color.blue, textcolor=color.white, size=size.small)
        // Profit protection: exit if price drops after T1/T2 (check BEFORE original stop)
        if callT2Hit and not callT3Hit and callWasAboveT1 and closeExec <= callT1Level and not callStopHit
            callStopHit := true
            alert("[T2 PROTECT] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Locked T1 gains | Est Option: +" + str.tostring(callOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, high, "T2â†’T1 ðŸ”’\n+" + str.tostring(callOptPnl, "#.#") + "%", style=label.style_label_down, color=color.teal, textcolor=color.white, size=size.small)
        else if callT1Hit and not callT2Hit and closeExec <= callEntry and not callStopHit
            callStopHit := true
            alert("[T1 PROTECT] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Breakeven exit | Est Option: " + str.tostring(callOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, high, "T1â†’BE ðŸ”’\n" + str.tostring(callOptPnl, "#.#") + "%", style=label.style_label_down, color=color.lime, textcolor=color.black, size=size.small)
        // Original stop (only if T1 not hit yet)
        if bar_index > callEntryBar and barstate.isconfirmed and closeExec <= callSL and not callStopHit and not callT1Hit
            callStopHit := true
            alert("[STOP EXIT] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Underlying: " + str.tostring(callPnl, "#.##") + "% | Est Option: " + str.tostring(callOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, high, "STOP âœ—\n" + str.tostring(callOptPnl, "#.#") + "%", style=label.style_label_down, color=color.orange, textcolor=color.white, size=size.small)
    
    // IN_TRADE â†’ EXITED
    if callState == IN_TRADE and (callT3Hit or callStopHit)
        callLastExitBar := bar_index, callState := EXITED, callEntry := na, dayBias := BIAS_NONE, callTradedToday := false
    
    // FORCE EXIT
    if callState == IN_TRADE and time >= forceExitTime and not callStopHit and not callT3Hit
        forcePnl = ((closeExec - callEntry) / callEntry) * 100
        forceOptPnl = forcePnl / optionDeltaSafe
        alert("[FORCE EXIT] CALL " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Underlying: " + str.tostring(forcePnl, "#.##") + "% | Est Option: " + str.tostring(forceOptPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, high, "FORCE â±\n" + str.tostring(forceOptPnl, "#.#") + "%", style=label.style_label_down, color=color.gray, textcolor=color.white, size=size.small)
        callLastExitBar := bar_index, callState := EXITED, callEntry := na, dayBias := BIAS_NONE, callTradedToday := false
    
    // EXITED â†’ EARLY (Re-entry) - blocked if already traded today
    if callState == EXITED and not callTradedToday and callValid and orbAllowsCallActive and inSession and allowNewTrades and bar_index > callLastExitBar + reentryDelayBars
        callState := EARLY, callEarlyBar := bar_index
        // Reset ORB passed status for re-entry
        callOrbPassed := orbProfile != "ROTATION" ? true : orbAllowsCallActive

    // PUT
    putAllowed = (dayBias == BIAS_NONE or dayBias == BIAS_PUT) and callState != EARLY
    earlyPutCooldownOK = na(lastEarlyPutAlertTime) or bar_index - lastEarlyPutAlertTime > earlyCooldownBars
    
    // IDLE â†’ EARLY
    if putState == IDLE and not putTradedToday and putValid and inSession and allowNewTrades and putAllowed and earlyPutCooldownOK
        putState := EARLY, putEarlyBar := bar_index, lastEarlyPutAlertTime := bar_index
        // For ROTATION profile, ORB must be passed; for others, ORB is checked in putValidConfirm
        putOrbPassed := orbProfile != "ROTATION" ? true : orbAllowsPutActive
        if showEarlyAlerts
            alert("[EARLY PUT] " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Watching for confirmation...", alert.freq_once_per_bar)
    
    // EARLY â†’ IDLE (Invalidation or Expiration)
    if putState == EARLY and (not putValidConfirm or (not na(putEarlyBar) and bar_index - putEarlyBar > maxEarlyBars))
        putState := IDLE, putEarlyBar := na, putOrbPassed := false
    
    // EARLY â†’ IN_TRADE
    canConfirmPut = not na(putEarlyBar) and bar_index - putEarlyBar >= confirmDelayBars
    if putState == EARLY and canConfirmPut and putValidConfirm and putOrbPassed and inSession and allowNewTrades and callState != IN_TRADE
        putState := IN_TRADE, putEntry := closeExec, putEntryBar := bar_index, dayBias := BIAS_PUT, putTradedToday := true
        putT1Hit := false, putT2Hit := false, putT3Hit := false, putStopHit := false, putWasBelowT1 := false
        putT1Level := putEntry * (1 - t1Used/100)  // Calculate and store T1 level once
        // Calculate stop loss for PUT (above entry)
        rawSL = math.max(res, putEntry * 1.01)  // Cap at 1% above entry as safety
        atrValSafe = math.max(na(atrVal) ? 0 : atrVal, putEntry * 0.001)  // Minimum 0.1% of entry price
        atrSL = putEntry + atrValSafe * atrMultUsed
        putSL := useAtrStop ? (tightStopsUsed ? math.min(rawSL, atrSL) : math.max(rawSL, atrSL)) : rawSL
        putSL := math.max(putSL, putEntry * 1.01)  // Final safety check: ensure stop is always above entry
        gapInfoAlertPut = " | " + gapType + " (" + gapSizeType + ")" + (gapFilled ? " [FILLED]" : " [OPEN]")
        contextInfoPut = gapInfoAlertPut + " | " + orbInfo + " | " + pdInfo + " | " + mktTrend + " | " + todInfo
        alert("[CONFIRMED PUT] " + syminfo.ticker + " Entry: " + str.tostring(putEntry, "#.##") + " SL: " + str.tostring(putSL, "#.##") + contextInfoPut, alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, high, "â–¼ PUT\n" + str.tostring(putEntry, "#.##") + "\nSL: " + str.tostring(putSL, "#.##"), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)
        if showEntryLine
            line.delete(putEntryLine), putEntryLine := line.new(bar_index, putEntry, bar_index + 1000, putEntry, color=color.red, style=line.style_solid, width=2, extend=extend.right)
        if showStopLine
            line.delete(putStopLine), putStopLine := line.new(bar_index, putSL, bar_index + 1000, putSL, color=color.green, style=line.style_dashed, width=1, extend=extend.right)
    
    // IN_TRADE: Targets & Stop
    if putState == IN_TRADE
        putPnl = ((putEntry - closeExec) / putEntry) * 100
        putOptPnl = putPnl / optionDeltaSafe
        if not putT1Hit and closeExec <= putT1Level
            putT1Hit := true
            alert("[T1 HIT] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Underlying: -" + str.tostring(putPnl, "#.##") + "% | Est Option: +" + str.tostring(putOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, high, "T1 âœ“\n+" + str.tostring(putOptPnl, "#.#") + "%", style=label.style_label_down, color=color.maroon, textcolor=color.white, size=size.tiny)
        if putT1Hit and not putT2Hit and closeExec <= putEntry * (1 - t2Used/100)
            putT2Hit := true
            alert("[T2 HIT] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Underlying: -" + str.tostring(putPnl, "#.##") + "% | Est Option: +" + str.tostring(putOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, high, "T2 âœ“\n+" + str.tostring(putOptPnl, "#.#") + "%", style=label.style_label_down, color=color.fuchsia, textcolor=color.white, size=size.tiny)
        // Track if price was below T1 after T2 hit (for profit protection)
        if putT2Hit and not putT3Hit and closeExec < putT1Level
            putWasBelowT1 := true
        if putT2Hit and not putT3Hit and closeExec <= putEntry * (1 - t3Used/100)
            putT3Hit := true
            alert("[T3 HIT] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Underlying: -" + str.tostring(putPnl, "#.##") + "% | Est Option: +" + str.tostring(putOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, high, "T3 ðŸŽ¯\n+" + str.tostring(putOptPnl, "#.#") + "%", style=label.style_label_down, color=color.purple, textcolor=color.white, size=size.small)
        // Profit protection: exit if price rises after T1/T2 (check BEFORE original stop)
        if putT2Hit and not putT3Hit and putWasBelowT1 and closeExec >= putT1Level and not putStopHit
            putStopHit := true
            alert("[T2 PROTECT] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Locked T1 gains | Est Option: +" + str.tostring(putOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, low, "T2â†’T1 ðŸ”’\n+" + str.tostring(putOptPnl, "#.#") + "%", style=label.style_label_up, color=color.teal, textcolor=color.white, size=size.small)
        else if putT1Hit and not putT2Hit and closeExec >= putEntry and not putStopHit
            putStopHit := true
            alert("[T1 PROTECT] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Breakeven exit | Est Option: " + str.tostring(putOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, low, "T1â†’BE ðŸ”’\n" + str.tostring(putOptPnl, "#.#") + "%", style=label.style_label_up, color=color.lime, textcolor=color.black, size=size.small)
        // Original stop (only if T1 not hit yet)
        if bar_index > putEntryBar and barstate.isconfirmed and closeExec >= putSL and not putStopHit and not putT1Hit
            putStopHit := true
            stopPnl = ((putEntry - closeExec) / putEntry) * 100
            stopOptPnl = stopPnl / optionDeltaSafe
            alert("[STOP EXIT] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Underlying: " + str.tostring(stopPnl, "#.##") + "% | Est Option: " + str.tostring(stopOptPnl, "#.#") + "%", alert.freq_once_per_bar)
            if showLabels
                label.new(bar_index, low, "STOP âœ—\n" + str.tostring(stopOptPnl, "#.#") + "%", style=label.style_label_up, color=color.orange, textcolor=color.white, size=size.small)
    
    // IN_TRADE â†’ EXITED
    if putState == IN_TRADE and (putT3Hit or putStopHit)
        putLastExitBar := bar_index, putState := EXITED, putEntry := na, dayBias := BIAS_NONE, putTradedToday := false
    
    // FORCE EXIT
    if putState == IN_TRADE and time >= forceExitTime and not putStopHit and not putT3Hit
        forcePnl = ((putEntry - closeExec) / putEntry) * 100
        forceOptPnl = forcePnl / optionDeltaSafe
        alert("[FORCE EXIT] PUT " + syminfo.ticker + " @ " + str.tostring(closeExec, "#.##") + " | Underlying: " + str.tostring(forcePnl, "#.##") + "% | Est Option: " + str.tostring(forceOptPnl, "#.#") + "%", alert.freq_once_per_bar)
        if showLabels
            label.new(bar_index, low, "FORCE â±\n" + str.tostring(forceOptPnl, "#.#") + "%", style=label.style_label_up, color=color.gray, textcolor=color.white, size=size.small)
        putLastExitBar := bar_index, putState := EXITED, putEntry := na, dayBias := BIAS_NONE, putTradedToday := false
    
    // EXITED â†’ EARLY (Re-entry) - blocked if already traded today
    if putState == EXITED and not putTradedToday and putValid and orbAllowsPutActive and inSession and allowNewTrades and bar_index > putLastExitBar + reentryDelayBars
        putState := EARLY, putEarlyBar := bar_index
        // Reset ORB passed status for re-entry
        putOrbPassed := orbProfile != "ROTATION" ? true : orbAllowsPutActive

    // SESSION END CLEANUP
    if not inSession
        if callState == IN_TRADE
            // Force exit any open trades at session end
            callLastExitBar := bar_index, callState := EXITED, callEntry := na, dayBias := BIAS_NONE, callTradedToday := false
        else if callState == EXITED
            callState := IDLE
        if putState == IN_TRADE
            // Force exit any open trades at session end
            putLastExitBar := bar_index, putState := EXITED, putEntry := na, dayBias := BIAS_NONE, putTradedToday := false
        else if putState == EXITED
            putState := IDLE

// CONFIG LOCK
var int configLockTime = na
if na(configLockTime)
    configLockTime := timenow
var label configLabel = na
if barstate.islast
    label.delete(configLabel)
    configLabel := label.new(bar_index, high, "LOCKED AT: " + str.format("{0,date,MM-dd HH:mm:ss} ET", configLockTime), style=label.style_label_upper_right, color=color.new(color.red, 75), textcolor=color.white, size=size.small)
