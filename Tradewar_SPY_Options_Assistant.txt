//@version=5
indicator("Tradewar SPY Options Assistant", overlay=true, max_labels_count=500)
// ═══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ═══════════════════════════════════════════════════════════════════════════════
groupCall = "═══ SPY CALLS ═══"
enableCall      = input.bool(true, "Enable CALL Alerts", group=groupCall)
callStrike      = input.float(693, "STRIKE ($)", group=groupCall, step=1)
callExp         = input.string("JAN-12-26", "EXP (e.g., DEC-24-25)", group=groupCall)
callTargetPrice = input.float(694, "TARGET Price ($)", group=groupCall, step=0.01)
callEntry       = input.float(692.25, "ENTRY: Breaks ($)", group=groupCall, step=0.01)

groupPut = "═══ SPY PUTS ═══"
enablePut      = input.bool(true, "Enable PUT Alerts", group=groupPut)
putStrike      = input.float(690, "STRIKE ($)", group=groupPut, step=1)
putExp         = input.string("JAN-12-26", "EXP (e.g., DEC-24-25)", group=groupPut)
putTargetPrice = input.float(688, "TARGET Price ($)", group=groupPut, step=0.01)
putEntry       = input.float(690, "ENTRY: Loses ($)", group=groupPut, step=0.01)

groupSettings = "═══ SETTINGS ═══"
cooldownMin      = input.int(2, "Cooldown After Open (min)", group=groupSettings, minval=1, maxval=10)
lotoWindowEnd    = input.int(55, "LOTO Window End (min)", group=groupSettings, minval=3, maxval=60)
confirmedStart   = input.int(5, "CONFIRMED Start (min)", group=groupSettings, minval=3, maxval=15)
earlyAlertDist   = input.float(0.30, "Early Alert Distance ($)", group=groupSettings, minval=0.10, maxval=1.00, step=0.05)
stopOffset       = input.float(0.5, "Stop Offset ($)", group=groupSettings, minval=0.05, maxval=1.00, step=0.05)
useTrendFilter   = input.bool(false, "Trend Filter (EMA)", group=groupSettings, tooltip="OFF=price only, ON=requires EMA trend")
emaFastLen       = input.int(9, "Fast EMA", group=groupSettings, minval=5, maxval=20, inline="ema")
emaSlowLen       = input.int(21, "Slow EMA", group=groupSettings, minval=10, maxval=50, inline="ema")
useVwapConfirm   = input.bool(false, "Require VWAP Confirmation", group=groupSettings)
useLotoAlert     = input.bool(true, "Enable LOTO Alert", group=groupSettings)
useLotoWindow    = input.bool(true, "LOTO Time Window (2-60 min)", group=groupSettings)
allowLotoReentry = input.bool(false, "Allow LOTO Re-Entry", group=groupSettings)
useBreakEvenStop = input.bool(true, "Break-Even Stop After T1", group=groupSettings)
useTrailingStop  = input.bool(true, "Trail Stop to T1 After T2", group=groupSettings)
useTick          = input.bool(false, "Use TICK Confirmation", group=groupSettings)
tickStartMin     = input.int(30, "TICK Start (min after open)", group=groupSettings, minval=15, maxval=60)
minTickBull      = input.int(200, "Min TICK for CALL", group=groupSettings, minval=-500, maxval=1000)
maxTickBear      = input.int(-200, "Max TICK for PUT", group=groupSettings, minval=-1000, maxval=500)
useVixFilter     = input.bool(false, "Use VIX Filter", group=groupSettings)
vixSymbol        = input.symbol("VIX", "VIX Symbol", group=groupSettings)
vixConfirmedMin  = input.float(15.0, "Min VIX", group=groupSettings, minval=5, maxval=80, step=0.5)
vixConfirmedMax  = input.float(30.0, "Max VIX", group=groupSettings, minval=5, maxval=80, step=0.5)

groupProtection = "═══ PROTECTION ═══"
useSpikeFilter   = input.bool(true, "Block Spike Candles", group=groupProtection)
spikeMultiplier  = input.float(2.0, "Spike Threshold (x Avg)", group=groupProtection, minval=1.5, maxval=4.0, step=0.5)
useVolumeConfirm = input.bool(true, "Require Volume", group=groupProtection)
volumeMultiplier = input.float(1.2, "Volume Threshold (x Avg)", group=groupProtection, minval=1.0, maxval=3.0, step=0.1)
useMiddayFilter  = input.bool(true, "Block Midday (12-13:30)", group=groupProtection)
useHaltDetection = input.bool(true, "Detect Halts", group=groupProtection)
haltGapThreshold = input.int(3, "Halt Gap (min)", group=groupProtection, minval=2, maxval=10)
haltCooldownBars = input.int(2, "Halt Cooldown Bars", group=groupProtection, minval=1, maxval=5)
useFlatBarFilter = input.bool(true, "Block Flat Bars", group=groupProtection)
entryCutoffMin   = input.int(10, "Entry Cutoff (min before close)", group=groupProtection, minval=5, maxval=30)

groupAlerts = "═══ ALERTS ═══"
showWarningAlerts    = input.bool(true, "Show Warning Alerts", group=groupAlerts)
showProtectionAlerts = input.bool(false, "Show Protection Alerts", group=groupAlerts)

groupVisual = "═══ VISUAL ═══"
showLabels          = input.bool(true, "Show Labels", group=groupVisual)
showLabelsOnSPYOnly = input.bool(true, "Labels on SPY Only", group=groupVisual)
showLevelLines      = input.bool(true, "Show Level Lines", group=groupVisual)

// ═══════════════════════════════════════════════════════════════════════════════
// TYPES & CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════════
enum TradeState
    IDLE
    EARLY
    IN_TRADE
    EXITED

MARKET_OPEN = 9 * 60 + 30
MARKET_CLOSE = 16 * 60
EXIT_WARNING_MIN = 15
FORCE_EXIT_MIN = 5
MIDDAY_START = 12 * 60
MIDDAY_END = 13 * 60 + 30
T1_PCT = 0.33
T2_PCT = 0.66
MAX_ENTRY_SLIPPAGE = 0.20
MAX_SCORE = 6

// ═══════════════════════════════════════════════════════════════════════════════
// FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════
//Alerts trigger instantly upon touch, ensuring you don't miss any fast tags.
isAlertBar = barstate.isrealtime or barstate.isconfirmed

parseMonth(m) =>
    u = str.upper(str.trim(m))
    u == "JAN" ? 1 : u == "FEB" ? 2 : u == "MAR" ? 3 : u == "APR" ? 4 : u == "MAY" ? 5 : u == "JUN" ? 6 : u == "JUL" ? 7 : u == "AUG" ? 8 : u == "SEP" ? 9 : u == "OCT" ? 10 : u == "NOV" ? 11 : u == "DEC" ? 12 : 0

parseExp(s) =>
    result = float(na)
    if str.length(s) >= 9
        p = str.split(s, "-")
        if array.size(p) >= 3
            monthNum = parseMonth(array.get(p, 0))
            dayNum = str.tonumber(array.get(p, 1))
            yearNum = str.tonumber(array.get(p, 2))
            if not na(yearNum) and yearNum < 100
                yearNum := yearNum + 2000
            if monthNum > 0 and not na(dayNum) and not na(yearNum)
                result := timestamp(int(yearNum), monthNum, int(dayNum), 16, 0, 0)
    result

// ═══════════════════════════════════════════════════════════════════════════════
// UNIFIED EVENT HANDLER - "Event = Action" Pattern
// Handles alert + label + marking in one place
// ═══════════════════════════════════════════════════════════════════════════════
// Helper: Calculate label Y-offset for targets (above/below price)
getLabelOffset(bool isCall, float hi, float lo) =>
    rangeLocal = hi - lo
    isCall ? hi + rangeLocal * 0.25 : lo - rangeLocal * 0.25

handleTradeEvent(bool isCall, string alertMsg, string labelText, color labelColor, bool labelUp, float labelY, bool showAlert = true, bool showLabel = true) =>
    isSPY = str.upper(syminfo.ticker) == "SPY"
    canShowLabels = showLabels and (not showLabelsOnSPYOnly or isSPY)
    labelStyle = labelUp ? label.style_label_up : label.style_label_down
    
    // Fire alert immediately
    if isAlertBar and showAlert
        alert(alertMsg, alert.freq_once_per_bar)
    
    // Draw label immediately
    if canShowLabels and showLabel
        label.new(bar_index, labelY, labelText, xloc=xloc.bar_index, yloc=yloc.price, color=labelColor, style=labelStyle, textcolor=color.white, size=size.small)

formatScore(int score) =>
    "Score: " + str.tostring(score) + "/" + str.tostring(MAX_SCORE)

// ═══════════════════════════════════════════════════════════════════════════════
// PERSISTENT STATE - Consolidated flags (one per event instead of alert/label separate)
// ═══════════════════════════════════════════════════════════════════════════════
var TradeState callState = TradeState.IDLE
var TradeState putState = TradeState.IDLE
var string callEntryMode = ""
var string putEntryMode = ""
var int callEntryBar = na
var int putEntryBar = na
var bool callEarlyLocked = false
var bool callEarlyFiredToday = false
var bool putEarlyLocked  = false
var bool putEarlyFiredToday = false
var bool callGapPending = false
var bool putGapPending = false
var float callEntryPrice = na
var float putEntryPrice = na
var float callStopPrice = na
var float putStopPrice = na
var float callT1Final = na
var float putT1Final = na
var float callT2Final = na
var float putT2Final = na
var float callT3Final = na
var float putT3Final = na
var bool callT1Hit = false
var bool callT2Hit = false
var bool putT1Hit = false
var bool putT2Hit = false

// Consolidated event handled flags (replaces separate callEntryAlerted/callEntryLabeled, etc.)
var bool callEventHandled_Early = false
var bool callEventHandled_GapPend = false
var bool callEventHandled_Entry = false
var bool callEventHandled_T1 = false
var bool callEventHandled_T2 = false
var bool callEventHandled_Stop = false
var bool callEventHandled_Exit = false

var bool putEventHandled_Early = false
var bool putEventHandled_GapPend = false
var bool putEventHandled_Entry = false
var bool putEventHandled_T1 = false
var bool putEventHandled_T2 = false
var bool putEventHandled_Stop = false
var bool putEventHandled_Exit = false

// Protection alert latches (per-side to allow both Call and Put alerts)
var bool callSpikeAlertFired = false
var bool putSpikeAlertFired = false
var bool callVolumeAlertFired = false
var bool putVolumeAlertFired = false
var bool callMiddayAlertFired = false
var bool putMiddayAlertFired = false
var bool callSlippageAlertFired = false
var bool putSlippageAlertFired = false
var bool haltAlertFired = false
var int configLockTime = na
configLockTime := na(configLockTime) ? timenow : configLockTime

// ═══════════════════════════════════════════════════════════════════════════════
// MARKET DATA
// ═══════════════════════════════════════════════════════════════════════════════
[m1Close, m1High, m1Low, m1Close1, m1EmaFast, m1EmaSlow, m1Vwap, m1CandleRange, m1AvgRange, m1Volume, m1VolAvg] = request.security(syminfo.tickerid, "1", [close, high, low, close[1], ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen), ta.vwap(close), high - low, ta.sma(high - low, 20), volume, ta.sma(volume, 20)], lookahead=barmerge.lookahead_off)
[m5EmaFast, m5EmaSlow, m5Vwap, m5Close] = request.security(syminfo.tickerid, "5", [ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen), ta.vwap(close), close], lookahead=barmerge.lookahead_off)
[vixCloseRaw, vixEmaRaw] = request.security(vixSymbol, "5", [close, ta.ema(close, 20)], lookahead=barmerge.lookahead_off)
vixClose = useVixFilter ? vixCloseRaw : na
vixEma = useVixFilter ? vixEmaRaw : na
tickRaw = request.security("USI:TICK", timeframe.period, close, lookahead=barmerge.lookahead_off)
priceNow = m1Close
priceHigh = m1High
priceLow = m1Low
pricePrev = m1Close1

// ═══════════════════════════════════════════════════════════════════════════════
// DERIVED CALCULATIONS
// ═══════════════════════════════════════════════════════════════════════════════
var string SESSION_STRING = str.format("{0,number,00}{1,number,00}-{2,number,00}{3,number,00}", 9, 30, 16, 0)
minutesET = hour(time, "America/New_York") * 60 + minute(time, "America/New_York")
isRTH = not na(time(timeframe.period, SESSION_STRING, "America/New_York"))
minutesSinceOpen = minutesET - MARKET_OPEN
minutesToClose = MARKET_CLOSE - minutesET

// Per-side expiration checks (required when Call & Put have different expirations)
callExpirationTs = parseExp(callExp)
putExpirationTs = parseExp(putExp)
callExpired = not na(callExpirationTs) and time >= callExpirationTs
putExpired = not na(putExpirationTs) and time >= putExpirationTs
callDte = na(callExpirationTs) ? 1 : math.max(0, math.floor((callExpirationTs - time) / 86400000))
putDte = na(putExpirationTs) ? 1 : math.max(0, math.floor((putExpirationTs - time) / 86400000))
is0DTE = callDte == 0 or putDte == 0
is1DTE = callDte == 1 or putDte == 1

inCooldown = isRTH and minutesSinceOpen >= 0 and minutesSinceOpen < cooldownMin
lotoWindowOK = minutesSinceOpen >= cooldownMin and minutesSinceOpen < lotoWindowEnd
confirmedOK = minutesSinceOpen >= confirmedStart
approachingOK = minutesSinceOpen >= cooldownMin

// VIX gating
vixTrendUp = useVixFilter and not na(vixEma) and ta.rising(vixEma, 3)
vixRising = useVixFilter and not na(vixClose) and not na(vixEma) and vixClose > vixEma
vixLowVol = useVixFilter and not na(vixClose) and vixClose < vixConfirmedMin
vixHighVol = useVixFilter and not na(vixClose) and vixClose > vixConfirmedMax
vixAllowsLoto = not useVixFilter or (vixRising and vixTrendUp and not vixLowVol)
vixAllowsConfirmed = not useVixFilter or not vixHighVol

// TICK confirmation
tickDataReady = useTick and minutesSinceOpen >= tickStartMin
tick = tickDataReady ? tickRaw : na
tickBullish = not useTick or not tickDataReady or na(tick) or tick >= minTickBull
tickBearish = not useTick or not tickDataReady or na(tick) or tick <= maxTickBear

// Exit timing
forceExit = (is0DTE or is1DTE) and minutesToClose <= FORCE_EXIT_MIN
isExit15MinWarning = (is0DTE or is1DTE) and minutesToClose <= EXIT_WARNING_MIN and minutesToClose > FORCE_EXIT_MIN

// Filters
isSpike = useSpikeFilter and not na(m1AvgRange) and m1CandleRange > m1AvgRange * spikeMultiplier
volumeOK = not useVolumeConfirm or (bar_index > 20 and not na(m1VolAvg) and m1Volume > m1VolAvg * volumeMultiplier)
inMiddayChop = useMiddayFilter and minutesET >= MIDDAY_START and minutesET < MIDDAY_END
// Note: Halt detection uses realtime-only gap calculation, so halts won't be detected in replay mode
haltGapMinutes = barstate.isrealtime and not na(time[1]) ? (time - time[1]) / 60000 : 0
isPossibleHalt = useHaltDetection and haltGapMinutes >= haltGapThreshold and isRTH and isRTH[1] and bar_index > 10
barsSinceHalt = ta.barssince(isPossibleHalt)
inHaltCooldown = useHaltDetection and not na(barsSinceHalt) and barsSinceHalt <= haltCooldownBars
isFlatBar = useFlatBarFilter and priceHigh == priceLow
canEnterTime = minutesToClose > entryCutoffMin
cooldownJustEnded = minutesSinceOpen == cooldownMin and minutesSinceOpen[1] < cooldownMin

callCommonEntryFilters = isRTH and not callExpired and not isSpike and volumeOK and not inMiddayChop and not forceExit and not isPossibleHalt and not inHaltCooldown and not isFlatBar and canEnterTime
putCommonEntryFilters = isRTH and not putExpired and not isSpike and volumeOK and not inMiddayChop and not forceExit and not isPossibleHalt and not inHaltCooldown and not isFlatBar and canEnterTime
callBaseEntryFilters = callCommonEntryFilters and not cooldownJustEnded
putBaseEntryFilters = putCommonEntryFilters and not cooldownJustEnded

// ═══════════════════════════════════════════════════════════════════════════════
// TREND DETECTION
// ═══════════════════════════════════════════════════════════════════════════════
emaBullish5m = m5EmaFast > m5EmaSlow
emaBearish5m = m5EmaFast < m5EmaSlow
vwapBullish5m = m5Close > m5Vwap
vwapBearish5m = m5Close < m5Vwap
confirmedUptrend = emaBullish5m and (not useVwapConfirm or m5Close >= m5Vwap - 0.05)
confirmedDowntrend = emaBearish5m and (not useVwapConfirm or m5Close <= m5Vwap + 0.05)

emaBullish1m = m1EmaFast > m1EmaSlow
emaBearish1m = m1EmaFast < m1EmaSlow
vwapBullish1m = m1Close > m1Vwap
vwapBearish1m = m1Close < m1Vwap
lotoUptrend = emaBullish1m and (not useVwapConfirm or vwapBullish1m)
lotoDowntrend = emaBearish1m and (not useVwapConfirm or vwapBearish1m)
pureDowntrend5m = emaBearish5m and vwapBearish5m
pureUptrend5m = emaBullish5m and vwapBullish5m

// Entry permissions
callConfirmedAllowed = not useTrendFilter or confirmedUptrend
putConfirmedAllowed = not useTrendFilter or confirmedDowntrend
callLotoAllowed = useLotoAlert and lotoUptrend and not pureDowntrend5m and (allowLotoReentry or callState != TradeState.IN_TRADE) and vixAllowsLoto
putLotoAllowed = useLotoAlert and lotoDowntrend and not pureUptrend5m and (allowLotoReentry or putState != TradeState.IN_TRADE) and vixAllowsLoto
callConfirmedAllowed := callConfirmedAllowed and vixAllowsConfirmed and tickBullish
putConfirmedAllowed := putConfirmedAllowed and vixAllowsConfirmed and tickBearish

lateLoto = minutesSinceOpen > 25
callLotoAllowed := callLotoAllowed and (not lateLoto or pureUptrend5m)
putLotoAllowed := putLotoAllowed and (not lateLoto or pureDowntrend5m)

// ═══════════════════════════════════════════════════════════════════════════════
// HELPER CONDITIONS
// ═══════════════════════════════════════════════════════════════════════════════
hasCall = enableCall and callEntry > 0 and callTargetPrice > callEntry
hasPut = enablePut and putEntry > 0 and putTargetPrice < putEntry
callApproaching = hasCall and priceLow < callEntry and priceHigh >= callEntry - earlyAlertDist and approachingOK
putApproaching = hasPut and priceHigh > putEntry and priceLow <= putEntry + earlyAlertDist and approachingOK
callBreak = hasCall and priceNow >= callEntry and pricePrev < callEntry
putBreak = hasPut and priceNow <= putEntry and pricePrev > putEntry
isFirstBarOfDay = isRTH and not isRTH[1]
callGapThrough = isFirstBarOfDay and hasCall and priceNow >= callEntry
putGapThrough = isFirstBarOfDay and hasPut and priceNow <= putEntry
callBreakOrGap = callBreak or callGapThrough or (callGapPending and priceNow >= callEntry)
putBreakOrGap = putBreak or putGapThrough or (putGapPending and priceNow <= putEntry)

// Allow entry if price is at entry level (handles case where opposite trade exits and price was at entry)
callPriceAtEntry = hasCall and math.abs(priceNow - callEntry) <= 0.10 and (callState == TradeState.IDLE or callState == TradeState.EARLY)
putPriceAtEntry = hasPut and math.abs(priceNow - putEntry) <= 0.10 and (putState == TradeState.IDLE or putState == TradeState.EARLY)

callCanEnter = (callBreakOrGap or callPriceAtEntry) and callBaseEntryFilters and priceNow <= callEntry + MAX_ENTRY_SLIPPAGE
callLotoReady = callCanEnter and (not useLotoWindow or lotoWindowOK) and callLotoAllowed
callConfirmedReady = callCanEnter and confirmedOK and callConfirmedAllowed and not callLotoReady
callPriceAtEntryMinimalFilters = isRTH and not callExpired and not forceExit
callPriceAtEntryBasicAllowed = not useTrendFilter or confirmedUptrend
callPriceAtEntryReady = callPriceAtEntry and callPriceAtEntryMinimalFilters and callPriceAtEntryBasicAllowed and not callLotoReady
callReadyToEnter = (callState == TradeState.IDLE or callState == TradeState.EARLY) and callState != TradeState.EXITED and (callLotoReady or callConfirmedReady or callPriceAtEntryReady)
callEntryType = callLotoReady ? "LOTO" : (callConfirmedReady or callPriceAtEntryReady) ? "CONFIRMED" : ""

putCanEnter = (putBreakOrGap or putPriceAtEntry) and putBaseEntryFilters and priceNow >= putEntry - MAX_ENTRY_SLIPPAGE
putLotoReady = putCanEnter and (not useLotoWindow or lotoWindowOK) and putLotoAllowed
putConfirmedReady = putCanEnter and confirmedOK and putConfirmedAllowed and not putLotoReady
putPriceAtEntryMinimalFilters = isRTH and not putExpired and not forceExit
putPriceAtEntryBasicAllowed = not useTrendFilter or confirmedDowntrend
putPriceAtEntryReady = putPriceAtEntry and putPriceAtEntryMinimalFilters and putPriceAtEntryBasicAllowed and not putLotoReady
putReadyToEnter = (putState == TradeState.IDLE or putState == TradeState.EARLY) and putState != TradeState.EXITED and (putLotoReady or putConfirmedReady or putPriceAtEntryReady)
putEntryType = putLotoReady ? "LOTO" : (putConfirmedReady or putPriceAtEntryReady) ? "CONFIRMED" : ""

callSlippageBlocked = callBreakOrGap and callCommonEntryFilters and priceNow > callEntry + MAX_ENTRY_SLIPPAGE and (callState == TradeState.IDLE or callState == TradeState.EARLY) and (not useTrendFilter or confirmedUptrend) and (callLotoAllowed or callConfirmedAllowed)
putSlippageBlocked = putBreakOrGap and putCommonEntryFilters and priceNow < putEntry - MAX_ENTRY_SLIPPAGE and (putState == TradeState.IDLE or putState == TradeState.EARLY) and (not useTrendFilter or confirmedDowntrend) and (putLotoAllowed or putConfirmedAllowed)

if callSlippageBlocked and barstate.isconfirmed and not callSlippageAlertFired
    handleTradeEvent(true, "[SLIPPAGE] CALL $" + str.tostring(callStrike, "#") + "C blocked", "SLIPPAGE", color.new(color.red, 70), false, priceHigh, showProtectionAlerts, true)
    callSlippageAlertFired := true
if putSlippageBlocked and barstate.isconfirmed and not putSlippageAlertFired
    handleTradeEvent(false, "[SLIPPAGE] PUT $" + str.tostring(putStrike, "#") + "P blocked", "SLIPPAGE", color.new(color.red, 70), true, priceLow, showProtectionAlerts, true)
    putSlippageAlertFired := true

// ═══════════════════════════════════════════════════════════════════════════════
// ENTRY SCORE (0–6)
// ═══════════════════════════════════════════════════════════════════════════════
scoreTrendCall   = confirmedUptrend ? 1 : 0
scoreTrendPut    = confirmedDowntrend ? 1 : 0
scoreVwapCall    = not useVwapConfirm or vwapBullish5m ? 1 : 0
scoreVwapPut     = not useVwapConfirm or vwapBearish5m ? 1 : 0
scoreVolume      = volumeOK ? 1 : 0
scoreNoSpike     = not isSpike ? 1 : 0
scoreNoMidday    = not inMiddayChop ? 1 : 0
scoreTickCall    = not useTick or tickBullish ? 1 : 0
scoreTickPut     = not useTick or tickBearish ? 1 : 0

callEntryScore = scoreTrendCall + scoreVwapCall + scoreVolume + scoreNoSpike + scoreNoMidday + scoreTickCall
putEntryScore = scoreTrendPut + scoreVwapPut + scoreVolume + scoreNoSpike + scoreNoMidday + scoreTickPut

// ═══════════════════════════════════════════════════════════════════════════════
// GENERIC TRADE PROCESSING FUNCTION - Eliminates Call/Put duplication
// ═══════════════════════════════════════════════════════════════════════════════
processTrade(bool isCall, TradeState state, bool earlyFiredToday, bool earlyLocked, bool gapPending, float entryPrice, float stopPrice, float t1Final, float t2Final, float t3Final, bool t1Hit, bool t2Hit, int entryBar, string entryMode, bool eventHandled_Early, bool eventHandled_GapPend, bool eventHandled_Entry, bool eventHandled_T1, bool eventHandled_T2, bool eventHandled_Stop, bool eventHandled_Exit, float entry, float target, float strike, string exp, bool approaching, bool breakOrGap, bool priceAtEntry, bool readyToEnter, string entryType, bool gapThrough, bool expired, int entryScore ) =>
    TradeState newState = state
    bool newEarlyFiredToday = earlyFiredToday
    bool newEarlyLocked = earlyLocked
    bool newGapPending = gapPending
    float newEntryPrice = entryPrice
    float newStopPrice = stopPrice
    float newT1Final = t1Final
    float newT2Final = t2Final
    float newT3Final = t3Final
    bool newT1Hit = t1Hit
    bool newT2Hit = t2Hit
    int newEntryBar = entryBar
    string newEntryMode = entryMode
    bool newEventHandled_Early = eventHandled_Early
    bool newEventHandled_GapPend = eventHandled_GapPend
    bool newEventHandled_Entry = eventHandled_Entry
    bool newEventHandled_T1 = eventHandled_T1
    bool newEventHandled_T2 = eventHandled_T2
    bool newEventHandled_Stop = eventHandled_Stop
    bool newEventHandled_Exit = eventHandled_Exit
    
    scoreText = formatScore(entryScore)
    // Handle gap pending
    if gapThrough and inCooldown and not gapPending
        newGapPending := true
        if not eventHandled_GapPend
            handleTradeEvent(isCall, "[GAP PENDING] " + (isCall ? "CALL" : "PUT") + " $" + str.tostring(strike, "#") + (isCall ? "C" : "P") + " | Entry queued", "GAP", color.new(color.orange, 50), not isCall, isCall ? priceHigh : priceLow, showWarningAlerts, true)
            newEventHandled_GapPend := true
    
    // Reset gap pending if conditions no longer allow entry (time cutoff, midday chop, or expired)
    if gapPending and (not canEnterTime or inMiddayChop or expired)
        newGapPending := false
        newEventHandled_GapPend := false
    
    // Handle early alert
    earlyFilters = isRTH and not expired and not isSpike and volumeOK and not inMiddayChop and not isPossibleHalt and not inHaltCooldown and canEnterTime
    if state == TradeState.IDLE and approaching and earlyFilters and not earlyFiredToday and not earlyLocked
        newState := TradeState.EARLY
        newEarlyFiredToday := true
        newEarlyLocked := true
        if not eventHandled_Early
            handleTradeEvent(isCall, "[EARLY] " + (isCall ? "CALL" : "PUT") + " $" + str.tostring(strike, "#") + (isCall ? "C" : "P") + " " + exp + " | $" + str.tostring(priceNow, "#.##") + " → $" + str.tostring(entry, "#.##"), "EARLY", color.new(color.yellow, 20), not isCall, isCall ? priceHigh : priceLow)
            newEventHandled_Early := true
    
    // Handle entry
    if readyToEnter and not eventHandled_Entry
        newEntryPrice := entry
        newStopPrice := isCall ? entry - stopOffset : entry + stopOffset
        targetDist = isCall ? target - entry : entry - target
        newT1Final := newEntryPrice + (targetDist * T1_PCT * (isCall ? 1 : -1))
        newT2Final := newEntryPrice + (targetDist * T2_PCT * (isCall ? 1 : -1))
        newT3Final := newEntryPrice + (targetDist * (isCall ? 1 : -1))
        newEntryMode := entryType
        newEntryBar := bar_index
        newGapPending := false
        newState := TradeState.IN_TRADE
        newT1Hit := false
        newT2Hit := false
        // Reset event flags for new trade
        newEventHandled_Early := false
        newEventHandled_T1 := false
        newEventHandled_T2 := false
        newEventHandled_Stop := false
        newEventHandled_Exit := false
        
        // Fire entry event immediately
        labelText = (entryType == "LOTO" ? "LOTO" : (entryType == "CONFIRMED" ? "CONFIRMED" : (isCall ? "CALL" : "PUT"))) + "\n" + scoreText
        handleTradeEvent(isCall, "[" + (isCall ? "CALL" : "PUT") + "][" + entryType + "][" + "SCORE " + str.tostring(entryScore) + "/" + str.tostring(MAX_SCORE) + "] $" + str.tostring(strike) + " " + exp + " E$" + str.tostring(newEntryPrice), labelText, entryType == "LOTO" ? color.orange : (isCall ? color.green : color.new(color.red, 20)), isCall, isCall ? priceLow : priceHigh)
        newEventHandled_Entry := true
    
    // Handle targets and stops while in trade
    if newState == TradeState.IN_TRADE and bar_index > newEntryBar
        // Check stop loss (before targets)
        if newState == TradeState.IN_TRADE and not newEventHandled_Exit and not na(newStopPrice)
            stopHit = isCall ? priceLow <= newStopPrice : priceHigh >= newStopPrice
            if stopHit
                newState := TradeState.EXITED
                // Note: Resetting earlyFiredToday allows EARLY alert to fire again after exit in same session
                newEarlyFiredToday := false
                newEarlyLocked := false
                if not newEventHandled_Exit
                    handleTradeEvent(isCall, "[" + (isCall ? "CALL" : "PUT") + " STOP HIT]", "STOP", color.red, isCall, isCall ? priceLow : priceHigh)
                    newEventHandled_Stop := true
                    newEventHandled_Exit := true
        if newState == TradeState.IN_TRADE
            // Check T1
            if not newT1Hit and not na(newT1Final)
                t1HitNow = isCall ? priceHigh >= newT1Final : priceLow <= newT1Final
                if t1HitNow
                    newT1Hit := true
                    if useBreakEvenStop
                        newStopPrice := newEntryPrice
                    if not newEventHandled_T1
                        t1Msg = useBreakEvenStop ? " Stop→BE" : ""
                        handleTradeEvent(isCall, "[" + (isCall ? "CALL" : "PUT") + " T1] $" + str.tostring(newT1Final, "#.##") + t1Msg, "T1", color.new(color.blue, 20), not isCall, getLabelOffset(isCall, priceHigh, priceLow))
                        newEventHandled_T1 := true
            
            // Check T2
            if newT1Hit and not newT2Hit and not na(newT2Final)
                t2HitNow = isCall ? priceHigh >= newT2Final : priceLow <= newT2Final
                if t2HitNow
                    newT2Hit := true
                    if useTrailingStop
                        newStopPrice := newT1Final
                    if not newEventHandled_T2
                        t2Msg = useTrailingStop ? " Stop→T1" : ""
                        handleTradeEvent(isCall, "[" + (isCall ? "CALL" : "PUT") + " T2] $" + str.tostring(newT2Final, "#.##") + t2Msg, "T2", color.blue, not isCall, getLabelOffset(isCall, priceHigh, priceLow))
                        newEventHandled_T2 := true
            
            // Check T3 (target hit)
            if newT2Hit and not na(newT3Final)
                t3Hit = isCall ? priceHigh >= newT3Final : priceLow <= newT3Final
                if t3Hit
                    newState := TradeState.EXITED
                    // Note: Resetting earlyFiredToday allows EARLY alert to fire again after exit in same session
                    newEarlyFiredToday := false
                    newEarlyLocked := false
                    if not newEventHandled_Exit
                        handleTradeEvent(isCall, "[" + (isCall ? "CALL" : "PUT") + " TARGET HIT]", "TARGET", color.green, not isCall, getLabelOffset(isCall, priceHigh, priceLow))
                        newEventHandled_Exit := true
    
    // Handle early state reset
    if newState == TradeState.EARLY
        earlyDisengaged = isCall ? low > entry + earlyAlertDist : high < entry - earlyAlertDist
        if earlyDisengaged
            newState := TradeState.IDLE
            newEventHandled_Early := false
    
    // Handle exited state cleanup
    if newState == TradeState.EXITED and bar_index > newEntryBar
        newT1Hit := false
        newT2Hit := false
        newEarlyFiredToday := false
        newEarlyLocked := false
        newEventHandled_Early := false
        newEventHandled_Entry := false
        newEventHandled_Stop := false
        newEventHandled_Exit := false
        newState := TradeState.IDLE

    [newState, newEarlyFiredToday, newEarlyLocked, newGapPending, newEntryPrice, newStopPrice, newT1Final, newT2Final, newT3Final, newT1Hit, newT2Hit, newEntryBar, newEntryMode, newEventHandled_Early, newEventHandled_GapPend, newEventHandled_Entry, newEventHandled_T1, newEventHandled_T2, newEventHandled_Stop, newEventHandled_Exit]

// ═══════════════════════════════════════════════════════════════════════════════
// STATE MACHINE - Using unified trade processing function
// ═══════════════════════════════════════════════════════════════════════════════
// Process CALL trade - assign to temp vars first, then to var variables
[callStateNew, callEarlyFiredTodayNew, callEarlyLockedNew, callGapPendingNew, callEntryPriceNew, callStopPriceNew, callT1FinalNew, callT2FinalNew, callT3FinalNew, callT1HitNew, callT2HitNew, callEntryBarNew, callEntryModeNew, callEventHandled_EarlyNew, callEventHandled_GapPendNew, callEventHandled_EntryNew, callEventHandled_T1New, callEventHandled_T2New, callEventHandled_StopNew, callEventHandled_ExitNew] = processTrade(true, callState, callEarlyFiredToday, callEarlyLocked, callGapPending, callEntryPrice, callStopPrice, callT1Final, callT2Final, callT3Final, callT1Hit, callT2Hit, callEntryBar, callEntryMode, callEventHandled_Early, callEventHandled_GapPend, callEventHandled_Entry, callEventHandled_T1, callEventHandled_T2, callEventHandled_Stop, callEventHandled_Exit, callEntry, callTargetPrice, callStrike, callExp, callApproaching, callBreakOrGap, callPriceAtEntry, callReadyToEnter, callEntryType, callGapThrough, callExpired, callEntryScore)
callState := callStateNew
callEarlyFiredToday := callEarlyFiredTodayNew
callEarlyLocked := callEarlyLockedNew
callGapPending := callGapPendingNew
callEntryPrice := callEntryPriceNew
callStopPrice := callStopPriceNew
callT1Final := callT1FinalNew
callT2Final := callT2FinalNew
callT3Final := callT3FinalNew
callT1Hit := callT1HitNew
callT2Hit := callT2HitNew
callEntryBar := callEntryBarNew
callEntryMode := callEntryModeNew
callEventHandled_Early := callEventHandled_EarlyNew
callEventHandled_GapPend := callEventHandled_GapPendNew
callEventHandled_Entry := callEventHandled_EntryNew
callEventHandled_T1 := callEventHandled_T1New
callEventHandled_T2 := callEventHandled_T2New
callEventHandled_Stop := callEventHandled_StopNew
callEventHandled_Exit := callEventHandled_ExitNew

// Process PUT trade - assign to temp vars first, then to var variables
[putStateNew, putEarlyFiredTodayNew, putEarlyLockedNew, putGapPendingNew, putEntryPriceNew, putStopPriceNew, putT1FinalNew, putT2FinalNew, putT3FinalNew, putT1HitNew, putT2HitNew, putEntryBarNew, putEntryModeNew, putEventHandled_EarlyNew, putEventHandled_GapPendNew, putEventHandled_EntryNew, putEventHandled_T1New, putEventHandled_T2New, putEventHandled_StopNew, putEventHandled_ExitNew] = processTrade(false, putState, putEarlyFiredToday, putEarlyLocked, putGapPending, putEntryPrice, putStopPrice, putT1Final, putT2Final, putT3Final, putT1Hit, putT2Hit, putEntryBar, putEntryMode, putEventHandled_Early, putEventHandled_GapPend, putEventHandled_Entry, putEventHandled_T1, putEventHandled_T2, putEventHandled_Stop, putEventHandled_Exit, putEntry, putTargetPrice, putStrike, putExp, putApproaching, putBreakOrGap, putPriceAtEntry, putReadyToEnter, putEntryType, putGapThrough, putExpired, putEntryScore)
putState := putStateNew
putEarlyFiredToday := putEarlyFiredTodayNew
putEarlyLocked := putEarlyLockedNew
putGapPending := putGapPendingNew
putEntryPrice := putEntryPriceNew
putStopPrice := putStopPriceNew
putT1Final := putT1FinalNew
putT2Final := putT2FinalNew
putT3Final := putT3FinalNew
putT1Hit := putT1HitNew
putT2Hit := putT2HitNew
putEntryBar := putEntryBarNew
putEntryMode := putEntryModeNew
putEventHandled_Early := putEventHandled_EarlyNew
putEventHandled_GapPend := putEventHandled_GapPendNew
putEventHandled_Entry := putEventHandled_EntryNew
putEventHandled_T1 := putEventHandled_T1New
putEventHandled_T2 := putEventHandled_T2New
putEventHandled_Stop := putEventHandled_StopNew
putEventHandled_Exit := putEventHandled_ExitNew

// ═══════════════════════════════════════════════════════════════════════════════
// SYSTEM & PROTECTION EVENTS
// ═══════════════════════════════════════════════════════════════════════════════
if forceExit and not forceExit[1] and (callState == TradeState.IN_TRADE or putState == TradeState.IN_TRADE)
    if callState == TradeState.IN_TRADE
        callState := TradeState.EXITED
        callEarlyFiredToday := false
        if not callEventHandled_Exit
            handleTradeEvent(true, "[CALL FORCE EXIT]", "EXIT", color.purple, false, priceHigh)
            callEventHandled_Exit := true
    if putState == TradeState.IN_TRADE
        putState := TradeState.EXITED
        putEarlyFiredToday := false
        if not putEventHandled_Exit
            handleTradeEvent(false, "[PUT FORCE EXIT]", "EXIT", color.purple, true, priceLow)
            putEventHandled_Exit := true

if isExit15MinWarning and not isExit15MinWarning[1] and (callState == TradeState.IN_TRADE or putState == TradeState.IN_TRADE)
    if isAlertBar and showWarningAlerts
        handleTradeEvent(true, "[15 MIN WARNING] Close position soon", "15MIN", color.new(color.yellow, 30), false, priceHigh, true, true)

if isSpike and callBreakOrGap and isRTH and barstate.isconfirmed and not callSpikeAlertFired
    if isAlertBar and showProtectionAlerts
        alert("[SPIKE] CALL Entry blocked", alert.freq_once_per_bar)
    callSpikeAlertFired := true

if isSpike and putBreakOrGap and isRTH and barstate.isconfirmed and not putSpikeAlertFired
    if isAlertBar and showProtectionAlerts
        alert("[SPIKE] PUT Entry blocked", alert.freq_once_per_bar)
    putSpikeAlertFired := true

if not volumeOK and callBreakOrGap and isRTH and not isSpike and barstate.isconfirmed and not callVolumeAlertFired
    if isAlertBar and showProtectionAlerts
        alert("[LOW VOL] CALL Entry blocked", alert.freq_once_per_bar)
    callVolumeAlertFired := true

if not volumeOK and putBreakOrGap and isRTH and not isSpike and barstate.isconfirmed and not putVolumeAlertFired
    if isAlertBar and showProtectionAlerts
        alert("[LOW VOL] PUT Entry blocked", alert.freq_once_per_bar)
    putVolumeAlertFired := true

if inMiddayChop and callBreakOrGap and isRTH and not isSpike and volumeOK and barstate.isconfirmed and not callMiddayAlertFired
    if isAlertBar and showProtectionAlerts
        alert("[MIDDAY] CALL Entry blocked", alert.freq_once_per_bar)
    callMiddayAlertFired := true

if inMiddayChop and putBreakOrGap and isRTH and not isSpike and volumeOK and barstate.isconfirmed and not putMiddayAlertFired
    if isAlertBar and showProtectionAlerts
        alert("[MIDDAY] PUT Entry blocked", alert.freq_once_per_bar)
    putMiddayAlertFired := true

if isPossibleHalt and not haltAlertFired and isRTH
    if isAlertBar and showWarningAlerts
        alert("[HALT] " + str.tostring(haltGapMinutes, "#") + "min gap detected", alert.freq_once_per_bar)
    haltAlertFired := true

// ═══════════════════════════════════════════════════════════════════════════════
// LEVEL LINES
// ═══════════════════════════════════════════════════════════════════════════════
isSPY = str.upper(syminfo.ticker) == "SPY"
showCallLines = showLevelLines and isSPY and enableCall and callEntry > 0
showPutLines = showLevelLines and isSPY and enablePut and putEntry > 0
plot(showCallLines ? callEntry : na, "CALL Entry", color=color.new(color.green, 40), linewidth=2, style=plot.style_linebr)
plot(showCallLines ? callTargetPrice : na, "CALL Target", color=color.green, linewidth=2, style=plot.style_linebr)
plot(showPutLines ? putEntry : na, "PUT Entry", color=color.new(color.red, 40), linewidth=2, style=plot.style_linebr)
plot(showPutLines ? putTargetPrice : na, "PUT Target", color=color.red, linewidth=2, style=plot.style_linebr)

// ═══════════════════════════════════════════════════════════════════════════════
// DAILY RESET
// ═══════════════════════════════════════════════════════════════════════════════
if ta.change(time("D", "America/New_York")) != 0
    if callState == TradeState.IN_TRADE or putState == TradeState.IN_TRADE
        if isAlertBar
            handleTradeEvent(true, "[FORCE EXIT] EXIT NOW", "EXIT", color.purple, false, priceHigh, true, true)
    callState := TradeState.IDLE
    callEntryPrice := na
    callStopPrice := na
    callT1Final := na
    callT2Final := na
    callT3Final := na
    callT1Hit := false
    callT2Hit := false
    callEntryMode := ""
    callEntryBar := na
    callEarlyFiredToday := false
    callEarlyLocked := false
    callGapPending := false
    putState := TradeState.IDLE
    putEntryPrice := na
    putStopPrice := na
    putT1Final := na
    putT2Final := na
    putT3Final := na
    putT1Hit := false
    putT2Hit := false
    putEntryMode := ""
    putEntryBar := na
    putEarlyFiredToday := false
    putEarlyLocked := false
    putGapPending := false
    callSpikeAlertFired := false
    putSpikeAlertFired := false
    callVolumeAlertFired := false
    putVolumeAlertFired := false
    callMiddayAlertFired := false
    putMiddayAlertFired := false
    callSlippageAlertFired := false
    putSlippageAlertFired := false
    haltAlertFired := false
    callEventHandled_Early := false
    callEventHandled_GapPend := false
    callEventHandled_Entry := false
    callEventHandled_T1 := false
    callEventHandled_T2 := false
    callEventHandled_Stop := false
    callEventHandled_Exit := false
    putEventHandled_Early := false
    putEventHandled_GapPend := false
    putEventHandled_Entry := false
    putEventHandled_T1 := false
    putEventHandled_T2 := false
    putEventHandled_Stop := false
    putEventHandled_Exit := false

// Replay label
if not barstate.isrealtime and barstate.islast and showLabels and (not showLabelsOnSPYOnly or isSPY)
    label.new(bar_index, priceHigh + (priceHigh - priceLow) * 0.5, "⚠️ REPLAY", style=label.style_label_down, color=color.gray, textcolor=color.white, size=size.normal)

// Config lock label
var label configLockLabel = na
string lockText = "LOCKED " + str.format("{0,number,00}-{1,number,00} {2,number,00}:{3,number,00}", month(configLockTime), dayofmonth(configLockTime), hour(configLockTime), minute(configLockTime))
if isSPY and barstate.islast
    if na(configLockLabel)
        configLockLabel := label.new(bar_index, high, lockText, style=label.style_label_upper_right, color=color.new(color.blue, 70), textcolor=color.white, size=size.small) 
