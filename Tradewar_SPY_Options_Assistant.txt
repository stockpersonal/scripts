//@version=6
indicator('Tradewar SPY Options Assistant', overlay = true, max_labels_count = 500)

// INPUTS
groupCall = '═══ SPY CALLS ═══'
enableCall      = input.bool(true, 'Enable CALL Alerts', group = groupCall)
callStrike      = input.float(683, 'STRIKE ($)', group = groupCall, step = 1)
callExp         = input.string('JAN-21-26', 'EXP (e.g., DEC-24-25)', group = groupCall)
callTargetPrice = input.float(686.5, 'TARGET Price ($)', group = groupCall, step = 0.01)
callEntry       = input.float(683, 'ENTRY: Breaks ($)', group = groupCall, step = 0.01)

groupPut = '═══ SPY PUTS ═══'
enablePut      = input.bool(true, 'Enable PUT Alerts', group = groupPut)
putStrike      = input.float(681, 'STRIKE ($)', group = groupPut, step = 1)
putExp         = input.string('JAN-21-26', 'EXP (e.g., DEC-24-25)', group = groupPut)
putTargetPrice = input.float(677.5, 'TARGET Price ($)', group = groupPut, step = 0.01)
putEntry       = input.float(681, 'ENTRY: Loses ($)', group = groupPut, step = 0.01)

groupSettings = '═══ SETTINGS ═══'
cooldownMin = input.int(2, 'Cooldown After Open (min)', group = groupSettings, minval = 1, maxval = 10)
lotoWindowEnd = input.int(30, 'LOTO Window End (min)', group = groupSettings, minval = 3, maxval = 60)
confirmedStart = input.int(5, 'CONFIRMED Start (min)', group = groupSettings, minval = 3, maxval = 15)
earlyAlertDist = input.float(0.30, 'Early Alert Distance ($)', group = groupSettings, minval = 0.10, maxval = 1.00, step = 0.05)
allowDirectEntry = input.bool(true, 'Allow Entry Without EARLY', group = groupSettings)
useCooldownIdle = input.bool(true, 'Use Cooldown After Exit (1 bar)', group = groupSettings, tooltip = 'ON=1 bar buffer after exit, OFF=immediate re-entry allowed')
stopOffset = input.float(0.5, 'Stop Offset ($)', group = groupSettings, minval = 0.05, maxval = 1.00, step = 0.05)
useTrendFilter = input.bool(false, 'Trend Filter (EMA)', group = groupSettings, tooltip = 'OFF=price only, ON=requires EMA trend')
emaFastLen = input.int(9, 'Fast EMA', group = groupSettings, minval = 5, maxval = 20, inline = 'ema')
emaSlowLen = input.int(21, 'Slow EMA', group = groupSettings, minval = 10, maxval = 50, inline = 'ema')
useVwapConfirm = input.bool(false, 'Require VWAP Confirmation', group = groupSettings)
useLotoAlert = input.bool(true, 'Enable LOTO Alert', group = groupSettings)
useLotoWindow = input.bool(true, 'LOTO Time Window (2-60 min)', group = groupSettings)
allowLotoReentry = input.bool(false, 'Allow LOTO Re-Entry', group = groupSettings)
useBreakEvenStop = input.bool(true, 'Break-Even Stop After T1', group = groupSettings)
useTrailingStop = input.bool(true, 'Trail Stop to T1 After T2', group = groupSettings)
useTick = input.bool(false, 'Use TICK Confirmation', group = groupSettings)
tickStartMin = input.int(30, 'TICK Start (min after open)', group = groupSettings, minval = 15, maxval = 60)
minTickBull = input.int(200, 'Min TICK for CALL', group = groupSettings, minval = -500, maxval = 1000)
maxTickBear = input.int(-200, 'Max TICK for PUT', group = groupSettings, minval = -1000, maxval = 500)
useVixFilter = input.bool(false, 'Use VIX Filter', group = groupSettings)
vixSymbol = input.symbol('VIX', 'VIX Symbol', group = groupSettings)
vixConfirmedMin = input.float(15.0, 'Min VIX', group = groupSettings, minval = 5, maxval = 80, step = 0.5)
vixConfirmedMax = input.float(30.0, 'Max VIX', group = groupSettings, minval = 5, maxval = 80, step = 0.5)

groupProtection = '═══ PROTECTION ═══'
useSpikeFilter = input.bool(true, 'Block Spike Candles', group = groupProtection)
spikeMultiplier = input.float(2.0, 'Spike Threshold (x Avg)', group = groupProtection, minval = 1.5, maxval = 4.0, step = 0.5)
useVolumeConfirm = input.bool(true, 'Require Volume', group = groupProtection)
volumeMultiplier = input.float(1.2, 'Volume Threshold (x Avg)', group = groupProtection, minval = 1.0, maxval = 3.0, step = 0.1)
useMiddayFilter = input.bool(true, 'Block Midday (12-13:30)', group = groupProtection)
useHaltDetection = input.bool(true, 'Detect Halts', group = groupProtection)
haltGapThreshold = input.int(3, 'Halt Gap (min)', group = groupProtection, minval = 2, maxval = 10)
haltCooldownBars = input.int(2, 'Halt Cooldown Bars', group = groupProtection, minval = 1, maxval = 5)
useFlatBarFilter = input.bool(true, 'Block Flat Bars', group = groupProtection)
entryCutoffMin = input.int(10, 'Entry Cutoff (min before close)', group = groupProtection, minval = 5, maxval = 30)

groupAlerts = '═══ ALERTS ═══'
showWarningAlerts = input.bool(true, 'Show Warning Alerts', group = groupAlerts)
showProtectionAlerts = input.bool(false, 'Show Protection Alerts', group = groupAlerts)

groupVisual = '═══ VISUAL ═══'
showLabels = input.bool(true, 'Show Labels', group = groupVisual)
showLabelsOnSPYOnly = input.bool(true, 'Labels on SPY Only', group = groupVisual)
showLevelLines = input.bool(true, 'Show Level Lines', group = groupVisual)

// TYPES & CONSTANTS
enum TradeState
	IDLE
	EARLY
	IN_TRADE
	EXITED
	COOLDOWN_IDLE

//Side constants for array indexing
SIDE_CALL = 0
SIDE_PUT = 1

MARKET_OPEN = 9 * 60 + 30
MARKET_CLOSE = 16 * 60
EXIT_WARNING_MIN = 15
FORCE_EXIT_MIN = 5
MIDDAY_START = 12 * 60
MIDDAY_END = 13 * 60 + 30
T1_PCT = 0.33
T2_PCT = 0.66
MAX_ENTRY_SLIPPAGE = 0.20
MAX_SCORE = 6

// FUNCTIONS
//Alerts trigger instantly upon touch, ensuring you don't miss any fast tags.
isAlertBar = barstate.isrealtime

parseMonth(m) =>
    u = str.upper(str.trim(m))
    u == 'JAN' ? 1 : u == 'FEB' ? 2 : u == 'MAR' ? 3 : u == 'APR' ? 4 : u == 'MAY' ? 5 : u == 'JUN' ? 6 : u == 'JUL' ? 7 : u == 'AUG' ? 8 : u == 'SEP' ? 9 : u == 'OCT' ? 10 : u == 'NOV' ? 11 : u == 'DEC' ? 12 : 0

parseExp(s) =>
    result = float(na)
    if str.length(s) >= 9
        p = str.split(s, '-')
        if array.size(p) >= 3
            monthNum = parseMonth(array.get(p, 0))
            dayNum = str.tonumber(array.get(p, 1))
            yearNum = str.tonumber(array.get(p, 2))
            if not na(yearNum) and yearNum < 100
                yearNum := yearNum + 2000
                yearNum
            if monthNum > 0 and not na(dayNum) and not na(yearNum)
                result := timestamp(int(yearNum), monthNum, int(dayNum), 16, 0, 0)
                result
    result

// Helper: Calculate label Y-offset for targets (above/below price)
getLabelOffset(bool isCall, float hi, float lo) =>
    rangeLocal = hi - lo
    isCall ? hi + rangeLocal * 0.25 : lo - rangeLocal * 0.25

// UNIFIED EVENT HANDLER - Handles alert + label + marking in one place
handleTradeEvent(bool isCall, string alertMsg, string labelText, color labelColor, bool labelUp, float labelY, bool showAlert = true, bool showLabel = true) =>
    isSPY = str.upper(syminfo.ticker) == 'SPY'
    canShowLabels = showLabels and (not showLabelsOnSPYOnly or isSPY)
    labelStyle = labelUp ? label.style_label_up : label.style_label_down

    // Fire alert immediately
    if isAlertBar and showAlert
        alert(alertMsg, alert.freq_once_per_bar)

    // Draw label immediately
    if canShowLabels and showLabel
        label.new(bar_index, labelY, labelText, xloc = xloc.bar_index, yloc = yloc.price, color = labelColor, style = labelStyle, textcolor = color.white, size = size.small)

formatScore(int score) =>
    'Score: ' + str.tostring(score) + '/' + str.tostring(MAX_SCORE)

// PERSISTENT STATE - Array-based indexed by side (0=CALL, 1=PUT)
var array<TradeState> state = array.new<TradeState>(2, TradeState.IDLE)
var array<int> entryBar = array.new_int(2, na)
var array<int> exitBar = array.new_int(2, na)
var array<int> cooldownBar = array.new_int(2, na)

// Early alert state
var array<bool> earlyLocked = array.new_bool(2, false)
var array<bool> earlyFiredForSetup = array.new_bool(2, false)
var array<bool> gapPending = array.new_bool(2, false)

// Trade price levels
var array<float> entryPrice = array.new_float(2, na)
var array<float> stopPrice = array.new_float(2, na)
var array<float> t1Final = array.new_float(2, na)
var array<float> t2Final = array.new_float(2, na)
var array<float> t3Final = array.new_float(2, na)
var array<bool> t1Hit = array.new_bool(2, false)
var array<bool> t2Hit = array.new_bool(2, false)

// Event handled flags (prevents duplicate alerts/labels)
var array<bool> evEarly = array.new_bool(2, false)
var array<bool> evGap = array.new_bool(2, false)
var array<bool> evEntry = array.new_bool(2, false)
var array<bool> evT1 = array.new_bool(2, false)
var array<bool> evT2 = array.new_bool(2, false)
var array<bool> evStop = array.new_bool(2, false)
var array<bool> evExit = array.new_bool(2, false)

// Protection alert latches (per-side)
var array<bool> spikeAlertFired = array.new_bool(2, false)
var array<bool> volumeAlertFired = array.new_bool(2, false)
var array<bool> middayAlertFired = array.new_bool(2, false)
var array<bool> slippageAlertFired = array.new_bool(2, false)
var bool haltAlertFired = false
var int configLockTime = na
configLockTime := na(configLockTime) ? timenow : configLockTime

// SIDE-SPECIFIC ACCESS HELPERS
isCall(int side) =>
    side == SIDE_CALL
sideLabel(int side) =>
    side == SIDE_CALL ? 'CALL' : 'PUT'
getEntry(int side) =>
    side == SIDE_CALL ? callEntry : putEntry
getTarget(int side) =>
    side == SIDE_CALL ? callTargetPrice : putTargetPrice
getStrike(int side) =>
    side == SIDE_CALL ? callStrike : putStrike
getExp(int side) =>
    side == SIDE_CALL ? callExp : putExp

// MARKET DATA
[m1Close, m1High, m1Low, m1Close1, m1EmaFast, m1EmaSlow, m1Vwap, m1CandleRange, m1AvgRange, m1Volume, m1VolAvg] = request.security(syminfo.tickerid, '1', [close, high, low, close[1], ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen), ta.vwap(close), high - low, ta.sma(high - low, 20), volume, ta.sma(volume, 20)], lookahead = barmerge.lookahead_off)
[m5EmaFast, m5EmaSlow, m5Vwap, m5Close] = request.security(syminfo.tickerid, '5', [ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen), ta.vwap(close), close], lookahead = barmerge.lookahead_off)
[vixCloseRaw, vixEmaRaw] = request.security(vixSymbol, '5', [close, ta.ema(close, 20)], lookahead = barmerge.lookahead_off)
vixClose = useVixFilter ? vixCloseRaw : na
vixEma = useVixFilter ? vixEmaRaw : na
tickRaw = request.security('USI:TICK', timeframe.period, close, lookahead = barmerge.lookahead_off)
priceNow = m1Close
priceHigh = m1High
priceLow = m1Low
pricePrev = m1Close1

// DERIVED CALCULATIONS
var string SESSION_STRING = str.format('{0,number,00}{1,number,00}-{2,number,00}{3,number,00}', 9, 30, 16, 0)
minutesET = hour(time, 'America/New_York') * 60 + minute(time, 'America/New_York')
isRTH = not na(time(timeframe.period, SESSION_STRING, 'America/New_York'))
minutesSinceOpen = minutesET - MARKET_OPEN
minutesToClose = MARKET_CLOSE - minutesET

// Per-side expiration checks (required when Call & Put have different expirations)
callExpirationTs = parseExp(callExp)
putExpirationTs = parseExp(putExp)
callExpired = not na(callExpirationTs) and time >= callExpirationTs
putExpired = not na(putExpirationTs) and time >= putExpirationTs
callDte = na(callExpirationTs) ? 1 : math.max(0, math.floor((callExpirationTs - time) / 86400000))
putDte = na(putExpirationTs) ? 1 : math.max(0, math.floor((putExpirationTs - time) / 86400000))
is0DTE = callDte == 0 or putDte == 0
is1DTE = callDte == 1 or putDte == 1

inCooldown = isRTH and minutesSinceOpen >= 0 and minutesSinceOpen < cooldownMin
lotoWindowOK = minutesSinceOpen >= cooldownMin and minutesSinceOpen < lotoWindowEnd
confirmedOK = minutesSinceOpen >= confirmedStart
approachingOK = minutesSinceOpen >= cooldownMin

// VIX gating
vixTrendUp = useVixFilter and not na(vixEma) and ta.rising(vixEma, 3)
vixRising = useVixFilter and not na(vixClose) and not na(vixEma) and vixClose > vixEma
vixLowVol = useVixFilter and not na(vixClose) and vixClose < vixConfirmedMin
vixHighVol = useVixFilter and not na(vixClose) and vixClose > vixConfirmedMax
vixAllowsLoto = not useVixFilter or vixRising and vixTrendUp and not vixLowVol
vixAllowsConfirmed = not useVixFilter or not vixHighVol

// TICK confirmation
tickDataReady = useTick and minutesSinceOpen >= tickStartMin
tick = tickDataReady ? tickRaw : na
tickBullish = not useTick or not tickDataReady or na(tick) or tick >= minTickBull
tickBearish = not useTick or not tickDataReady or na(tick) or tick <= maxTickBear

// Exit timing
forceExit = (is0DTE or is1DTE) and minutesToClose <= FORCE_EXIT_MIN
isExit15MinWarning = (is0DTE or is1DTE) and minutesToClose <= EXIT_WARNING_MIN and minutesToClose > FORCE_EXIT_MIN

// Filters
isSpike = useSpikeFilter and not na(m1AvgRange) and m1CandleRange > m1AvgRange * spikeMultiplier
volumeOK = not useVolumeConfirm or bar_index > 20 and not na(m1VolAvg) and m1Volume > m1VolAvg * volumeMultiplier
inMiddayChop = useMiddayFilter and minutesET >= MIDDAY_START and minutesET < MIDDAY_END
// Note: Halt detection uses realtime-only gap calculation, so halts won't be detected in replay mode
haltGapMinutes = barstate.isrealtime and not na(time[1]) ? (time - time[1]) / 60000 : 0
isPossibleHalt = useHaltDetection and haltGapMinutes >= haltGapThreshold and isRTH and isRTH[1] and bar_index > 10
barsSinceHalt = ta.barssince(isPossibleHalt)
inHaltCooldown = useHaltDetection and not na(barsSinceHalt) and barsSinceHalt <= haltCooldownBars
isFlatBar = useFlatBarFilter and priceHigh == priceLow
canEnterTime = minutesToClose > entryCutoffMin
cooldownJustEnded = minutesSinceOpen == cooldownMin and minutesSinceOpen[1] < cooldownMin

callCommonEntryFilters = isRTH and not callExpired and not isSpike and volumeOK and not inMiddayChop and not forceExit and not isPossibleHalt and not inHaltCooldown and not isFlatBar and canEnterTime
putCommonEntryFilters = isRTH and not putExpired and not isSpike and volumeOK and not inMiddayChop and not forceExit and not isPossibleHalt and not inHaltCooldown and not isFlatBar and canEnterTime
callBaseEntryFilters = callCommonEntryFilters // and not cooldownJustEnded
putBaseEntryFilters = putCommonEntryFilters // and not cooldownJustEnded

// TREND DETECTION
emaBullish5m = m5EmaFast > m5EmaSlow
emaBearish5m = m5EmaFast < m5EmaSlow
vwapBullish5m = m5Close > m5Vwap
vwapBearish5m = m5Close < m5Vwap
confirmedUptrend = emaBullish5m and (not useVwapConfirm or m5Close >= m5Vwap - 0.05)
confirmedDowntrend = emaBearish5m and (not useVwapConfirm or m5Close <= m5Vwap + 0.05)

emaBullish1m = m1EmaFast > m1EmaSlow
emaBearish1m = m1EmaFast < m1EmaSlow
vwapBullish1m = m1Close > m1Vwap
vwapBearish1m = m1Close < m1Vwap
lotoUptrend = emaBullish1m and (not useVwapConfirm or vwapBullish1m)
lotoDowntrend = emaBearish1m and (not useVwapConfirm or vwapBearish1m)
pureDowntrend5m = emaBearish5m and vwapBearish5m
pureUptrend5m = emaBullish5m and vwapBullish5m

// Current state shortcuts for condition calculations
callState = array.get(state, SIDE_CALL)
putState = array.get(state, SIDE_PUT)
callGapPend = array.get(gapPending, SIDE_CALL)
putGapPend = array.get(gapPending, SIDE_PUT)
callEarlyFired = array.get(earlyFiredForSetup, SIDE_CALL)
putEarlyFired = array.get(earlyFiredForSetup, SIDE_PUT)

// Entry permissions
callConfirmedAllowed = not useTrendFilter or confirmedUptrend
putConfirmedAllowed = not useTrendFilter or confirmedDowntrend
callLotoAllowed = useLotoAlert and lotoUptrend and not pureDowntrend5m and (allowLotoReentry or callState != TradeState.IN_TRADE) and vixAllowsLoto
putLotoAllowed = useLotoAlert and lotoDowntrend and not pureUptrend5m and (allowLotoReentry or putState != TradeState.IN_TRADE) and vixAllowsLoto
callConfirmedAllowed := callConfirmedAllowed and vixAllowsConfirmed and tickBullish
putConfirmedAllowed := putConfirmedAllowed and vixAllowsConfirmed and tickBearish

lateLoto = minutesSinceOpen > 25
callLotoAllowed := callLotoAllowed and (not lateLoto or pureUptrend5m)
putLotoAllowed := putLotoAllowed and (not lateLoto or pureDowntrend5m)

// HELPER CONDITIONS
hasCall = enableCall and callEntry > 0 and callTargetPrice > callEntry
hasPut = enablePut and putEntry > 0 and putTargetPrice < putEntry
callApproaching = hasCall and priceLow < callEntry and priceHigh >= callEntry - earlyAlertDist and approachingOK
putApproaching = hasPut and priceHigh > putEntry and priceLow <= putEntry + earlyAlertDist and approachingOK
callBreak = hasCall and priceNow >= callEntry and pricePrev < callEntry
putBreak = hasPut and priceNow <= putEntry and pricePrev > putEntry
isFirstBarOfDay = isRTH and not isRTH[1]
callGapThrough = isFirstBarOfDay and hasCall and priceNow >= callEntry
putGapThrough = isFirstBarOfDay and hasPut and priceNow <= putEntry
// GAP release requires FULL filters (not just base) — prevents phantom entries when conditions invalidate
callGapRelease = callGapPend and priceNow >= callEntry and callCommonEntryFilters and (callConfirmedAllowed or callLotoAllowed)
putGapRelease = putGapPend and priceNow <= putEntry and putCommonEntryFilters and (putConfirmedAllowed or putLotoAllowed)
callBreakOrGap = callBreak or callGapThrough or callGapRelease
putBreakOrGap = putBreak or putGapThrough or putGapRelease

// Allow entry if price is at entry level (handles case where opposite trade exits and price was at entry)
callPriceAtEntry = hasCall and math.abs(priceNow - callEntry) <= 0.10 and (callState == TradeState.IDLE or callState == TradeState.EARLY)
putPriceAtEntry = hasPut and math.abs(priceNow - putEntry) <= 0.10 and (putState == TradeState.IDLE or putState == TradeState.EARLY)

callCanEnter = (callBreakOrGap or callPriceAtEntry) and callBaseEntryFilters and priceNow <= callEntry + MAX_ENTRY_SLIPPAGE
callLotoReady = callCanEnter and (not useLotoWindow or lotoWindowOK) and callLotoAllowed
callConfirmedReady = callCanEnter and confirmedOK and callConfirmedAllowed and not callLotoReady
callPriceAtEntryMinimalFilters = isRTH and not callExpired and not forceExit
callPriceAtEntryBasicAllowed = not useTrendFilter or confirmedUptrend
callPriceAtEntryReady = callPriceAtEntry and callPriceAtEntryMinimalFilters and callPriceAtEntryBasicAllowed and not callLotoReady
callReadyToEnter = (callState == TradeState.IDLE or callState == TradeState.EARLY) and (callLotoReady or callConfirmedReady or callPriceAtEntryReady) and (callEarlyFired or allowDirectEntry)
callEntryType = callLotoReady ? 'LOTO' : callConfirmedReady or callPriceAtEntryReady ? 'CONFIRMED' : ''

putCanEnter = (putBreakOrGap or putPriceAtEntry) and putBaseEntryFilters and priceNow >= putEntry - MAX_ENTRY_SLIPPAGE
putLotoReady = putCanEnter and (not useLotoWindow or lotoWindowOK) and putLotoAllowed
putConfirmedReady = putCanEnter and confirmedOK and putConfirmedAllowed and not putLotoReady
putPriceAtEntryMinimalFilters = isRTH and not putExpired and not forceExit
putPriceAtEntryBasicAllowed = not useTrendFilter or confirmedDowntrend
putPriceAtEntryReady = putPriceAtEntry and putPriceAtEntryMinimalFilters and putPriceAtEntryBasicAllowed and not putLotoReady
putReadyToEnter = (putState == TradeState.IDLE or putState == TradeState.EARLY) and (putLotoReady or putConfirmedReady or putPriceAtEntryReady) and (putEarlyFired or allowDirectEntry)
putEntryType = putLotoReady ? 'LOTO' : putConfirmedReady or putPriceAtEntryReady ? 'CONFIRMED' : ''

callSlippageBlocked = callBreakOrGap and callCommonEntryFilters and priceNow > callEntry + MAX_ENTRY_SLIPPAGE and (callState == TradeState.IDLE or callState == TradeState.EARLY) and (not useTrendFilter or confirmedUptrend) and (callLotoAllowed or callConfirmedAllowed)
putSlippageBlocked = putBreakOrGap and putCommonEntryFilters and priceNow < putEntry - MAX_ENTRY_SLIPPAGE and (putState == TradeState.IDLE or putState == TradeState.EARLY) and (not useTrendFilter or confirmedDowntrend) and (putLotoAllowed or putConfirmedAllowed)

// Slippage alerts — no barstate.isconfirmed dependency (alert-only, no state transition)
if callSlippageBlocked and not array.get(slippageAlertFired, SIDE_CALL)
    handleTradeEvent(true, '[SLIPPAGE] CALL $' + str.tostring(callStrike, '#') + 'C blocked', 'SLIPPAGE', color.new(color.red, 70), false, priceHigh, showProtectionAlerts, true)
    array.set(slippageAlertFired, SIDE_CALL, true)
if putSlippageBlocked and not array.get(slippageAlertFired, SIDE_PUT)
    handleTradeEvent(false, '[SLIPPAGE] PUT $' + str.tostring(putStrike, '#') + 'P blocked', 'SLIPPAGE', color.new(color.red, 70), true, priceLow, showProtectionAlerts, true)
    array.set(slippageAlertFired, SIDE_PUT, true)

// ENTRY SCORE (0–6)
scoreTrendCall = confirmedUptrend ? 1 : 0
scoreTrendPut = confirmedDowntrend ? 1 : 0
scoreVwapCall = not useVwapConfirm or vwapBullish5m ? 1 : 0
scoreVwapPut = not useVwapConfirm or vwapBearish5m ? 1 : 0
scoreVolume = volumeOK ? 1 : 0
scoreNoSpike = not isSpike ? 1 : 0
scoreNoMidday = not inMiddayChop ? 1 : 0
scoreTickCall = not useTick or tickBullish ? 1 : 0
scoreTickPut = not useTick or tickBearish ? 1 : 0

callEntryScore = scoreTrendCall + scoreVwapCall + scoreVolume + scoreNoSpike + scoreNoMidday + scoreTickCall
putEntryScore = scoreTrendPut + scoreVwapPut + scoreVolume + scoreNoSpike + scoreNoMidday + scoreTickPut

// FSM TRADE PROCESSOR — Array-based, no tuple returns, side + conditions only
processTrade(int side, bool approaching, bool breakOrGap, bool priceAtEntry, bool readyToEnter, string entryType, bool gapThrough, bool expired, int entryScore) =>
    // Read current state from arrays
    TradeState s = array.get(state, side)
    bool ic = isCall(side)
    string label = sideLabel(side)
    float entry = getEntry(side)
    float target = getTarget(side)
    float strike = getStrike(side)
    string exp = getExp(side)

    // Read trade state
    bool _earlyFired = array.get(earlyFiredForSetup, side)
    bool _earlyLocked = array.get(earlyLocked, side)
    bool _gapPending = array.get(gapPending, side)
    float _entryPrice = array.get(entryPrice, side)
    float _stopPrice = array.get(stopPrice, side)
    float _t1Final = array.get(t1Final, side)
    float _t2Final = array.get(t2Final, side)
    float _t3Final = array.get(t3Final, side)
    bool _t1Hit = array.get(t1Hit, side)
    bool _t2Hit = array.get(t2Hit, side)
    int _entryBar = array.get(entryBar, side)
    int _exitBar = array.get(exitBar, side)
    int _cooldownBar = array.get(cooldownBar, side)

    // Read event flags
    bool _evEarly = array.get(evEarly, side)
    bool _evGap = array.get(evGap, side)
    bool _evEntry = array.get(evEntry, side)
    bool _evT1 = array.get(evT1, side)
    bool _evT2 = array.get(evT2, side)
    bool _evStop = array.get(evStop, side)
    bool _evExit = array.get(evExit, side)

    scoreText = formatScore(entryScore)

    // Handle gap pending
    if gapThrough and inCooldown and not _gapPending
        _gapPending := true
        if not _evGap
            handleTradeEvent(ic, '[GAP PENDING] ' + label + ' $' + str.tostring(strike, '#') + (ic ? 'C' : 'P') + ' | Entry queued', 'GAP', color.new(color.orange, 50), not ic, ic ? priceHigh : priceLow, showWarningAlerts, true)
            _evGap := true

    // Reset gap pending if conditions no longer allow entry
    if _gapPending and (not canEnterTime or inMiddayChop or expired)
        _gapPending := false
        _evGap := false

    // Handle early alert
    earlyFilters = isRTH and not expired and not inCooldown and not isSpike and volumeOK and not inMiddayChop and not isPossibleHalt and not inHaltCooldown and canEnterTime
    if s == TradeState.IDLE and approaching and earlyFilters and not _earlyFired and not _earlyLocked
        s := TradeState.EARLY
        _earlyFired := true
        _earlyLocked := true
        if not _evEarly
            handleTradeEvent(ic, '[EARLY] ' + label + ' $' + str.tostring(strike, '#') + (ic ? 'C' : 'P') + ' ' + exp + ' | $' + str.tostring(priceNow, '#.##') + ' → $' + str.tostring(entry, '#.##'), 'EARLY', color.new(color.yellow, 20), not ic, ic ? priceHigh : priceLow)
            _evEarly := true

    // Handle entry - FSM enforces state check (never trust callers)
    if (s == TradeState.IDLE or s == TradeState.EARLY) and readyToEnter and not _evEntry
        _entryPrice := entry
        _stopPrice := ic ? entry - stopOffset : entry + stopOffset
        targetDist = ic ? target - entry : entry - target
        _t1Final := _entryPrice + targetDist * T1_PCT * (ic ? 1 : -1)
        _t2Final := _entryPrice + targetDist * T2_PCT * (ic ? 1 : -1)
        _t3Final := _entryPrice + targetDist * (ic ? 1 : -1)
        _entryBar := bar_index
        _gapPending := false
        _evGap := false
        s := TradeState.IN_TRADE
        _t1Hit := false
        _t2Hit := false
        // Reset event flags for new trade
        _evEarly := false
        _evT1 := false
        _evT2 := false
        _evStop := false
        _evExit := false

        // Fire entry event immediately
        labelText = (entryType == 'LOTO' ? 'LOTO' : entryType == 'CONFIRMED' ? 'CONFIRMED' : label) + '\n' + scoreText
        handleTradeEvent(ic, '[' + label + '][' + entryType + '][SCORE ' + str.tostring(entryScore) + '/' + str.tostring(MAX_SCORE) + '] $' + str.tostring(strike) + ' ' + exp + ' E$' + str.tostring(_entryPrice), labelText, entryType == 'LOTO' ? color.orange : ic ? color.green : color.new(color.red, 20), ic, ic ? priceLow : priceHigh)
        _evEntry := true

    // CRITICAL: Entry bar protection — NO exits allowed on entry bar
    if s == TradeState.IN_TRADE and bar_index > _entryBar
        // Check stop loss (before targets)
        if not _evExit and not na(_stopPrice)
            stopHit = ic ? priceLow <= _stopPrice : priceHigh >= _stopPrice
            if stopHit
                s := TradeState.EXITED
                _exitBar := bar_index
                _earlyFired := false
                _earlyLocked := false
                _evEarly := false
                if not _evExit
                    handleTradeEvent(ic, '[' + label + ' STOP HIT]', 'STOP', color.red, ic, ic ? priceLow : priceHigh)
                    _evStop := true
                    _evExit := true
        // Only check targets if still in trade
        if s == TradeState.IN_TRADE
            // Check T1
            if not _t1Hit and not na(_t1Final)
                t1HitNow = ic ? priceHigh >= _t1Final : priceLow <= _t1Final
                if t1HitNow
                    _t1Hit := true
                    if useBreakEvenStop
                        _stopPrice := _entryPrice
                    if not _evT1
                        t1Msg = useBreakEvenStop ? ' Stop→BE' : ''
                        handleTradeEvent(ic, '[' + label + ' T1] $' + str.tostring(_t1Final, '#.##') + t1Msg, 'T1', color.new(color.blue, 20), not ic, getLabelOffset(ic, priceHigh, priceLow))
                        _evT1 := true

            // Check T2
            if _t1Hit and not _t2Hit and not na(_t2Final)
                t2HitNow = ic ? priceHigh >= _t2Final : priceLow <= _t2Final
                if t2HitNow
                    _t2Hit := true
                    if useTrailingStop
                        _stopPrice := _t1Final
                    if not _evT2
                        t2Msg = useTrailingStop ? ' Stop→T1' : ''
                        handleTradeEvent(ic, '[' + label + ' T2] $' + str.tostring(_t2Final, '#.##') + t2Msg, 'T2', color.blue, not ic, getLabelOffset(ic, priceHigh, priceLow))
                        _evT2 := true

            // Check T3 (target hit)
            if _t2Hit and not na(_t3Final)
                t3Hit = ic ? priceHigh >= _t3Final : priceLow <= _t3Final
                if t3Hit
                    s := TradeState.EXITED
                    _exitBar := bar_index
                    _earlyFired := false
                    _earlyLocked := false
                    _evEarly := false
                    if not _evExit
                        handleTradeEvent(ic, '[' + label + ' TARGET HIT]', 'TARGET', color.green, not ic, getLabelOffset(ic, priceHigh, priceLow))
                        _evExit := true

    // Handle early state reset - allow EARLY to re-fire if price disengages and re-approaches
    if s == TradeState.EARLY
        earlyDisengaged = ic ? low > entry + earlyAlertDist : high < entry - earlyAlertDist
        if earlyDisengaged
            s := TradeState.IDLE
            _earlyFired := false
            _evEarly := false
            _earlyLocked := false

    // Handle exited state cleanup - EXITED must persist for 1 full bar
    if s == TradeState.EXITED and bar_index > _exitBar
        _t1Hit := false
        _t2Hit := false
        _earlyFired := false
        _earlyLocked := false
        _gapPending := false
        _evEarly := false
        _evEntry := false
        _evStop := false
        _evExit := false
        if useCooldownIdle
            s := TradeState.COOLDOWN_IDLE
            _cooldownBar := bar_index
        else
            s := TradeState.IDLE

    // Advance COOLDOWN_IDLE → IDLE after 1 full bar (deterministic, no barstate.isconfirmed)
    if s == TradeState.COOLDOWN_IDLE and bar_index > _cooldownBar
        s := TradeState.IDLE

    // Write all state back to arrays
    array.set(state, side, s)
    array.set(earlyFiredForSetup, side, _earlyFired)
    array.set(earlyLocked, side, _earlyLocked)
    array.set(gapPending, side, _gapPending)
    array.set(entryPrice, side, _entryPrice)
    array.set(stopPrice, side, _stopPrice)
    array.set(t1Final, side, _t1Final)
    array.set(t2Final, side, _t2Final)
    array.set(t3Final, side, _t3Final)
    array.set(t1Hit, side, _t1Hit)
    array.set(t2Hit, side, _t2Hit)
    array.set(entryBar, side, _entryBar)
    array.set(exitBar, side, _exitBar)
    array.set(cooldownBar, side, _cooldownBar)
    array.set(evEarly, side, _evEarly)
    array.set(evGap, side, _evGap)
    array.set(evEntry, side, _evEntry)
    array.set(evT1, side, _evT1)
    array.set(evT2, side, _evT2)
    array.set(evStop, side, _evStop)
    array.set(evExit, side, _evExit)

// STATE MACHINE — Clean invocation
processTrade(SIDE_CALL, callApproaching, callBreakOrGap, callPriceAtEntry, callReadyToEnter, callEntryType, callGapThrough, callExpired, callEntryScore)
processTrade(SIDE_PUT, putApproaching, putBreakOrGap, putPriceAtEntry, putReadyToEnter, putEntryType, putGapThrough, putExpired, putEntryScore)

// SYSTEM & PROTECTION EVENTS
callInTrade = array.get(state, SIDE_CALL) == TradeState.IN_TRADE
putInTrade = array.get(state, SIDE_PUT) == TradeState.IN_TRADE

if forceExit and not forceExit[1] and (callInTrade or putInTrade)
    for side = 0 to 1 by 1
        array.set(evEarly, side, false)
        array.set(earlyLocked, side, false)

        if array.get(state, side) == TradeState.IN_TRADE
            array.set(state, side, TradeState.EXITED)
            array.set(exitBar, side, bar_index)
            array.set(earlyFiredForSetup, side, false)
            array.set(evEntry, side, false)
            array.set(evStop, side, false)
            if not array.get(evExit, side)
                ic = isCall(side)
                handleTradeEvent(ic, '[' + sideLabel(side) + ' FORCE EXIT]', 'EXIT', color.purple, not ic, ic ? priceHigh : priceLow)
                array.set(evExit, side, true)

if isExit15MinWarning and not isExit15MinWarning[1] and (callInTrade or putInTrade)
    if isAlertBar and showWarningAlerts
        handleTradeEvent(true, '[15 MIN WARNING] Close position soon', '15MIN', color.new(color.yellow, 30), false, priceHigh, true, true)

// PROTECTION ALERTS — Alert-only, no state transitions
fireProtectionAlert(int side, bool condition, array<bool> alertArray, string alertType) =>
    breakOrGap = side == SIDE_CALL ? callBreakOrGap : putBreakOrGap
    if condition and breakOrGap and isRTH and not array.get(alertArray, side)
        if isAlertBar and showProtectionAlerts
            alert('[' + alertType + '] ' + sideLabel(side) + ' Entry blocked', alert.freq_once_per_bar)
        array.set(alertArray, side, true)

for side = 0 to 1 by 1
    fireProtectionAlert(side, isSpike, spikeAlertFired, 'SPIKE')
    fireProtectionAlert(side, not volumeOK and not isSpike, volumeAlertFired, 'LOW VOL')
    fireProtectionAlert(side, inMiddayChop and not isSpike and volumeOK, middayAlertFired, 'MIDDAY')

if isPossibleHalt and not haltAlertFired and isRTH
    if isAlertBar and showWarningAlerts
        alert('[HALT] ' + str.tostring(haltGapMinutes, '#') + 'min gap detected', alert.freq_once_per_bar)
    haltAlertFired := true

// LEVEL LINES
isSPY = str.upper(syminfo.ticker) == 'SPY'
showCallLines = showLevelLines and isSPY and enableCall and callEntry > 0
showPutLines = showLevelLines and isSPY and enablePut and putEntry > 0
plot(showCallLines ? callEntry : na, 'CALL Entry', color = color.new(color.green, 40), linewidth = 2, style = plot.style_linebr)
plot(showCallLines ? callTargetPrice : na, 'CALL Target', color = color.green, linewidth = 2, style = plot.style_linebr)
plot(showPutLines ? putEntry : na, 'PUT Entry', color = color.new(color.red, 40), linewidth = 2, style = plot.style_linebr)
plot(showPutLines ? putTargetPrice : na, 'PUT Target', color = color.red, linewidth = 2, style = plot.style_linebr)

// DAILY RESET
if ta.change(time('D', 'America/New_York')) != 0
    // Clear exit flags FIRST to prevent duplicate alerts in replay
    for side = 0 to 1 by 1
        array.set(evExit, side, false)
        array.set(evStop, side, false)

    if array.get(state, SIDE_CALL) == TradeState.IN_TRADE or array.get(state, SIDE_PUT) == TradeState.IN_TRADE
        if isAlertBar
            handleTradeEvent(true, '[FORCE EXIT] EXIT NOW', 'EXIT', color.purple, false, priceHigh, true, true)

    // Reset state for both sides using loop
    for side = 0 to 1 by 1
        array.set(state, side, TradeState.IDLE)
        array.set(entryPrice, side, na)
        array.set(stopPrice, side, na)
        array.set(t1Final, side, na)
        array.set(t2Final, side, na)
        array.set(t3Final, side, na)
        array.set(t1Hit, side, false)
        array.set(t2Hit, side, false)
        array.set(entryBar, side, na)
        array.set(exitBar, side, na)
        array.set(cooldownBar, side, na)
        array.set(earlyFiredForSetup, side, false)
        array.set(earlyLocked, side, false)
        array.set(gapPending, side, false)
        array.set(spikeAlertFired, side, false)
        array.set(volumeAlertFired, side, false)
        array.set(middayAlertFired, side, false)
        array.set(slippageAlertFired, side, false)
        array.set(evEarly, side, false)
        array.set(evGap, side, false)
        array.set(evEntry, side, false)
        array.set(evT1, side, false)
        array.set(evT2, side, false)
        array.set(evStop, side, false)
        array.set(evExit, side, false)
    haltAlertFired := false

// Replay label
if not barstate.isrealtime and barstate.islast and showLabels and (not showLabelsOnSPYOnly or isSPY)
    label.new(bar_index, priceHigh + (priceHigh - priceLow) * 0.5, '⚠️ REPLAY', style = label.style_label_down, color = color.gray, textcolor = color.white, size = size.normal)

// Script load timestamp label
var label scriptLoadLabel = na
string loadText = 'LOAD ' + str.format('{0,number,00}-{1,number,00} {2,number,00}:{3,number,00}', month(configLockTime), dayofmonth(configLockTime), hour(configLockTime), minute(configLockTime))
if isSPY and barstate.islast
    if na(scriptLoadLabel)
        scriptLoadLabel := label.new(bar_index, high, loadText, style = label.style_label_upper_right, color = color.new(color.blue, 70), textcolor = color.white, size = size.small)
