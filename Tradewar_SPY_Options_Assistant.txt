//@version=5
indicator("Tradewar SPY Options Assistant", overlay=true, max_labels_count=500)

// ═══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ═══════════════════════════════════════════════════════════════════════════════
groupCall = "═══ SPY CALLS ═══"
enableCall      = input.bool(true, "Enable CALL Alerts", group=groupCall)
callStrike      = input.float(689, "STRIKE ($)", group=groupCall, step=1)
callExp         = input.string("JAN-09-26", "EXP (e.g., DEC-24-25)", group=groupCall)
callTargetPrice = input.float(691, "TARGET Price ($)", group=groupCall, step=0.01)
callEntry       = input.float(689.39, "ENTRY: Breaks ($)", group=groupCall, step=0.01)

groupPut = "═══ SPY PUTS ═══"
enablePut      = input.bool(true, "Enable PUT Alerts", group=groupPut)
putStrike      = input.float(688, "STRIKE ($)", group=groupPut, step=1)
putExp         = input.string("JAN-09-26", "EXP (e.g., DEC-24-25)", group=groupPut)
putTargetPrice = input.float(686, "TARGET Price ($)", group=groupPut, step=0.01)
putEntry       = input.float(688, "ENTRY: Loses ($)", group=groupPut, step=0.01)

groupSettings = "═══ SETTINGS ═══"
cooldownMin      = input.int(2, "Cooldown After Open (min)", group=groupSettings, minval=1, maxval=10)
lotoWindowEnd    = input.int(30, "LOTO Window End (min)", group=groupSettings, minval=3, maxval=40)
confirmedStart   = input.int(5, "CONFIRMED Start (min)", group=groupSettings, minval=3, maxval=15)
earlyAlertDist   = input.float(0.30, "Early Alert Distance ($)", group=groupSettings, minval=0.10, maxval=1.00, step=0.05)
stopOffset       = input.float(0.5, "Stop Offset ($)", group=groupSettings, minval=0.05, maxval=1.00, step=0.05)
useTrendFilter   = input.bool(false, "Trend Filter (EMA)", group=groupSettings, tooltip="OFF=price only, ON=requires EMA trend")
emaFastLen       = input.int(9, "Fast EMA", group=groupSettings, minval=5, maxval=20, inline="ema")
emaSlowLen       = input.int(21, "Slow EMA", group=groupSettings, minval=10, maxval=50, inline="ema")
useVwapConfirm   = input.bool(false, "Require VWAP Confirmation", group=groupSettings)
useLotoAlert     = input.bool(true, "Enable LOTO Alert", group=groupSettings)
useLotoWindow    = input.bool(true, "LOTO Time Window (2-30 min)", group=groupSettings)
allowLotoReentry = input.bool(false, "Allow LOTO Re-Entry", group=groupSettings)
useBreakEvenStop = input.bool(true, "Break-Even Stop After T1", group=groupSettings)
useTrailingStop  = input.bool(true, "Trail Stop to T1 After T2", group=groupSettings)
useTick          = input.bool(false, "Use TICK Confirmation", group=groupSettings)
tickStartMin     = input.int(30, "TICK Start (min after open)", group=groupSettings, minval=15, maxval=60)
minTickBull      = input.int(200, "Min TICK for CALL", group=groupSettings, minval=-500, maxval=1000)
maxTickBear      = input.int(-200, "Max TICK for PUT", group=groupSettings, minval=-1000, maxval=500)
useVixFilter     = input.bool(false, "Use VIX Filter", group=groupSettings)
vixSymbol        = input.symbol("VIX", "VIX Symbol", group=groupSettings)
vixConfirmedMin  = input.float(15.0, "Min VIX", group=groupSettings, minval=5, maxval=80, step=0.5)
vixConfirmedMax  = input.float(30.0, "Max VIX", group=groupSettings, minval=5, maxval=80, step=0.5)

groupProtection = "═══ PROTECTION ═══"
useSpikeFilter   = input.bool(true, "Block Spike Candles", group=groupProtection)
spikeMultiplier  = input.float(2.0, "Spike Threshold (x Avg)", group=groupProtection, minval=1.5, maxval=4.0, step=0.5)
useVolumeConfirm = input.bool(true, "Require Volume", group=groupProtection)
volumeMultiplier = input.float(1.2, "Volume Threshold (x Avg)", group=groupProtection, minval=1.0, maxval=3.0, step=0.1)
useMiddayFilter  = input.bool(true, "Block Midday (12-13:30)", group=groupProtection)
useHaltDetection = input.bool(true, "Detect Halts", group=groupProtection)
haltGapThreshold = input.int(3, "Halt Gap (min)", group=groupProtection, minval=2, maxval=10)
haltCooldownBars = input.int(2, "Halt Cooldown Bars", group=groupProtection, minval=1, maxval=5)
useFlatBarFilter = input.bool(true, "Block Flat Bars", group=groupProtection)
entryCutoffMin   = input.int(10, "Entry Cutoff (min before close)", group=groupProtection, minval=5, maxval=30)

groupAlerts = "═══ ALERTS ═══"
showWarningAlerts    = input.bool(true, "Show Warning Alerts", group=groupAlerts)
showProtectionAlerts = input.bool(false, "Show Protection Alerts", group=groupAlerts)

groupVisual = "═══ VISUAL ═══"
showLabels          = input.bool(true, "Show Labels", group=groupVisual)
showLabelsOnSPYOnly = input.bool(true, "Labels on SPY Only", group=groupVisual)
showLevelLines      = input.bool(true, "Show Level Lines", group=groupVisual)

// ═══════════════════════════════════════════════════════════════════════════════
// TYPES & CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════════
enum TradeState
    IDLE
    EARLY
    IN_TRADE
    EXITED

MARKET_OPEN = 9 * 60 + 30
MARKET_CLOSE = 16 * 60
EXIT_WARNING_MIN = 15
FORCE_EXIT_MIN = 5
MIDDAY_START = 12 * 60
MIDDAY_END = 13 * 60 + 30
T1_PCT = 0.33
T2_PCT = 0.66
MAX_ENTRY_SLIPPAGE = 0.20

// ═══════════════════════════════════════════════════════════════════════════════
// FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════
parseMonth(m) =>
    u = str.upper(str.trim(m))
    u == "JAN" ? 1 : u == "FEB" ? 2 : u == "MAR" ? 3 : u == "APR" ? 4 : u == "MAY" ? 5 : u == "JUN" ? 6 : u == "JUL" ? 7 : u == "AUG" ? 8 : u == "SEP" ? 9 : u == "OCT" ? 10 : u == "NOV" ? 11 : u == "DEC" ? 12 : 0

parseExp(s) =>
    result = float(na)
    if str.length(s) >= 9
        p = str.split(s, "-")
        if array.size(p) >= 3
            monthNum = parseMonth(array.get(p, 0))
            dayNum = str.tonumber(array.get(p, 1))
            yearNum = str.tonumber(array.get(p, 2))
            if not na(yearNum) and yearNum < 100
                yearNum := yearNum + 2000
            if monthNum > 0 and not na(dayNum) and not na(yearNum)
                result := timestamp(int(yearNum), monthNum, int(dayNum), 16, 0, 0)
    result

// ═══════════════════════════════════════════════════════════════════════════════
// PERSISTENT STATE
// ═══════════════════════════════════════════════════════════════════════════════
var TradeState callState = TradeState.IDLE
var TradeState putState = TradeState.IDLE
var string callEntryMode = ""
var string putEntryMode = ""
var int callEntryBar = na
var int putEntryBar = na
var bool callEarlyFiredToday = false
var bool putEarlyFiredToday = false
var bool callGapPending = false
var bool putGapPending = false
var string directionLockedToday = ""
var bool callHadTrade = false
var bool putHadTrade = false
var bool spikeAlertFired = false
var bool volumeAlertFired = false
var bool middayAlertFired = false
var bool slippageAlertFired = false
var bool haltAlertFired = false
var int lastCallAlertBar = na
var int lastPutAlertBar = na
var bool callStateChangedThisBar = false
var bool putStateChangedThisBar = false
var float callEntryPrice = na
var float putEntryPrice = na
var float callStopPrice = na
var float putStopPrice = na
var float callT1Final = na
var float callT2Final = na
var float callT3Final = na
var float putT1Final = na
var float putT2Final = na
var float putT3Final = na
var bool callT1Hit = false
var bool callT2Hit = false
var bool putT1Hit = false
var bool putT2Hit = false

// ═══════════════════════════════════════════════════════════════════════════════
// BAR-SCOPED EVENT FLAGS
// ═══════════════════════════════════════════════════════════════════════════════
bool evt_callEarly = false
bool evt_callGapPend = false
bool evt_callEntry = false
bool evt_callT1 = false
bool evt_callT2 = false
bool evt_callT3 = false
bool evt_callStop = false
bool evt_putEarly = false
bool evt_putGapPend = false
bool evt_putEntry = false
bool evt_putT1 = false
bool evt_putT2 = false
bool evt_putT3 = false
bool evt_putStop = false
bool evt_forceExit = false
bool evt_15MinWarning = false
bool evt_spikeBlocked = false
bool evt_volumeBlocked = false
bool evt_middayBlocked = false
bool evt_callSlippage = false
bool evt_putSlippage = false
bool evt_haltDetected = false

isLiveBar = barstate.isrealtime
var bool callAlertFiredThisBar = false
var bool putAlertFiredThisBar = false
if barstate.isnew
    callAlertFiredThisBar := false
    putAlertFiredThisBar := false
    callStateChangedThisBar := false
    putStateChangedThisBar := false

var int configLockTime = na
configLockTime := na(configLockTime) ? timenow : configLockTime

// ═══════════════════════════════════════════════════════════════════════════════
// MARKET DATA
// ═══════════════════════════════════════════════════════════════════════════════
[m1Close, m1High, m1Low, m1Close1, m1EmaFast, m1EmaSlow, m1Vwap, m1CandleRange, m1AvgRange, m1Volume, m1VolAvg] = request.security(syminfo.tickerid, "1", [close, high, low, close[1], ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen), ta.vwap, high - low, ta.sma(high - low, 20), volume, ta.sma(volume, 20)], lookahead=barmerge.lookahead_off)
[m5EmaFast, m5EmaSlow, m5Vwap, m5Close] = request.security(syminfo.tickerid, "5", [ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen), ta.vwap, close], lookahead=barmerge.lookahead_off)
[vixCloseRaw, vixEmaRaw] = request.security(vixSymbol, "5", [close, ta.ema(close, 20)], lookahead=barmerge.lookahead_off)
vixClose = useVixFilter ? vixCloseRaw : na
vixEma = useVixFilter ? vixEmaRaw : na
tickRaw = request.security("USI:TICK", timeframe.period, close, lookahead=barmerge.lookahead_off)
priceNow = m1Close
priceHigh = m1High
priceLow = m1Low
pricePrev = m1Close1

// ═══════════════════════════════════════════════════════════════════════════════
// DERIVED CALCULATIONS
// ═══════════════════════════════════════════════════════════════════════════════
var string SESSION_STRING = str.format("{0,number,00}{1,number,00}-{2,number,00}{3,number,00}", 9, 30, 16, 0)
minutesET = hour(time, "America/New_York") * 60 + minute(time, "America/New_York")
isRTH = not na(time(timeframe.period, SESSION_STRING, "America/New_York"))
minutesSinceOpen = minutesET - MARKET_OPEN
minutesToClose = MARKET_CLOSE - minutesET

var string expirationStr = str.length(callExp) > 0 ? callExp : putExp
var float expirationTs = parseExp(expirationStr)
dte = na(expirationTs) ? 1 : math.max(0, math.floor((expirationTs - time) / 86400000))
isExpired = not na(expirationTs) and time >= expirationTs
is0DTE = dte == 0
is1DTE = dte == 1

inCooldown = isRTH and minutesSinceOpen >= 0 and minutesSinceOpen < cooldownMin
lotoWindowOK = minutesSinceOpen >= cooldownMin and minutesSinceOpen < lotoWindowEnd
confirmedOK = minutesSinceOpen >= confirmedStart
approachingOK = minutesSinceOpen >= cooldownMin

// VIX gating
vixTrendUp = useVixFilter and not na(vixEma) and ta.rising(vixEma, 3)
vixRising = useVixFilter and not na(vixClose) and not na(vixEma) and vixClose > vixEma
vixLowVol = useVixFilter and not na(vixClose) and vixClose < vixConfirmedMin
vixHighVol = useVixFilter and not na(vixClose) and vixClose > vixConfirmedMax
vixAllowsLoto = not useVixFilter or (vixRising and vixTrendUp and not vixLowVol)
vixAllowsConfirmed = not useVixFilter or not vixHighVol

// TICK confirmation
tickDataReady = useTick and minutesSinceOpen >= tickStartMin
tick = tickDataReady ? tickRaw : na
tickBullish = not useTick or not tickDataReady or na(tick) or tick >= minTickBull
tickBearish = not useTick or not tickDataReady or na(tick) or tick <= maxTickBear

// Exit timing
forceExit = (is0DTE or is1DTE) and minutesToClose <= FORCE_EXIT_MIN
isExit15MinWarning = (is0DTE or is1DTE) and minutesToClose <= EXIT_WARNING_MIN and minutesToClose > FORCE_EXIT_MIN

// Filters
isSpike = useSpikeFilter and not na(m1AvgRange) and m1CandleRange > m1AvgRange * spikeMultiplier
volumeOK = not useVolumeConfirm or (bar_index > 20 and not na(m1VolAvg) and m1Volume > m1VolAvg * volumeMultiplier)
inMiddayChop = useMiddayFilter and minutesET >= MIDDAY_START and minutesET < MIDDAY_END
haltGapMinutes = barstate.isrealtime and not na(time[1]) ? (time - time[1]) / 60000 : 0
isPossibleHalt = useHaltDetection and haltGapMinutes >= haltGapThreshold and isRTH and isRTH[1] and bar_index > 10
barsSinceHalt = ta.barssince(isPossibleHalt)
inHaltCooldown = useHaltDetection and not na(barsSinceHalt) and barsSinceHalt <= haltCooldownBars
isFlatBar = useFlatBarFilter and priceHigh == priceLow
canEnterTime = minutesToClose > entryCutoffMin
cooldownJustEnded = minutesSinceOpen == cooldownMin and minutesSinceOpen[1] < cooldownMin

commonEntryFilters = isRTH and not isExpired and not isSpike and volumeOK and not inMiddayChop and not forceExit and not isPossibleHalt and not inHaltCooldown and not isFlatBar and canEnterTime
baseEntryFilters = commonEntryFilters and not cooldownJustEnded

// ═══════════════════════════════════════════════════════════════════════════════
// TREND DETECTION
// ═══════════════════════════════════════════════════════════════════════════════
emaBullish5m = m5EmaFast > m5EmaSlow
emaBearish5m = m5EmaFast < m5EmaSlow
vwapBullish5m = m5Close > m5Vwap
vwapBearish5m = m5Close < m5Vwap
confirmedUptrend = emaBullish5m and (not useVwapConfirm or m5Close >= m5Vwap - 0.05)
confirmedDowntrend = emaBearish5m and (not useVwapConfirm or m5Close <= m5Vwap + 0.05)

emaBullish1m = m1EmaFast > m1EmaSlow
emaBearish1m = m1EmaFast < m1EmaSlow
vwapBullish1m = m1Close > m1Vwap
vwapBearish1m = m1Close < m1Vwap
lotoUptrend = emaBullish1m and (not useVwapConfirm or vwapBullish1m)
lotoDowntrend = emaBearish1m and (not useVwapConfirm or vwapBearish1m)
pureDowntrend5m = emaBearish5m and vwapBearish5m
pureUptrend5m = emaBullish5m and vwapBullish5m

// Entry permissions
callConfirmedAllowed = not useTrendFilter or confirmedUptrend
putConfirmedAllowed = not useTrendFilter or confirmedDowntrend
callLotoAllowed = useLotoAlert and lotoUptrend and not pureDowntrend5m and (allowLotoReentry or not callHadTrade) and vixAllowsLoto
putLotoAllowed = useLotoAlert and lotoDowntrend and not pureUptrend5m and (allowLotoReentry or not putHadTrade) and vixAllowsLoto
callConfirmedAllowed := callConfirmedAllowed and vixAllowsConfirmed and tickBullish
putConfirmedAllowed := putConfirmedAllowed and vixAllowsConfirmed and tickBearish

// ═══════════════════════════════════════════════════════════════════════════════
// HELPER CONDITIONS
// ═══════════════════════════════════════════════════════════════════════════════
hasCall = enableCall and callEntry > 0 and callTargetPrice > callEntry
hasPut = enablePut and putEntry > 0 and putTargetPrice < putEntry
callApproaching = hasCall and priceNow < callEntry and priceNow >= callEntry - earlyAlertDist and approachingOK
putApproaching = hasPut and priceNow > putEntry and priceNow <= putEntry + earlyAlertDist and approachingOK
callBreak = hasCall and priceNow >= callEntry and pricePrev < callEntry
putBreak = hasPut and priceNow <= putEntry and pricePrev > putEntry
isFirstBarOfDay = isRTH and not isRTH[1]
callGapThrough = isFirstBarOfDay and hasCall and priceNow >= callEntry
putGapThrough = isFirstBarOfDay and hasPut and priceNow <= putEntry
callBreakOrGap = callBreak or callGapThrough or (callGapPending and priceNow >= callEntry)
putBreakOrGap = putBreak or putGapThrough or (putGapPending and priceNow <= putEntry)

callCanEnter = callBreakOrGap and baseEntryFilters and priceNow <= callEntry + MAX_ENTRY_SLIPPAGE and (directionLockedToday == "" or directionLockedToday == "CALL")
callLotoReady = callCanEnter and (not useLotoWindow or lotoWindowOK) and callLotoAllowed
callConfirmedReady = callCanEnter and confirmedOK and callConfirmedAllowed and not callLotoReady
callReadyToEnter = (callState == TradeState.IDLE or callState == TradeState.EARLY) and (callLotoReady or callConfirmedReady)
callEntryType = callLotoReady ? "LOTO" : callConfirmedReady ? "CONFIRMED" : ""

putCanEnter = putBreakOrGap and baseEntryFilters and priceNow >= putEntry - MAX_ENTRY_SLIPPAGE and (directionLockedToday == "" or directionLockedToday == "PUT")
putLotoReady = putCanEnter and (not useLotoWindow or lotoWindowOK) and putLotoAllowed
putConfirmedReady = putCanEnter and confirmedOK and putConfirmedAllowed and not putLotoReady
putReadyToEnter = (putState == TradeState.IDLE or putState == TradeState.EARLY) and (putLotoReady or putConfirmedReady)
putEntryType = putLotoReady ? "LOTO" : putConfirmedReady ? "CONFIRMED" : ""

callSlippageBlocked = callBreakOrGap and commonEntryFilters and priceNow > callEntry + MAX_ENTRY_SLIPPAGE and (callState == TradeState.IDLE or callState == TradeState.EARLY) and (not useTrendFilter or confirmedUptrend)
putSlippageBlocked = putBreakOrGap and commonEntryFilters and priceNow < putEntry - MAX_ENTRY_SLIPPAGE and (putState == TradeState.IDLE or putState == TradeState.EARLY) and (not useTrendFilter or confirmedDowntrend)

// ═══════════════════════════════════════════════════════════════════════════════
// STATE MACHINE - CALL
// ═══════════════════════════════════════════════════════════════════════════════
if callGapThrough and inCooldown and not callGapPending
    callGapPending := true
    evt_callGapPend := true

if callState == TradeState.IDLE and callApproaching and isRTH and not isExpired and not callEarlyFiredToday
    callState := TradeState.EARLY
    callEarlyFiredToday := true
    evt_callEarly := true

if callReadyToEnter
    callEntryPrice := callEntry
    callStopPrice := callEntryPrice - stopOffset
    callTargetDist = callTargetPrice - callEntry
    callT1Final := callEntryPrice + (callTargetDist * T1_PCT)
    callT2Final := callEntryPrice + (callTargetDist * T2_PCT)
    callT3Final := callEntryPrice + callTargetDist
    callEntryMode := callEntryType
    callEntryBar := bar_index
    callGapPending := false
    callHadTrade := true
    directionLockedToday := "CALL"
    callState := TradeState.IN_TRADE
    evt_callEntry := true

if callState == TradeState.IN_TRADE and bar_index > callEntryBar and not callStateChangedThisBar
    if not callT1Hit and not na(callT1Final) and priceHigh >= callT1Final
        callT1Hit := true
        evt_callT1 := true
        if useBreakEvenStop
            callStopPrice := callEntryPrice
    if callT1Hit and not callT2Hit and not na(callT2Final) and priceHigh >= callT2Final
        callT2Hit := true
        evt_callT2 := true
        if useTrailingStop
            callStopPrice := callT1Final
    if callT2Hit and not na(callT3Final) and priceHigh >= callT3Final
        callState := TradeState.EXITED
        evt_callT3 := true
        callStateChangedThisBar := true

if callState == TradeState.IN_TRADE and bar_index > callEntryBar and not na(callStopPrice) and priceLow <= callStopPrice and not callStateChangedThisBar
    callState := TradeState.EXITED
    evt_callStop := true
    callStateChangedThisBar := true

if callState == TradeState.EXITED and callState[1] == TradeState.EXITED
    callT1Hit := false
    callT2Hit := false
    callEarlyFiredToday := false
    callState := TradeState.IDLE

if callState == TradeState.EARLY and priceNow < callEntry - earlyAlertDist - 0.10
    callState := TradeState.IDLE

// ═══════════════════════════════════════════════════════════════════════════════
// STATE MACHINE - PUT
// ═══════════════════════════════════════════════════════════════════════════════
if putGapThrough and inCooldown and not putGapPending
    putGapPending := true
    evt_putGapPend := true

if putState == TradeState.IDLE and putApproaching and isRTH and not isExpired and not putEarlyFiredToday
    putState := TradeState.EARLY
    putEarlyFiredToday := true
    evt_putEarly := true

if putReadyToEnter
    putEntryPrice := putEntry
    putStopPrice := putEntryPrice + stopOffset
    putTargetDist = putEntry - putTargetPrice
    putT1Final := putEntryPrice - (putTargetDist * T1_PCT)
    putT2Final := putEntryPrice - (putTargetDist * T2_PCT)
    putT3Final := putEntryPrice - putTargetDist
    putEntryMode := putEntryType
    putEntryBar := bar_index
    putGapPending := false
    putHadTrade := true
    directionLockedToday := "PUT"
    putState := TradeState.IN_TRADE
    evt_putEntry := true

if putState == TradeState.IN_TRADE and bar_index > putEntryBar and not putStateChangedThisBar
    if not putT1Hit and not na(putT1Final) and priceLow <= putT1Final
        putT1Hit := true
        evt_putT1 := true
        if useBreakEvenStop
            putStopPrice := putEntryPrice
    if putT1Hit and not putT2Hit and not na(putT2Final) and priceLow <= putT2Final
        putT2Hit := true
        evt_putT2 := true
        if useTrailingStop
            putStopPrice := putT1Final
    if putT2Hit and not na(putT3Final) and priceLow <= putT3Final
        putState := TradeState.EXITED
        evt_putT3 := true
        putStateChangedThisBar := true

if putState == TradeState.IN_TRADE and bar_index > putEntryBar and not na(putStopPrice) and priceHigh >= putStopPrice and not putStateChangedThisBar
    putState := TradeState.EXITED
    evt_putStop := true
    putStateChangedThisBar := true

if putState == TradeState.EXITED and putState[1] == TradeState.EXITED
    putT1Hit := false
    putT2Hit := false
    putEarlyFiredToday := false
    putState := TradeState.IDLE

if putState == TradeState.EARLY and priceNow > putEntry + earlyAlertDist + 0.10
    putState := TradeState.IDLE

// ═══════════════════════════════════════════════════════════════════════════════
// SYSTEM & PROTECTION EVENTS
// ═══════════════════════════════════════════════════════════════════════════════
if forceExit and not forceExit[1] and (callState == TradeState.IN_TRADE or putState == TradeState.IN_TRADE)
    evt_forceExit := true
    if callState == TradeState.IN_TRADE
        callState := TradeState.EXITED
    if putState == TradeState.IN_TRADE
        putState := TradeState.EXITED
    directionLockedToday := ""

if isExit15MinWarning and not isExit15MinWarning[1] and (callState == TradeState.IN_TRADE or putState == TradeState.IN_TRADE)
    evt_15MinWarning := true

if isSpike and (callBreakOrGap or putBreakOrGap) and isRTH and barstate.isconfirmed and not spikeAlertFired
    evt_spikeBlocked := true
    spikeAlertFired := true
if not volumeOK and (callBreakOrGap or putBreakOrGap) and isRTH and not isSpike and barstate.isconfirmed and not volumeAlertFired
    evt_volumeBlocked := true
    volumeAlertFired := true
if inMiddayChop and (callBreakOrGap or putBreakOrGap) and isRTH and not isSpike and volumeOK and barstate.isconfirmed and not middayAlertFired
    evt_middayBlocked := true
    middayAlertFired := true
if callSlippageBlocked and barstate.isconfirmed and not slippageAlertFired
    evt_callSlippage := true
    slippageAlertFired := true
if putSlippageBlocked and barstate.isconfirmed and not slippageAlertFired
    evt_putSlippage := true
    slippageAlertFired := true
if isPossibleHalt and not haltAlertFired and isRTH
    evt_haltDetected := true
    haltAlertFired := true

// ═══════════════════════════════════════════════════════════════════════════════
// ALERT DISPATCH - CALL
// ═══════════════════════════════════════════════════════════════════════════════
if evt_callGapPend and isLiveBar and showWarningAlerts
    alert("[GAP PENDING] CALL $" + str.tostring(callStrike, "#") + "C | Entry queued", alert.freq_once_per_bar)
if evt_callEarly and isLiveBar
    alert("[EARLY] CALL $" + str.tostring(callStrike, "#") + "C " + callExp + " | $" + str.tostring(priceNow, "#.##") + " → $" + str.tostring(callEntry, "#.##"), alert.freq_once_per_bar)

canFireCallAlert = bar_index != lastCallAlertBar
entryAlertNotFired = lastCallAlertBar != callEntryBar
if (evt_callEntry or (callState == TradeState.IN_TRADE and (callEntryBar == bar_index or callEntryBar == bar_index - 1) and entryAlertNotFired)) and isLiveBar and not callAlertFiredThisBar and canFireCallAlert
    alert("[" + callEntryMode + "] CALL $" + str.tostring(callStrike, "#") + "C " + callExp + " | E$" + str.tostring(callEntryPrice, "#.##") + " S$" + str.tostring(callStopPrice, "#.##") + " T1$" + str.tostring(callT1Final, "#.##") + " T2$" + str.tostring(callT2Final, "#.##") + " T3$" + str.tostring(callT3Final, "#.##"), alert.freq_once_per_bar)
    callAlertFiredThisBar := true
    lastCallAlertBar := bar_index
if (evt_callT1 or (callState == TradeState.IN_TRADE and callT1Hit and not callT1Hit[1])) and isLiveBar and canFireCallAlert
    t1Msg = useBreakEvenStop ? " Stop→BE" : ""
    alert("[T1] CALL $" + str.tostring(callStrike, "#") + "C | $" + str.tostring(callT1Final, "#.##") + t1Msg, alert.freq_once_per_bar)
    callAlertFiredThisBar := true
    lastCallAlertBar := bar_index
if (evt_callT2 or (callState == TradeState.IN_TRADE and callT2Hit and not callT2Hit[1])) and isLiveBar and canFireCallAlert
    t2Msg = useTrailingStop ? " Stop→T1" : ""
    alert("[T2] CALL $" + str.tostring(callStrike, "#") + "C | $" + str.tostring(callT2Final, "#.##") + t2Msg, alert.freq_once_per_bar)
    callAlertFiredThisBar := true
    lastCallAlertBar := bar_index
if (evt_callT3 or (callState == TradeState.EXITED and callState[1] == TradeState.IN_TRADE and callT2Hit[1] and not na(callT3Final) and priceHigh[1] >= callT3Final)) and isLiveBar and canFireCallAlert
    alert("[TARGET] CALL $" + str.tostring(callStrike, "#") + "C | $" + str.tostring(callT3Final, "#.##") + " CLOSE", alert.freq_once_per_bar)
    callAlertFiredThisBar := true
    lastCallAlertBar := bar_index
if (evt_callStop or (callState == TradeState.EXITED and callState[1] == TradeState.IN_TRADE and not na(callStopPrice) and priceLow[1] <= callStopPrice and not (callT2Hit[1] and priceHigh[1] >= callT3Final))) and isLiveBar and canFireCallAlert
    alert("[STOP] CALL $" + str.tostring(callStrike, "#") + "C | $" + str.tostring(callStopPrice, "#.##"), alert.freq_once_per_bar)
    callAlertFiredThisBar := true
    lastCallAlertBar := bar_index
if evt_callSlippage and isLiveBar and showProtectionAlerts
    alert("[SLIPPAGE] CALL $" + str.tostring(callStrike, "#") + "C blocked", alert.freq_once_per_bar)

// ═══════════════════════════════════════════════════════════════════════════════
// ALERT DISPATCH - PUT
// ═══════════════════════════════════════════════════════════════════════════════
if evt_putGapPend and isLiveBar and showWarningAlerts
    alert("[GAP PENDING] PUT $" + str.tostring(putStrike, "#") + "P | Entry queued", alert.freq_once_per_bar)
if evt_putEarly and isLiveBar
    alert("[EARLY] PUT $" + str.tostring(putStrike, "#") + "P " + putExp + " | $" + str.tostring(priceNow, "#.##") + " → $" + str.tostring(putEntry, "#.##"), alert.freq_once_per_bar)

canFirePutAlert = bar_index != lastPutAlertBar
putEntryAlertNotFired = lastPutAlertBar != putEntryBar
if (evt_putEntry or (putState == TradeState.IN_TRADE and (putEntryBar == bar_index or putEntryBar == bar_index - 1) and putEntryAlertNotFired)) and isLiveBar and not putAlertFiredThisBar and canFirePutAlert
    alert("[" + putEntryMode + "] PUT $" + str.tostring(putStrike, "#") + "P " + putExp + " | E$" + str.tostring(putEntryPrice, "#.##") + " S$" + str.tostring(putStopPrice, "#.##") + " T1$" + str.tostring(putT1Final, "#.##") + " T2$" + str.tostring(putT2Final, "#.##") + " T3$" + str.tostring(putT3Final, "#.##"), alert.freq_once_per_bar)
    putAlertFiredThisBar := true
    lastPutAlertBar := bar_index
if (evt_putT1 or (putState == TradeState.IN_TRADE and putT1Hit and not putT1Hit[1])) and isLiveBar and canFirePutAlert
    t1MsgP = useBreakEvenStop ? " Stop→BE" : ""
    alert("[T1] PUT $" + str.tostring(putStrike, "#") + "P | $" + str.tostring(putT1Final, "#.##") + t1MsgP, alert.freq_once_per_bar)
    putAlertFiredThisBar := true
    lastPutAlertBar := bar_index
if (evt_putT2 or (putState == TradeState.IN_TRADE and putT2Hit and not putT2Hit[1])) and isLiveBar and canFirePutAlert
    t2MsgP = useTrailingStop ? " Stop→T1" : ""
    alert("[T2] PUT $" + str.tostring(putStrike, "#") + "P | $" + str.tostring(putT2Final, "#.##") + t2MsgP, alert.freq_once_per_bar)
    putAlertFiredThisBar := true
    lastPutAlertBar := bar_index
if (evt_putT3 or (putState == TradeState.EXITED and putState[1] == TradeState.IN_TRADE and putT2Hit[1] and not na(putT3Final) and priceLow[1] <= putT3Final)) and isLiveBar and canFirePutAlert
    alert("[TARGET] PUT $" + str.tostring(putStrike, "#") + "P | $" + str.tostring(putT3Final, "#.##") + " CLOSE", alert.freq_once_per_bar)
    putAlertFiredThisBar := true
    lastPutAlertBar := bar_index
if (evt_putStop or (putState == TradeState.EXITED and putState[1] == TradeState.IN_TRADE and not na(putStopPrice) and priceHigh[1] >= putStopPrice and not (putT2Hit[1] and priceLow[1] <= putT3Final))) and isLiveBar and canFirePutAlert
    alert("[STOP] PUT $" + str.tostring(putStrike, "#") + "P | $" + str.tostring(putStopPrice, "#.##"), alert.freq_once_per_bar)
    putAlertFiredThisBar := true
    lastPutAlertBar := bar_index
if evt_putSlippage and isLiveBar and showProtectionAlerts
    alert("[SLIPPAGE] PUT $" + str.tostring(putStrike, "#") + "P blocked", alert.freq_once_per_bar)

// ═══════════════════════════════════════════════════════════════════════════════
// ALERT DISPATCH - SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════
if evt_15MinWarning and isLiveBar and showWarningAlerts
    alert("[15 MIN WARNING] Close position soon", alert.freq_once_per_bar)
if evt_forceExit and barstate.isrealtime
    alert("[FORCE EXIT] EXIT NOW", alert.freq_once_per_bar)
if evt_spikeBlocked and isLiveBar and showProtectionAlerts
    alert("[SPIKE] Entry blocked", alert.freq_once_per_bar)
if evt_volumeBlocked and isLiveBar and showProtectionAlerts
    alert("[LOW VOL] Entry blocked", alert.freq_once_per_bar)
if evt_middayBlocked and isLiveBar and showProtectionAlerts
    alert("[MIDDAY] Entry blocked", alert.freq_once_per_bar)
if evt_haltDetected and isLiveBar and showWarningAlerts
    alert("[HALT] " + str.tostring(haltGapMinutes, "#") + "min gap detected", alert.freq_once_per_bar)

// ═══════════════════════════════════════════════════════════════════════════════
// LABELS
// ═══════════════════════════════════════════════════════════════════════════════
isSPY = str.upper(syminfo.ticker) == "SPY"
canShowLabels = showLabels and (not showLabelsOnSPYOnly or isSPY)
canCreateLabel = label.all.size() < 450
throttleCallEarly = bar_index % 2 == 0
throttlePutEarly = bar_index % 2 == 1

if evt_callEarly and canShowLabels and canCreateLabel and throttleCallEarly
    label.new(bar_index, priceHigh, "EARLY", style=label.style_label_down, color=color.new(color.yellow, 20), textcolor=color.black, size=size.small)
if evt_callEntry and canShowLabels and canCreateLabel
    label.new(bar_index, priceLow, callEntryMode == "LOTO" ? "LOTO" : "CALL", style=label.style_label_up, color=callEntryMode == "LOTO" ? color.orange : color.green, textcolor=color.white, size=size.small)
if evt_callT1 and canShowLabels and canCreateLabel
    label.new(bar_index, priceHigh, "T1", style=label.style_label_down, color=color.new(color.blue, 20), textcolor=color.white, size=size.small)
if evt_callT2 and canShowLabels and canCreateLabel
    label.new(bar_index, priceHigh, "T2", style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.small)
if evt_callT3 and canShowLabels and canCreateLabel
    label.new(bar_index, priceHigh, "TARGET", style=label.style_label_down, color=color.green, textcolor=color.white, size=size.small)
if evt_callStop and canShowLabels and canCreateLabel
    label.new(bar_index, priceLow, "STOP", style=label.style_label_up, color=color.red, textcolor=color.white, size=size.small)

if evt_putEarly and canShowLabels and canCreateLabel and throttlePutEarly
    label.new(bar_index, priceLow, "EARLY", style=label.style_label_up, color=color.new(color.yellow, 20), textcolor=color.black, size=size.small)
if evt_putEntry and canShowLabels and canCreateLabel
    label.new(bar_index, priceHigh, putEntryMode == "LOTO" ? "LOTO" : "PUT", style=label.style_label_down, color=putEntryMode == "LOTO" ? color.orange : color.new(color.red, 20), textcolor=color.white, size=size.small)
if evt_putT1 and canShowLabels and canCreateLabel
    label.new(bar_index, priceLow, "T1", style=label.style_label_up, color=color.new(color.blue, 20), textcolor=color.white, size=size.small)
if evt_putT2 and canShowLabels and canCreateLabel
    label.new(bar_index, priceLow, "T2", style=label.style_label_up, color=color.blue, textcolor=color.white, size=size.small)
if evt_putT3 and canShowLabels and canCreateLabel
    label.new(bar_index, priceLow, "TARGET", style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)
if evt_putStop and canShowLabels and canCreateLabel
    label.new(bar_index, priceHigh, "STOP", style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

if evt_forceExit and canShowLabels and canCreateLabel
    label.new(bar_index, priceHigh, "EXIT", style=label.style_label_down, color=color.purple, textcolor=color.white, size=size.small)
if not barstate.isrealtime and barstate.islast and canShowLabels and canCreateLabel
    label.new(bar_index, priceHigh + (priceHigh - priceLow) * 0.5, "⚠️ REPLAY", style=label.style_label_down, color=color.gray, textcolor=color.white, size=size.normal)

// ═══════════════════════════════════════════════════════════════════════════════
// LEVEL LINES
// ═══════════════════════════════════════════════════════════════════════════════
showCallLines = showLevelLines and isSPY and enableCall and callEntry > 0
showPutLines = showLevelLines and isSPY and enablePut and putEntry > 0
plot(showCallLines ? callEntry : na, "CALL Entry", color=color.new(color.green, 40), linewidth=2, style=plot.style_linebr)
plot(showCallLines ? callTargetPrice : na, "CALL Target", color=color.green, linewidth=2, style=plot.style_linebr)
plot(showPutLines ? putEntry : na, "PUT Entry", color=color.new(color.red, 40), linewidth=2, style=plot.style_linebr)
plot(showPutLines ? putTargetPrice : na, "PUT Target", color=color.red, linewidth=2, style=plot.style_linebr)

// ═══════════════════════════════════════════════════════════════════════════════
// DAILY RESET
// ═══════════════════════════════════════════════════════════════════════════════
if ta.change(time("D", "America/New_York")) != 0
    if callState == TradeState.IN_TRADE or putState == TradeState.IN_TRADE
        evt_forceExit := true
    callState := TradeState.IDLE
    callEntryPrice := na
    callStopPrice := na
    callT1Final := na
    callT2Final := na
    callT3Final := na
    callT1Hit := false
    callT2Hit := false
    callEntryMode := ""
    callEntryBar := na
    callEarlyFiredToday := false
    callGapPending := false
    putState := TradeState.IDLE
    putEntryPrice := na
    putStopPrice := na
    putT1Final := na
    putT2Final := na
    putT3Final := na
    putT1Hit := false
    putT2Hit := false
    putEntryMode := ""
    putEntryBar := na
    putEarlyFiredToday := false
    putGapPending := false
    directionLockedToday := ""
    callHadTrade := false
    putHadTrade := false
    spikeAlertFired := false
    volumeAlertFired := false
    middayAlertFired := false
    slippageAlertFired := false
    haltAlertFired := false
    lastCallAlertBar := na
    lastPutAlertBar := na

// Config lock label
var label configLockLabel = na
string lockText = "LOCKED " + str.format("{0,number,00}-{1,number,00} {2,number,00}:{3,number,00}", month(configLockTime), dayofmonth(configLockTime), hour(configLockTime), minute(configLockTime))
if isSPY and barstate.islast
    label.delete(configLockLabel)
    configLockLabel := label.new(bar_index, high, lockText, style=label.style_label_upper_right, color=color.new(color.blue, 70), textcolor=color.white, size=size.small)
