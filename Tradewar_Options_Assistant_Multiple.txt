//@version=5
indicator("Tradewar Options Assistant Multiple", overlay=true, dynamic_requests=true, max_labels_count=500)

// ============================================================================
// INPUT PARAMETERS - Ticker configurations (5 tickers supported)
// ============================================================================

group1  = "═══ TICKER 1 ═══"
t1_on   = input.bool(true, "Enable", group=group1)
t1_dir  = input.string("CALL", "Direction", options=["CALL","PUT"], group=group1)
t1_sym  = input.string("AMD", "Symbol", group=group1)
t1_k    = input.float(215, "Strike ($)", group=group1, step=1)
t1_exp  = input.string("JAN-16-26", "Expiry", group=group1)
t1_tgt  = input.float(220, "Target Price ($)", group=group1, step=0.01, tooltip="Final target price (T2) - script calculates T1/T2 automatically")
t1_res  = input.float(215.15, "Entry: Breaks ($)", group=group1, step=0.01)

group2  = "═══ TICKER 2 ═══"
t2_on   = input.bool(true, "Enable", group=group2)
t2_dir  = input.string("CALL", "Direction", options=["CALL","PUT"], group=group2)
t2_sym  = input.string("INTC", "Symbol", group=group2)
t2_k    = input.float(45, "Strike ($)", group=group2, step=1)
t2_exp  = input.string("JAN-16-26", "Expiry", group=group2)
t2_tgt  = input.float(47, "Target Price ($)", group=group2, step=0.01, tooltip="Final target price (T2)")
t2_res  = input.float(45.85, "Entry: Breaks ($)", group=group2, step=0.01)

group3  = "═══ TICKER 3 ═══"
t3_on   = input.bool(true, "Enable", group=group3)
t3_dir  = input.string("CALL", "Direction", options=["CALL","PUT"], group=group3)
t3_sym  = input.string("BMNR", "Symbol", group=group3)
t3_k    = input.float(32, "Strike ($)", group=group3, step=1)
t3_exp  = input.string("JAN-16-26", "Expiry", group=group3)
t3_tgt  = input.float(33, "Target Price ($)", group=group3, step=0.01, tooltip="Final target price (T2)")
t3_res  = input.float(32, "Entry: Breaks ($)", group=group3, step=0.01)

group4  = "═══ TICKER 4 ═══"
t4_on   = input.bool(true, "Enable", group=group4)
t4_dir  = input.string("CALL", "Direction", options=["CALL","PUT"], group=group4)
t4_sym  = input.string("OXY", "Symbol", group=group4)
t4_k    = input.float(43, "Strike ($)", group=group4, step=1)
t4_exp  = input.string("JAN-16-26", "Expiry", group=group4)
t4_tgt  = input.float(43.75, "Target Price ($)", group=group4, step=0.01, tooltip="Final target price (T2)")
t4_res  = input.float(43.25, "Entry: Breaks ($)", group=group4, step=0.01)

group5  = "═══ TICKER 5 ═══"
t5_on   = input.bool(false, "Enable", group=group5)
t5_dir  = input.string("CALL", "Direction", options=["CALL","PUT"], group=group5)
t5_sym  = input.string("SLV", "Symbol", group=group5)
t5_k    = input.float(78, "Strike ($)", group=group5, step=1)
t5_exp  = input.string("JAN-16-26", "Expiry", group=group5)
t5_tgt  = input.float(79, "Target Price ($)", group=group5, step=0.01, tooltip="Final target price (T2)")
t5_res  = input.float(77.55, "Entry: Breaks ($)", group=group5, step=0.01)

// ============================================================================
// Timing settings
// ============================================================================

groupSettings   = "═══ SETTINGS ═══"
cooldownMin     = input.int(2, "Cooldown After Open (min)", group=groupSettings, minval=1, maxval=10)
lotoWindowEnd   = input.int(10, "LOTO Window End (min)", group=groupSettings, minval=3, maxval=15)
confirmedStart  = input.int(5, "CONFIRMED Start (min)", group=groupSettings, minval=3, maxval=15)
earlyAlertDist  = input.float(0.50, "Early Alert Distance (%)", group=groupSettings, minval=0.10, maxval=2.00, step=0.10, tooltip="% below resistance to trigger early alert")
stopOffsetPct   = input.float(0.30, "Stop Offset (%)", group=groupSettings, minval=0.10, maxval=1.00, step=0.05, tooltip="% below entry for stop loss")
partialExitPct  = input.float(50, "Partial Exit % at T1", group=groupSettings, minval=10, maxval=90, step=5, tooltip="% of position to trim at T1, runners continue to T2")
trailPct        = input.float(0.25, "Trailing Stop % (after T1)", group=groupSettings, minval=0.1, maxval=1.0, step=0.05, tooltip="% trailing stop distance after T1 hit")

// ============================================================================
// Filter settings
// ============================================================================

groupFilters    = "═══ FILTERS ═══"
useTrendFilter  = input.bool(true, "Trend Filter (EMA 9 > 21)", group=groupFilters, tooltip="Recommended: ON - Prevents counter-trend entries")
emaFastLen      = input.int(9, "Fast EMA", group=groupFilters, minval=5, maxval=20, inline="ema")
emaSlowLen      = input.int(21, "Slow EMA", group=groupFilters, minval=10, maxval=50, inline="ema")
useVwapConfirm  = input.bool(false, "Require VWAP Confirmation", group=groupFilters, tooltip="OFF for catalyst plays - news stocks often gap above VWAP")
useLotoAlert    = input.bool(true, "Enable LOTO Alert (Fast 1-min)", group=groupFilters)

// ============================================================================
// Protection settings
// ============================================================================

groupProtection     = "═══ PROTECTION ═══"
useSpikeFilter      = input.bool(true, "Block Entry on Spike Candles", group=groupProtection, tooltip="Recommended: ON - Avoids chasing extended candles")
spikeMultiplier     = input.float(2.5, "Spike Threshold (x Avg Range)", group=groupProtection, minval=1.5, maxval=4.0, step=0.5, tooltip="Higher = more lenient for news spikes")
useVolumeConfirm    = input.bool(false, "Require Volume Confirmation", group=groupProtection, tooltip="OFF for catalyst plays - news already drives volume")
volumeMultiplier    = input.float(1.0, "Volume Threshold (x Avg)", group=groupProtection, minval=0.5, maxval=3.0, step=0.1)
useMiddayFilter     = input.bool(false, "Block Midday Chop (12:00-13:30 ET)", group=groupProtection, tooltip="OFF for catalyst plays - news can break out anytime")

// ============================================================================
// Alert & visual settings
// ============================================================================

groupAlerts         = "═══ ALERT PREFERENCES ═══"
showWarningAlerts   = input.bool(true, "Show Warning Alerts", group=groupAlerts, tooltip="GAP PENDING alerts")

groupVisual         = "═══ VISUAL SETTINGS ═══"
showLabels          = input.bool(true, "Show Chart Labels", group=groupVisual, tooltip="Display visual labels on chart for entries, targets, and stops")
showLevelLines      = input.bool(true, "Show Entry/Target Lines", group=groupVisual, tooltip="Display horizontal lines for entry and target levels (only on matching ticker chart)")

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

enum TradeDir
    CALL
    PUT

enum TradeEvent
    NONE
    EARLY
    ENTRY
    T1
    T2
    STOP
    GAP_PENDING
    FORCE_EXIT

enum TradeState
    IDLE
    EARLY
    IN_TRADE
    EXITED

// ============================================================================
// CONSTANTS
// ============================================================================

MARKET_OPEN_HOUR    = 9
MARKET_OPEN_MIN     = 30
MARKET_CLOSE_HOUR   = 16
MARKET_CLOSE_MIN    = 0
MARKET_OPEN         = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MIN
MARKET_CLOSE        = MARKET_CLOSE_HOUR * 60 + MARKET_CLOSE_MIN
DROP_THRESHOLD      = 0.10
FORCE_EXIT_MIN      = 5
MIDDAY_START        = 12 * 60
MIDDAY_END          = 13 * 60 + 30
T1_PCT              = 0.40
MAX_ENTRY_SLIPPAGE  = 0.15

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Parse month abbreviation to number (JAN -> 1, FEB -> 2, etc.)
parseMonth(m) =>
    u = str.upper(str.trim(m))
    u == "JAN" ? 1 : u == "FEB" ? 2 : u == "MAR" ? 3 : u == "APR" ? 4 : u == "MAY" ? 5 : u == "JUN" ? 6 : u == "JUL" ? 7 : u == "AUG" ? 8 : u == "SEP" ? 9 : u == "OCT" ? 10 : u == "NOV" ? 11 : u == "DEC" ? 12 : 0

// Parse expiry string (format: "JAN-09-26") to timestamp, handles 2-digit years
parseExp(s) =>
    result = float(na)
    if str.length(s) >= 9
        p = str.split(s, "-")
        if array.size(p) >= 3
            monthNum = parseMonth(array.get(p, 0))
            dayNum   = str.tonumber(array.get(p, 1))
            yearNum  = str.tonumber(array.get(p, 2))
            if not na(yearNum) and yearNum < 100
                yearNum := yearNum + 2000
            if monthNum > 0 and not na(dayNum) and not na(yearNum)
                result := timestamp(int(yearNum), monthNum, int(dayNum), 16, 0, 0)
    result

// Format days to expiration as string
dteStr(d) =>
    d == 0 ? "0DTE" : d == 1 ? "1DTE" : str.tostring(d) + "DTE"

// Format time component with leading zero
formatTimeComponent(val) =>
    (val < 10 ? "0" : "") + str.tostring(val)

// ============================================================================
// MARKET SESSION & TIME CALCULATIONS
// ============================================================================

var string SESSION_STRING = str.format("{0,number,00}{1,number,00}-{2,number,00}{3,number,00}", MARKET_OPEN_HOUR, MARKET_OPEN_MIN, MARKET_CLOSE_HOUR, MARKET_CLOSE_MIN)

currentHour         = hour(time, "America/New_York")
currentMin          = minute(time, "America/New_York")
minutesET           = currentHour * 60 + currentMin
isRTH               = not na(time(timeframe.period, SESSION_STRING, "America/New_York"))
minutesSinceOpen    = minutesET - MARKET_OPEN
minutesToClose      = MARKET_CLOSE - minutesET

inCooldown          = isRTH and minutesSinceOpen < cooldownMin
lotoWindowOK        = minutesSinceOpen >= cooldownMin and minutesSinceOpen < lotoWindowEnd
confirmedOK         = minutesSinceOpen >= confirmedStart
approachingOK       = minutesSinceOpen >= cooldownMin

inMiddayChop        = useMiddayFilter and minutesET >= MIDDAY_START and minutesET < MIDDAY_END

isConfirmedBar      = barstate.isconfirmed
isLastBar           = barstate.islast
chartTicker         = str.upper(syminfo.ticker)

var int configLockTime = na
configLockTime := na(configLockTime) ? timenow : configLockTime

// ============================================================================
// MAIN PROCESSING FUNCTION
// 3-Layer Architecture: Signal Layer → State Machine → Event Queue
// Returns: [entryMode, entryPrice, stopPrice, t1Final, t2Final, dte, currentPrice, wasFirstTrade]
// ============================================================================

processTicker(tickerIdx, enabled, sym, expTs, entryLevel, targetPrice, dir, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, exitBarArr, eventQueue, earlyFiredArr, gapPendingArr, hadTradeArr, partialTakenArr) =>
    returnEntryMode     = ""
    returnEntryPrice    = 0.0
    returnStopPrice     = 0.0
    returnT1            = 0.0
    returnT2            = 0.0
    returnDte           = 999
    returnPrice         = 0.0
    returnWasFirstTrade = false
    
    // Clear event queue for this bar
    array.clear(eventQueue)
    
    if enabled and entryLevel > 0
        // Fetch multi-timeframe data
        [tickerClose, tickerHigh, tickerLow, tickerClose1, tickerEmaFast, tickerEmaSlow, tickerVwap, tickerRange, tickerAvgRange, tickerVol, tickerVolAvg] = request.security(sym, "1", [close, high, low, close[1], ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen), ta.vwap, high - low, ta.sma(high - low, 20), volume, ta.sma(volume, 20)], lookahead=barmerge.lookahead_off)
        [m5EmaFast, m5EmaSlow, m5Vwap, m5Close] = request.security(sym, "5", [ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen), ta.vwap, close])
        
        returnPrice := tickerClose
        isCall       = dir == TradeDir.CALL
        
        // Calculate expiry and force exit conditions
        dte         = na(expTs) ? 1 : math.max(0, math.floor((expTs - time) / 86400000))
        returnDte  := dte
        isExpired   = not na(expTs) and time >= expTs
        forceExit   = ((dte == 0 or dte == 1) and minutesToClose <= FORCE_EXIT_MIN and minutesToClose >= 0)
        
        // Load state from arrays
        state           = array.get(stateArr, tickerIdx)
        entryMode       = array.get(entryModeArr, tickerIdx)
        entryBar        = array.get(entryBarArr, tickerIdx)
        exitBar         = array.get(exitBarArr, tickerIdx)
        entryPrice      = array.get(entryPriceArr, tickerIdx)
        stopPrice       = array.get(stopPriceArr, tickerIdx)
        t1Final         = array.get(t1FinalArr, tickerIdx)
        t2Final         = array.get(t2FinalArr, tickerIdx)
        earlyFired      = array.get(earlyFiredArr, tickerIdx)
        gapPending      = array.get(gapPendingArr, tickerIdx)
        hadTrade        = array.get(hadTradeArr, tickerIdx)
        partialTaken    = array.get(partialTakenArr, tickerIdx)
        
        // ====================================================================
        // SIGNAL LAYER (Pure Conditions - No State Mutation)
        // ====================================================================
        
        // Entry filters
        isSpike     = useSpikeFilter and not na(tickerAvgRange) and tickerRange > tickerAvgRange * spikeMultiplier
        volumeOK    = not useVolumeConfirm or (bar_index > 20 and not na(tickerVolAvg) and tickerVol > tickerVolAvg * volumeMultiplier)
        
        // Trend analysis (direction-aware)
        emaTrend1m  = isCall ? (tickerEmaFast > tickerEmaSlow) : (tickerEmaFast < tickerEmaSlow)
        vwapTrend1m = isCall ? (tickerClose > tickerVwap) : (tickerClose < tickerVwap)
        lotoTrendOK = emaTrend1m and (not useVwapConfirm or vwapTrend1m)
        
        emaTrend5m          = isCall ? (m5EmaFast > m5EmaSlow) : (m5EmaFast < m5EmaSlow)
        vwapTrend5m         = isCall ? (m5Close > m5Vwap) : (m5Close < m5Vwap)
        confirmedTrendOK    = emaTrend5m and (not useVwapConfirm or vwapTrend5m)
        
        pureCounterTrend5m  = isCall ? (m5EmaFast < m5EmaSlow and m5Close < m5Vwap) : (m5EmaFast > m5EmaSlow and m5Close > m5Vwap)
        
        lotoAllowed         = useLotoAlert and lotoTrendOK and not pureCounterTrend5m and not hadTrade
        confirmedAllowed    = (not useTrendFilter or confirmedTrendOK) and not pureCounterTrend5m
        
        // Pure signal conditions (no state mutation)
        earlyDist       = entryLevel * (earlyAlertDist / 100)
        earlyLevelPrice = isCall ? entryLevel - earlyDist : entryLevel + earlyDist
        earlyCond       = isCall ? (tickerClose < entryLevel and tickerClose >= earlyLevelPrice) : (tickerClose > entryLevel and tickerClose <= earlyLevelPrice)
        earlyCond      := earlyCond and approachingOK and isRTH and not isExpired and not earlyFired
        
        isFirstBarOfDay = isRTH and not isRTH[1]
        priceBreak      = isCall ? (tickerClose >= entryLevel and tickerClose1 < entryLevel) : (tickerClose <= entryLevel and tickerClose1 > entryLevel)
        entryCond       = priceBreak and isRTH and minutesSinceOpen >= cooldownMin and not isFirstBarOfDay and not isExpired
        
        gapThrough      = isFirstBarOfDay and (isCall ? tickerClose >= entryLevel : tickerClose <= entryLevel)
        
        localGapPending = gapPending
        if gapThrough and (inCooldown or (minutesSinceOpen == cooldownMin)) and not gapPending
            localGapPending := true
            array.push(eventQueue, TradeEvent.GAP_PENDING)
        
        gapPendingExpired = localGapPending and not inCooldown
        if gapPendingExpired
            localGapPending := false
        
        breakOrGap = priceBreak or gapThrough or (localGapPending and (isCall ? tickerClose >= entryLevel : tickerClose <= entryLevel)) or (gapPendingExpired and (isCall ? tickerClose >= entryLevel : tickerClose <= entryLevel))
        
        maxSlip     = entryLevel * (MAX_ENTRY_SLIPPAGE / 100)
        slippageOK  = isCall ? tickerClose <= entryLevel + maxSlip : tickerClose >= entryLevel - maxSlip
        
        validTarget = isCall ? targetPrice > entryLevel : targetPrice < entryLevel
        
        canEnter        = breakOrGap and isRTH and minutesSinceOpen >= cooldownMin and not isFirstBarOfDay and not isExpired and not isSpike and volumeOK and not inMiddayChop and slippageOK and not forceExit and validTarget
        lotoReady       = canEnter and lotoWindowOK and lotoAllowed
        confirmedReady  = canEnter and confirmedOK and confirmedAllowed
        
        // Tick-accurate target/stop conditions (use high/low, not close)
        t1Cond      = not na(t1Final) and t1Final > 0 and (isCall ? tickerHigh >= t1Final : tickerLow <= t1Final)
        t2Cond      = not na(t2Final) and t2Final > 0 and (isCall ? tickerHigh >= t2Final : tickerLow <= t2Final)
        stopCond    = not na(stopPrice) and (isCall ? tickerLow <= stopPrice : tickerHigh >= stopPrice)
        
        dropThreshold       = entryLevel * (DROP_THRESHOLD / 100)
        earlyDropCondition  = isCall ? tickerClose < earlyLevelPrice - dropThreshold : tickerClose > earlyLevelPrice + dropThreshold
        
        entryReady = entryCond and validTarget and (lotoReady or confirmedReady)
        
        // ====================================================================
        // STATE MACHINE (Clean & Ordered)
        // ====================================================================
        
        if state == TradeState.IDLE
            if earlyCond
                state      := TradeState.EARLY
                earlyFired := true
                array.push(eventQueue, TradeEvent.EARLY)
            
            if entryReady
                returnWasFirstTrade := not hadTrade
                entryPrice          := entryLevel
                stopOffset           = entryLevel * (stopOffsetPct / 100)
                stopPrice           := isCall ? entryPrice - stopOffset : entryPrice + stopOffset
                
                targetDist  = math.abs(targetPrice - entryLevel)
                t1Final    := isCall ? entryPrice + (targetDist * T1_PCT) : entryPrice - (targetDist * T1_PCT)
                t2Final    := targetPrice
                
                entryMode       := lotoReady ? "LOTO" : "CONFIRMED"
                entryBar        := bar_index
                localGapPending := false
                hadTrade        := true
                state           := TradeState.IN_TRADE
                array.push(eventQueue, TradeEvent.ENTRY)
            
            else if entryCond and validTarget
                // BREAK entry - visualization only
                returnWasFirstTrade := not hadTrade
                entryPrice          := entryLevel
                stopOffset           = entryLevel * (stopOffsetPct / 100)
                stopPrice           := isCall ? entryPrice - stopOffset : entryPrice + stopOffset
                
                targetDist  = math.abs(targetPrice - entryLevel)
                t1Final    := isCall ? entryPrice + (targetDist * T1_PCT) : entryPrice - (targetDist * T1_PCT)
                t2Final    := targetPrice
                
                entryMode       := "CONFIRMED"
                entryBar        := bar_index
                localGapPending := false
                hadTrade        := true
                state           := TradeState.IN_TRADE
                array.push(eventQueue, TradeEvent.ENTRY)
        
        else if state == TradeState.EARLY
            if earlyDropCondition
                state      := TradeState.IDLE
                earlyFired := false
            
            if entryReady
                returnWasFirstTrade := not hadTrade
                entryPrice          := entryLevel
                stopOffset           = entryLevel * (stopOffsetPct / 100)
                stopPrice           := isCall ? entryPrice - stopOffset : entryPrice + stopOffset
                
                targetDist  = math.abs(targetPrice - entryLevel)
                t1Final    := isCall ? entryPrice + (targetDist * T1_PCT) : entryPrice - (targetDist * T1_PCT)
                t2Final    := targetPrice
                
                entryMode       := lotoReady ? "LOTO" : "CONFIRMED"
                entryBar        := bar_index
                localGapPending := false
                hadTrade        := true
                state           := TradeState.IN_TRADE
                array.push(eventQueue, TradeEvent.ENTRY)
            
            else if entryCond and validTarget
                // BREAK entry from EARLY state
                returnWasFirstTrade := not hadTrade
                entryPrice          := entryLevel
                stopOffset           = entryLevel * (stopOffsetPct / 100)
                stopPrice           := isCall ? entryPrice - stopOffset : entryPrice + stopOffset
                
                targetDist  = math.abs(targetPrice - entryLevel)
                t1Final    := isCall ? entryPrice + (targetDist * T1_PCT) : entryPrice - (targetDist * T1_PCT)
                t2Final    := targetPrice
                
                entryMode       := "CONFIRMED"
                entryBar        := bar_index
                localGapPending := false
                hadTrade        := true
                state           := TradeState.IN_TRADE
                array.push(eventQueue, TradeEvent.ENTRY)
        
        else if state == TradeState.IN_TRADE
            if bar_index >= entryBar
                // Check stop first (highest priority)
                if stopCond
                    state   := TradeState.EXITED
                    exitBar := bar_index
                    array.push(eventQueue, TradeEvent.STOP)
                
                else if isExpired or forceExit
                    state   := TradeState.EXITED
                    exitBar := bar_index
                    array.push(eventQueue, TradeEvent.FORCE_EXIT)
                
                else
                    // Check targets (T2 before T1 for priority)
                    if t2Cond
                        if not partialTaken
                            partialTaken := true
                            array.push(eventQueue, TradeEvent.T1)
                        
                        state   := TradeState.EXITED
                        exitBar := bar_index
                        array.push(eventQueue, TradeEvent.T2)
                        
                        if not na(t1Final) and not na(stopPrice)
                            stopPrice := isCall ? math.max(t1Final, stopPrice) : math.min(t1Final, stopPrice)
                    
                    else
                        // Check T1 hit (fire event if not already fired)
                        if t1Cond and not partialTaken
                            partialTaken := true
                            array.push(eventQueue, TradeEvent.T1)
                        
                        // Update trailing stop every bar after T1 hits (tick-accurate using high/low)
                        if partialTaken
                            trailOffset     = entryPrice * (trailPct / 100)
                            newTrailStop    = isCall ? tickerHigh - trailOffset : tickerLow + trailOffset
                            stopPrice      := isCall ? math.max(stopPrice, newTrailStop) : math.min(stopPrice, newTrailStop)
        
        else if state == TradeState.EXITED
            // Hold EXITED state for 1 full bar before resetting to IDLE
            if bar_index > exitBar
                state        := TradeState.IDLE
                partialTaken := false
                
                // Reset entry bar to allow new entries after exit
                entryBar    := na
                entryPrice  := na
                stopPrice   := na
                t1Final     := na
                t2Final     := na
        
        // Persist state back to arrays
        array.set(stateArr, tickerIdx, state)
        array.set(entryModeArr, tickerIdx, entryMode)
        array.set(entryBarArr, tickerIdx, entryBar)
        array.set(exitBarArr, tickerIdx, exitBar)
        array.set(entryPriceArr, tickerIdx, entryPrice)
        array.set(stopPriceArr, tickerIdx, stopPrice)
        array.set(t1FinalArr, tickerIdx, t1Final)
        array.set(t2FinalArr, tickerIdx, t2Final)
        array.set(earlyFiredArr, tickerIdx, earlyFired)
        array.set(gapPendingArr, tickerIdx, localGapPending)
        array.set(hadTradeArr, tickerIdx, hadTrade)
        array.set(partialTakenArr, tickerIdx, partialTaken)
        
        returnEntryMode  := entryMode
        returnEntryPrice := entryPrice
        returnStopPrice  := stopPrice
        returnT1         := t1Final
        returnT2         := t2Final
    
    [returnEntryMode, returnEntryPrice, returnStopPrice, returnT1, returnT2, returnDte, returnPrice, returnWasFirstTrade]

// ============================================================================
// EVENT HANDLER FUNCTION
// Unified event handler: combines alerts and labels in one place.
// Only processes events on confirmed bars to prevent spam
// ============================================================================

handleEvent(evt, dir, sym, k, exp, mode, entryLevel, price, stop, t1, t2, dte, cur, first, matchChart) =>
    side        = dir == TradeDir.CALL ? "C" : "P"
    verbBreak   = dir == TradeDir.CALL ? "Breaks ABOVE" : "Breaks BELOW"
    
    if evt != TradeEvent.NONE
        // Process alerts on confirmed bars only
        if isConfirmedBar
            if evt == TradeEvent.GAP_PENDING and showWarningAlerts
                alert("[GAP PENDING] " + sym + " | $" + str.tostring(k, "#.##") + side + " | Gapped " + (dir == TradeDir.CALL ? "UP through" : "DOWN through") + " $" + str.tostring(entryLevel, "#.##") + " | Entry queued after cooldown", alert.freq_once_per_bar)
            
            if evt == TradeEvent.EARLY
                alert("[EARLY] " + sym + " | $" + str.tostring(k, "#.##") + side + " " + exp + " | Price $" + str.tostring(cur, "#.##") + " | Approaching $" + str.tostring(entryLevel, "#.##"), alert.freq_once_per_bar)
            
            if evt == TradeEvent.ENTRY and (mode == "LOTO" or mode == "CONFIRMED" or first)
                alertMsg = "[" + mode + "] " + sym + " | $" + str.tostring(k, "#.##") + side + " " + exp + " (" + dteStr(dte) + ") | " + verbBreak + " $" + str.tostring(entryLevel, "#.##") + " | Entry $" + str.tostring(price, "#.##") + " | Stop $" + str.tostring(stop, "#.##") + " | T1 $" + str.tostring(t1, "#.##") + " | T2 $" + str.tostring(t2, "#.##")
                if mode == "LOTO"
                    alert(alertMsg, alert.freq_once_per_bar)
                else
                    alert(alertMsg, alert.freq_once_per_bar_close)
            
            if evt == TradeEvent.T1
                alert("[T1 HIT – TRIM " + str.tostring(partialExitPct) + "%] " + sym + " | $" + str.tostring(k, "#.##") + side + " | Lock profits, runners to T2 $" + str.tostring(t2, "#.##"), alert.freq_once_per_bar)
            
            if evt == TradeEvent.T2
                alert("[TARGET] " + sym + " | $" + str.tostring(k, "#.##") + side + " " + exp + " | Hit $" + str.tostring(t2, "#.##") + " | CLOSE POSITION | Mode: " + mode, alert.freq_once_per_bar)
            
            if evt == TradeEvent.STOP
                alert("[STOP] " + sym + " | $" + str.tostring(k, "#.##") + side + " " + exp + " | Stopped $" + str.tostring(stop, "#.##") + " | Mode: " + mode, alert.freq_once_per_bar)
            
            if evt == TradeEvent.FORCE_EXIT
                alert("[FORCE EXIT] " + sym + " | $" + str.tostring(k, "#.##") + side + " " + exp + " | EXIT NOW - Market closing", alert.freq_once_per_bar)
        
        // Create labels for all bars (historical and live) when matchChart is true
        if matchChart
            if evt == TradeEvent.GAP_PENDING
                labelPos    = dir == TradeDir.CALL ? high : low
                labelStyle  = dir == TradeDir.CALL ? label.style_label_down : label.style_label_up
                label.new(bar_index, labelPos, "GAP", style=labelStyle, color=color.new(color.gray, 30), textcolor=color.white, size=size.small, tooltip="GAP PENDING " + sym + " | $" + str.tostring(k, "#.##") + side + " | " + (dir == TradeDir.CALL ? "above" : "below") + " $" + str.tostring(entryLevel, "#.##"))
            
            if evt == TradeEvent.EARLY
                labelPos    = dir == TradeDir.CALL ? high : low
                labelStyle  = dir == TradeDir.CALL ? label.style_label_down : label.style_label_up
                label.new(bar_index, labelPos, "EARLY", style=labelStyle, color=color.new(color.yellow, 20), textcolor=color.black, size=size.small, tooltip="EARLY " + sym + " $" + str.tostring(k, "#.##") + side + " | Approaching $" + str.tostring(entryLevel, "#.##"))
            
            if evt == TradeEvent.ENTRY
                lblText     = mode == "LOTO" ? "LOTO" : mode == "BREAK" ? "BREAK" : "CONFIRMED"
                lblColor    = mode == "LOTO" ? color.new(color.orange, 0) : color.new(color.green, 0)
                labelPos    = dir == TradeDir.CALL ? low : high
                labelStyle  = dir == TradeDir.CALL ? label.style_label_up : label.style_label_down
                label.new(bar_index, labelPos, lblText, style=labelStyle, color=lblColor, textcolor=color.white, size=size.small, tooltip="[" + mode + "] " + sym + " $" + str.tostring(k, "#.##") + side + " " + dteStr(dte) + " | Entry $" + str.tostring(price, "#.##") + " | Stop $" + str.tostring(stop, "#.##") + " | T1 $" + str.tostring(t1, "#.##") + " | T2 $" + str.tostring(t2, "#.##"))
            
            if evt == TradeEvent.T1
                labelPos    = dir == TradeDir.CALL ? high : low
                labelStyle  = dir == TradeDir.CALL ? label.style_label_down : label.style_label_up
                label.new(bar_index, labelPos, "T1", style=labelStyle, color=color.new(color.blue, 20), textcolor=color.white, size=size.small, tooltip="T1 HIT " + sym + " | $" + str.tostring(t1, "#.##"))
            
            if evt == TradeEvent.T2
                labelPos    = dir == TradeDir.CALL ? high : low
                labelStyle  = dir == TradeDir.CALL ? label.style_label_down : label.style_label_up
                label.new(bar_index, labelPos, "TARGET", style=labelStyle, color=color.new(color.green, 0), textcolor=color.white, size=size.small, tooltip="TARGET " + sym + " | $" + str.tostring(t2, "#.##") + " | CLOSE")
            
            if evt == TradeEvent.STOP
                labelPos    = dir == TradeDir.CALL ? low : high
                labelStyle  = dir == TradeDir.CALL ? label.style_label_up : label.style_label_down
                label.new(bar_index, labelPos, "STOP", style=labelStyle, color=color.new(color.red, 0), textcolor=color.white, size=size.small, tooltip="STOP " + sym + " | $" + str.tostring(stop, "#.##"))
            
            if evt == TradeEvent.FORCE_EXIT
                labelPos    = dir == TradeDir.CALL ? high : low
                labelStyle  = dir == TradeDir.CALL ? label.style_label_down : label.style_label_up
                label.new(bar_index, labelPos, "EXIT", style=labelStyle, color=color.new(color.purple, 0), textcolor=color.white, size=size.small, tooltip="FORCE EXIT " + sym)

// ============================================================================
// INITIALIZATION & SETUP - Parse expiry dates
// ============================================================================

t1_expTs = parseExp(t1_exp)
t2_expTs = parseExp(t2_exp)
t3_expTs = parseExp(t3_exp)
t4_expTs = parseExp(t4_exp)
t5_expTs = parseExp(t5_exp)

var stateArr        = array.new<TradeState>(5, TradeState.IDLE)
var string[] entryModeArr   = array.new_string(5, "")
var int[] entryBarArr       = array.new_int(5, na)
var float[] entryPriceArr   = array.new_float(5, na)
var float[] stopPriceArr    = array.new_float(5, na)
var float[] t1FinalArr      = array.new_float(5, na)
var float[] t2FinalArr      = array.new_float(5, na)
var bool[] earlyFiredArr    = array.new_bool(5, false)
var bool[] gapPendingArr    = array.new_bool(5, false)
var bool[] hadTradeArr      = array.new_bool(5, false)
var bool[] partialTakenArr  = array.new_bool(5, false)
var int[] exitBarArr        = array.new_int(5, na)

var array<TradeEvent> eventQueue1 = array.new<TradeEvent>()
var array<TradeEvent> eventQueue2 = array.new<TradeEvent>()
var array<TradeEvent> eventQueue3 = array.new<TradeEvent>()
var array<TradeEvent> eventQueue4 = array.new<TradeEvent>()
var array<TradeEvent> eventQueue5 = array.new<TradeEvent>()

// Reset all ticker states at start of each trading day
if ta.change(time("D", "America/New_York")) != 0
    for i = 0 to 4
        array.set(stateArr, i, TradeState.IDLE)
        array.set(entryModeArr, i, "")
        array.set(entryBarArr, i, na)
        array.set(entryPriceArr, i, na)
        array.set(stopPriceArr, i, na)
        array.set(t1FinalArr, i, na)
        array.set(t2FinalArr, i, na)
        array.set(earlyFiredArr, i, false)
        array.set(gapPendingArr, i, false)
        array.set(hadTradeArr, i, false)
        array.set(partialTakenArr, i, false)
        array.set(exitBarArr, i, na)
    array.clear(eventQueue1)
    array.clear(eventQueue2)
    array.clear(eventQueue3)
    array.clear(eventQueue4)
    array.clear(eventQueue5)

dir1 = t1_dir == "PUT" ? TradeDir.PUT : TradeDir.CALL
dir2 = t2_dir == "PUT" ? TradeDir.PUT : TradeDir.CALL
dir3 = t3_dir == "PUT" ? TradeDir.PUT : TradeDir.CALL
dir4 = t4_dir == "PUT" ? TradeDir.PUT : TradeDir.CALL
dir5 = t5_dir == "PUT" ? TradeDir.PUT : TradeDir.CALL

// ============================================================================
// MAIN EXECUTION - Process each ticker and generate events
// ============================================================================

[mode1, price1, stop1, t1_1, t2_1, dte1, cur1, first1] = processTicker(0, t1_on, t1_sym, t1_expTs, t1_res, t1_tgt, dir1, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, exitBarArr, eventQueue1, earlyFiredArr, gapPendingArr, hadTradeArr, partialTakenArr)
[mode2, price2, stop2, t1_2, t2_2, dte2, cur2, first2] = processTicker(1, t2_on, t2_sym, t2_expTs, t2_res, t2_tgt, dir2, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, exitBarArr, eventQueue2, earlyFiredArr, gapPendingArr, hadTradeArr, partialTakenArr)
[mode3, price3, stop3, t1_3, t2_3, dte3, cur3, first3] = processTicker(2, t3_on, t3_sym, t3_expTs, t3_res, t3_tgt, dir3, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, exitBarArr, eventQueue3, earlyFiredArr, gapPendingArr, hadTradeArr, partialTakenArr)
[mode4, price4, stop4, t1_4, t2_4, dte4, cur4, first4] = processTicker(3, t4_on, t4_sym, t4_expTs, t4_res, t4_tgt, dir4, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, exitBarArr, eventQueue4, earlyFiredArr, gapPendingArr, hadTradeArr, partialTakenArr)
[mode5, price5, stop5, t1_5, t2_5, dte5, cur5, first5] = processTicker(4, t5_on, t5_sym, t5_expTs, t5_res, t5_tgt, dir5, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, exitBarArr, eventQueue5, earlyFiredArr, gapPendingArr, hadTradeArr, partialTakenArr)

t1_match = showLabels and str.upper(t1_sym) == chartTicker
t2_match = showLabels and str.upper(t2_sym) == chartTicker
t3_match = showLabels and str.upper(t3_sym) == chartTicker
t4_match = showLabels and str.upper(t4_sym) == chartTicker
t5_match = showLabels and str.upper(t5_sym) == chartTicker

// Process event queues for each ticker
if array.size(eventQueue1) > 0
    for i = 0 to array.size(eventQueue1) - 1
        handleEvent(array.get(eventQueue1, i), dir1, t1_sym, t1_k, t1_exp, mode1, t1_res, price1, stop1, t1_1, t2_1, dte1, cur1, first1, t1_match)

if array.size(eventQueue2) > 0
    for i = 0 to array.size(eventQueue2) - 1
        handleEvent(array.get(eventQueue2, i), dir2, t2_sym, t2_k, t2_exp, mode2, t2_res, price2, stop2, t1_2, t2_2, dte2, cur2, first2, t2_match)

if array.size(eventQueue3) > 0
    for i = 0 to array.size(eventQueue3) - 1
        handleEvent(array.get(eventQueue3, i), dir3, t3_sym, t3_k, t3_exp, mode3, t3_res, price3, stop3, t1_3, t2_3, dte3, cur3, first3, t3_match)

if array.size(eventQueue4) > 0
    for i = 0 to array.size(eventQueue4) - 1
        handleEvent(array.get(eventQueue4, i), dir4, t4_sym, t4_k, t4_exp, mode4, t4_res, price4, stop4, t1_4, t2_4, dte4, cur4, first4, t4_match)

if array.size(eventQueue5) > 0
    for i = 0 to array.size(eventQueue5) - 1
        handleEvent(array.get(eventQueue5, i), dir5, t5_sym, t5_k, t5_exp, mode5, t5_res, price5, stop5, t1_5, t2_5, dte5, cur5, first5, t5_match)

// Debug helper - Visual confirmation of events
anyEvent = array.size(eventQueue1) > 0 or array.size(eventQueue2) > 0 or array.size(eventQueue3) > 0 or array.size(eventQueue4) > 0 or array.size(eventQueue5) > 0
plotchar(anyEvent, "EVENT", "•", location.top)

// ============================================================================
// VISUALIZATION - Plot entry and target lines (only for matching ticker chart)
// ============================================================================

showT1Lines = showLevelLines and t1_on and t1_res > 0 and str.upper(t1_sym) == chartTicker
showT2Lines = showLevelLines and t2_on and t2_res > 0 and str.upper(t2_sym) == chartTicker
showT3Lines = showLevelLines and t3_on and t3_res > 0 and str.upper(t3_sym) == chartTicker
showT4Lines = showLevelLines and t4_on and t4_res > 0 and str.upper(t4_sym) == chartTicker
showT5Lines = showLevelLines and t5_on and t5_res > 0 and str.upper(t5_sym) == chartTicker

// Direction-aware colors: Green for CALLs, Red for PUTs
t1_entryColor   = dir1 == TradeDir.CALL ? color.new(color.green, 40) : color.new(color.red, 40)
t1_targetColor  = dir1 == TradeDir.CALL ? color.new(color.green, 0)  : color.new(color.red, 0)
t2_entryColor   = dir2 == TradeDir.CALL ? color.new(color.green, 40) : color.new(color.red, 40)
t2_targetColor  = dir2 == TradeDir.CALL ? color.new(color.green, 0)  : color.new(color.red, 0)
t3_entryColor   = dir3 == TradeDir.CALL ? color.new(color.green, 40) : color.new(color.red, 40)
t3_targetColor  = dir3 == TradeDir.CALL ? color.new(color.green, 0)  : color.new(color.red, 0)
t4_entryColor   = dir4 == TradeDir.CALL ? color.new(color.green, 40) : color.new(color.red, 40)
t4_targetColor  = dir4 == TradeDir.CALL ? color.new(color.green, 0)  : color.new(color.red, 0)
t5_entryColor   = dir5 == TradeDir.CALL ? color.new(color.green, 40) : color.new(color.red, 40)
t5_targetColor  = dir5 == TradeDir.CALL ? color.new(color.green, 0)  : color.new(color.red, 0)

plot(showT1Lines ? t1_res : na, "T1 Entry",  color=showT1Lines ? t1_entryColor  : na, linewidth=2, style=plot.style_linebr)
plot(showT1Lines ? t1_tgt : na, "T1 Target", color=showT1Lines ? t1_targetColor : na, linewidth=2, style=plot.style_linebr)
plot(showT2Lines ? t2_res : na, "T2 Entry",  color=showT2Lines ? t2_entryColor  : na, linewidth=2, style=plot.style_linebr)
plot(showT2Lines ? t2_tgt : na, "T2 Target", color=showT2Lines ? t2_targetColor : na, linewidth=2, style=plot.style_linebr)
plot(showT3Lines ? t3_res : na, "T3 Entry",  color=showT3Lines ? t3_entryColor  : na, linewidth=2, style=plot.style_linebr)
plot(showT3Lines ? t3_tgt : na, "T3 Target", color=showT3Lines ? t3_targetColor : na, linewidth=2, style=plot.style_linebr)
plot(showT4Lines ? t4_res : na, "T4 Entry",  color=showT4Lines ? t4_entryColor  : na, linewidth=2, style=plot.style_linebr)
plot(showT4Lines ? t4_tgt : na, "T4 Target", color=showT4Lines ? t4_targetColor : na, linewidth=2, style=plot.style_linebr)
plot(showT5Lines ? t5_res : na, "T5 Entry",  color=showT5Lines ? t5_entryColor  : na, linewidth=2, style=plot.style_linebr)
plot(showT5Lines ? t5_tgt : na, "T5 Target", color=showT5Lines ? t5_targetColor : na, linewidth=2, style=plot.style_linebr)

// Display config lock timestamp on chart
anyTickerMatches = (t1_on and str.upper(t1_sym) == chartTicker) or 
                   (t2_on and str.upper(t2_sym) == chartTicker) or 
                   (t3_on and str.upper(t3_sym) == chartTicker) or 
                   (t4_on and str.upper(t4_sym) == chartTicker) or 
                   (t5_on and str.upper(t5_sym) == chartTicker)

var label configLockLabel = na
if anyTickerMatches and barstate.islast
    configLockLabelText = "LOCKED AT : " + 
                          formatTimeComponent(month(configLockTime)) + "-" + 
                          formatTimeComponent(dayofmonth(configLockTime)) + " " + 
                          formatTimeComponent(hour(configLockTime)) + ":" + 
                          formatTimeComponent(minute(configLockTime)) + ":" + 
                          formatTimeComponent(second(configLockTime))
    label.delete(configLockLabel)
    configLockLabel := label.new(bar_index, high, configLockLabelText, style=label.style_label_upper_right, color=color.new(color.blue, 70), textcolor=color.white, size=size.small)
