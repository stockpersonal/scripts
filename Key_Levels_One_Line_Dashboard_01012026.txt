//@version=5
indicator("Key Levels Dashboard", overlay=true, max_labels_count=500, max_bars_back=5000)

// ══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ══════════════════════════════════════════════════════════════════════════════

// ── Level Settings ────────────────────────────────────────────────────────────
i_tf              = input.string("D", "Key Level Base TF", options=["D", "W", "M"], group="Level Settings")
i_lookback_months  = input.int(18, "Lookback (Months)", minval=1, maxval=120, group="Level Settings")
i_bars_hold        = input.int(2, "Bars Level Must Hold", minval=1, maxval=10, group="Level Settings")
i_use_wick_retest  = input.bool(true, "Use Wick-Only Retest", group="Level Settings")

// ── ZigZag & Elliott Wave ─────────────────────────────────────────────────────
i_zz_depth         = input.int(8, "ZigZag Pivot Depth", minval=3, maxval=20, group="Elliott Wave")
i_min_retr_w2      = input.float(0.30, "Min W2 Retrace", minval=0.1, maxval=0.9, step=0.01, group="Elliott Wave")
i_max_retr_w2      = input.float(0.90, "Max W2 Retrace", minval=0.5, maxval=1.0, step=0.01, group="Elliott Wave")
i_min_ext_w3       = input.float(0.80, "Min W3 Extension", minval=0.5, maxval=2.0, step=0.01, group="Elliott Wave")

// ── ATR Settings ─────────────────────────────────────────────────────────────
i_atr_len          = input.int(14, "ATR Length", minval=5, maxval=50, group="ATR")
i_atr_mult         = input.float(0.236, "ATR Trigger %", minval=0.1, maxval=1.0, step=0.01, group="ATR")

// ── Alerts & Display ──────────────────────────────────────────────────────────
i_buffer           = input.float(0.20, "Alert Buffer ($)", group="Alerts & Display")
i_show_ew_fib      = input.bool(true, "Show EW & Fib in Dashboard", group="Alerts & Display")
i_use_options_lbl  = input.bool(true, "Use Options Labels", group="Alerts & Display")

// ══════════════════════════════════════════════════════════════════════════════
// CONSTANTS
// ══════════════════════════════════════════════════════════════════════════════
FMT = "#.##"
MAX_HIST = 5000
MAX_PIVS = 50
EW_MAX_AGE = 30

// ══════════════════════════════════════════════════════════════════════════════
// COLORS
// ══════════════════════════════════════════════════════════════════════════════
CLR_BULL   = color.rgb(0, 180, 80)
CLR_BEAR   = color.rgb(200, 50, 50)
CLR_CHOP   = color.rgb(255, 165, 0)
CLR_HEADER = color.rgb(255, 140, 0)
CLR_LEVEL  = color.rgb(0, 150, 70)
CLR_TARGET = color.rgb(0, 120, 200)
CLR_ATR    = color.rgb(120, 70, 160)
CLR_EW     = color.rgb(40, 80, 120)
CLR_FIB    = color.rgb(20, 60, 120)
CLR_EXT    = color.rgb(0, 140, 150)

// ══════════════════════════════════════════════════════════════════════════════
// PERSISTENT STATE VARIABLES
// ══════════════════════════════════════════════════════════════════════════════

// ── Pivot Arrays ──────────────────────────────────────────────────────────────
var float[] piv_val  = array.new_float()
var int[]   piv_type = array.new_int()
var int[]   piv_bar  = array.new_int()
var bool    piv_dirty = false
var bool    piv_ready_for_ew = false
var int     bars_since_pivot = 999

// ── ZigZag Structure ──────────────────────────────────────────────────────────
var float[] zz_highs_lock = array.new_float()
var float[] zz_lows_lock  = array.new_float()
var string  zz_structure = "N/A"
var color   zz_struct_clr = CLR_CHOP
var float   zz_last_val = na
var string  zz_last_type = "N/A"
var int     zz_last_age = na
var string  zz_bias = "→"

// ── Key Levels ────────────────────────────────────────────────────────────────
var float L1 = na
var float L2 = na
var float L3 = na
var int   hold_L1 = 0
var int   hold_L2 = 0
var int   hold_L3 = 0
var float L1_lock = na
var float L2_lock = na
var float L3_lock = na

// ── Elliott Wave State ────────────────────────────────────────────────────────
// Simplified state machine: ew_state can be "NONE", "ACTIVE", "INVALID", "WAITING"
var string ew_state = "NONE"  // Simplified state: NONE, ACTIVE, INVALID, WAITING
var string ew_dir = "NONE"
var float  ew_w0 = na      // W1 start (for Fibonacci calculations)
var float  ew_w1 = na      // W1 end / W2 start
var float  ew_w2 = na      // W2 end / W3 start
var float  ew_w3 = na      // W3 end / W4 start
var float  ew_w4 = na      // W4 end
var float  ew_w5 = na
var float  ew_invalid = na
var int    ew_age = 0
var int    ew_cooldown = 0
var int    ew_invalid_bar = na  // Track bar when invalidated to prevent same-bar re-detection

// ── Fibonacci Levels ──────────────────────────────────────────────────────────
var float  fib_50 = na
var float  fib_618 = na
var float  fib_786 = na
var float  fib_886 = na
var float  ext_127 = na
var float  ext_162 = na
var float  ext_200 = na
var string fib_src = "N/A"

// ── Targets ───────────────────────────────────────────────────────────────────
var float T1 = na
var float T2 = na
var float T3 = na
var bool  targets_locked = false
var float T1_lock = na
var float T2_lock = na
var float T3_lock = na

// ── Alert State ───────────────────────────────────────────────────────────────
var bool   fire = false
var string alrt = ""
var int    last_alert_bar = na
var bool alert_L1 = false

// ── UI Components ─────────────────────────────────────────────────────────────
var table tbl = table.new(position.bottom_right, 1, 18, border_width=1)

//
var float rng_h = na
var float rng_l = na
var string tgt_dir = "NONE"

// ══════════════════════════════════════════════════════════════════════════════
// FUNCTIONS
// ══════════════════════════════════════════════════════════════════════════════

// ──────────────────────────────────────────────────────────────────────────────
// Function: Detect Elliott Wave Pattern (Strict Rules)
// Returns: [found, direction, w1, w2, w3, w4, w5, invalid_level]
// ──────────────────────────────────────────────────────────────────────────────
f_detect_ew_strict(piv_val, piv_type, chop, min_retr_w2, max_retr_w2, min_ext_w3) =>
    bool   _found   = false
    string _dir     = "NONE"
    float  _w0      = na      // W1 start
    float  _w1      = na      // W1 end
    float  _w2      = na      // W2 end
    float  _w3      = na      // W3 end
    float  _w4      = na      // W4 end
    float  _w5      = na
    float  _invalid = na

    if not chop
        n = array.size(piv_val)
        if n >= 5
            start_ix = math.max(n - 15, 0)

            for ix = start_ix to n - 5
                v0 = array.get(piv_val, ix)
                v1 = array.get(piv_val, ix + 1)
                v2 = array.get(piv_val, ix + 2)
                v3 = array.get(piv_val, ix + 3)
                v4 = array.get(piv_val, ix + 4)

                t0 = array.get(piv_type, ix)
                t1 = array.get(piv_type, ix + 1)
                t2 = array.get(piv_type, ix + 2)
                t3 = array.get(piv_type, ix + 3)
                t4 = array.get(piv_type, ix + 4)

                // ─────────────────────────────
                // UP IMPULSE: 0-1-0-1-0
                // ─────────────────────────────
                if t0 == 0 and t1 == 1 and t2 == 0 and t3 == 1 and t4 == 0
                    w1 = v1 - v0
                    w2 = v1 - v2
                    w3 = v3 - v2

                    r2 = w1 != 0 ? w2 / w1 : 0
                    x3 = w1 != 0 ? w3 / w1 : 0

                    // STRICT RULES
                    valid =
                         r2 >= min_retr_w2 and r2 <= max_retr_w2 and
                         x3 >= min_ext_w3 and
                         w3 > w1 and
                         v4 > v2 and                 // Higher low (W4 > W2)
                         v4 > v0                     // NO W4 overlap with W1 (W4 low > W1 start)

                    if valid
                        _found   := true
                        _dir     := "UP"
                        _w0      := v0              // W1 start (for Fib retracements)
                        _w1      := v1              // W1 end / W2 start
                        _w2      := v2              // W2 end / W3 start
                        _w3      := v3              // W3 end / W4 start
                        _w4      := v4              // W4 end
                        _w5      := v4 + w3          // Conservative W5 proj
                        _invalid := math.min(v0, v2)
                        break

                // ─────────────────────────────
                // DOWN IMPULSE: 1-0-1-0-1
                // ─────────────────────────────
                if t0 == 1 and t1 == 0 and t2 == 1 and t3 == 0 and t4 == 1
                    w1 = v0 - v1
                    w2 = v2 - v1
                    w3 = v2 - v3

                    r2 = w1 != 0 ? w2 / w1 : 0
                    x3 = w1 != 0 ? w3 / w1 : 0

                    // STRICT RULES
                    valid =
                         r2 >= min_retr_w2 and r2 <= max_retr_w2 and
                         x3 >= min_ext_w3 and
                         w3 > w1 and
                         v4 < v2 and                 // Lower high (W4 < W2)
                         v4 < v0                     // NO W4 overlap with W1 (W4 high < W1 start)

                    if valid
                        _found   := true
                        _dir     := "DOWN"
                        _w0      := v0              // W1 start (for Fib retracements)
                        _w1      := v1              // W1 end / W2 start
                        _w2      := v2              // W2 end / W3 start
                        _w3      := v3              // W3 end / W4 start
                        _w4      := v4              // W4 end
                        _w5      := v4 - w3
                        _invalid := math.max(v0, v2)
                        break

    [_found, _dir, _w0, _w1, _w2, _w3, _w4, _w5, _invalid]

// ──────────────────────────────────────────────────────────────────────────────
// Function: Format Array as String List
// ──────────────────────────────────────────────────────────────────────────────
f_fmt_list(arr) =>
    if array.size(arr) == 0
        "N/A"
    else
        string s = ""
        for i = 0 to array.size(arr) - 1
            s += (i > 0 ? " | " : "") + str.tostring(array.get(arr, i), FMT)
        s

// ══════════════════════════════════════════════════════════════════════════════
// HIGHER TIMEFRAME DATA
// ══════════════════════════════════════════════════════════════════════════════
[htf_h, htf_l, htf_c] = request.security(syminfo.tickerid, i_tf, [high, low, close], barmerge.gaps_off, barmerge.lookahead_off)
new_htf_close = (ta.change(time(i_tf)) != 0) and barstate.isconfirmed

// ══════════════════════════════════════════════════════════════════════════════
// CORE CALCULATIONS
// ══════════════════════════════════════════════════════════════════════════════

// ── Range & Pivot Calculations ────────────────────────────────────────────────
bars_lb  = math.min(i_lookback_months * 21, MAX_HIST)
htf_piv_h = ta.pivothigh(htf_h, i_zz_depth, i_zz_depth)
htf_piv_l = ta.pivotlow(htf_l, i_zz_depth, i_zz_depth)

// ── Trend & ATR Calculations ──────────────────────────────────────────────────
e8  = ta.ema(close, 8)
e21 = ta.ema(close, 21)
e34 = ta.ema(close, 34)
atr = ta.atr(i_atr_len)

// Trend Direction
bull = close >= e8 and e8 >= e21 and e21 >= e34
bear = close <= e8 and e8 <= e21 and e21 <= e34
chop = not bull and not bear

t_clr = bull ? CLR_BULL : bear ? CLR_BEAR : CLR_CHOP
t_dir = bull ? "BULL" : bear ? "BEAR" : "CHOP"

// Trend Strength
spread = atr > 0 ? math.abs(e8 - e34) / atr : 0
t_type = chop or spread < 0.3 ? "CHOPPY" : spread < 0.6 ? "NORMAL" : spread < 1.0 ? "MOMENTUM" : "POWER"
t_risk = t_type == "CHOPPY" ? "Range (0%)" : t_type == "NORMAL" ? "Trend (2%)" : t_type == "MOMENTUM" ? "Clean (3%)" : "Breakout (0%)"

// ATR Triggers
atr_call = close[1] + atr[1] * i_atr_mult
atr_put  = close[1] - atr[1] * i_atr_mult
lbl_l = i_use_options_lbl ? "Calls" : "Long"
lbl_s = i_use_options_lbl ? "Puts" : "Short"

// Ready Signal
rdy_txt = chop ? "WAIT" : bull ? "LONG" : "SHORT"
rdy_clr = chop ? CLR_CHOP : bull ? CLR_BULL : CLR_BEAR

// ══════════════════════════════════════════════════════════════════════════════
// PIVOT MANAGEMENT
// ══════════════════════════════════════════════════════════════════════════════

// ── Store HTF Pivots ──────────────────────────────────────────────────────────
last_bar = array.size(piv_bar) > 0 ? array.last(piv_bar) : na
cur_bar  = bar_index - i_zz_depth

if new_htf_close and not na(htf_piv_h) and (na(last_bar) or cur_bar > last_bar)
    array.push(piv_val, htf_piv_h)
    array.push(piv_type, 1)
    array.push(piv_bar, bar_index - i_zz_depth)
    piv_dirty := true
    bars_since_pivot := 0
    if not piv_ready_for_ew
        piv_ready_for_ew := true

if new_htf_close and not na(htf_piv_l) and (na(last_bar) or cur_bar > last_bar)
    array.push(piv_val, htf_piv_l)
    array.push(piv_type, 0)
    array.push(piv_bar, bar_index - i_zz_depth)
    piv_dirty := true
    bars_since_pivot := 0
    if not piv_ready_for_ew
        piv_ready_for_ew := true

// ── Keep Arrays Bounded ───────────────────────────────────────────────────────
if array.size(piv_val) > MAX_PIVS
    while array.size(piv_val) > MAX_PIVS - 5
        array.shift(piv_val)
        array.shift(piv_type)
        array.shift(piv_bar)

// ── Sort Pivots by Bar Index (Only when dirty, with early exit) ──────────────
if piv_dirty and array.size(piv_bar) >= 2 and new_htf_close
    n_piv = array.size(piv_bar)
    swapped = true
    passes = 0
    max_passes = n_piv - 1
    while swapped and passes < max_passes
        swapped := false
        passes += 1
        for i = 0 to n_piv - 2
            if array.get(piv_bar, i) > array.get(piv_bar, i + 1)
                // Swap all three arrays
                tmp_bar = array.get(piv_bar, i)
                array.set(piv_bar, i, array.get(piv_bar, i + 1))
                array.set(piv_bar, i + 1, tmp_bar)
                
                tmp_val = array.get(piv_val, i)
                array.set(piv_val, i, array.get(piv_val, i + 1))
                array.set(piv_val, i + 1, tmp_val)
                
                tmp_type = array.get(piv_type, i)
                array.set(piv_type, i, array.get(piv_type, i + 1))
                array.set(piv_type, i + 1, tmp_type)
                
                swapped := true
    piv_dirty := false

if barstate.isconfirmed and not new_htf_close and ew_state == "NONE"
    bars_since_pivot += 1

// ══════════════════════════════════════════════════════════════════════════════
// HIGHER TIMEFRAME RESET & LEVEL CALCULATION
// ══════════════════════════════════════════════════════════════════════════════
if new_htf_close
    // Cleanup old pivots
    if array.size(piv_val) > MAX_PIVS
        array.shift(piv_val)
        array.shift(piv_type)
    
    // Always reset holds on new HTF bar
    hold_L1 := 0
    hold_L2 := 0
    hold_L3 := 0

    // Calculate Base Levels (Quartiles)
    rng_h := ta.highest(htf_h, bars_lb)
    rng_l := ta.lowest(htf_l, bars_lb)
    rng_m = (rng_h + rng_l) * 0.5

    _b1 = rng_l + (rng_m - rng_l) * 0.5
    _b2 = rng_m
    _b3 = rng_m + (rng_h - rng_m) * 0.5
    arr = array.new_float(3, 0)
    array.set(arr, 0, _b1)
    array.set(arr, 1, _b2)
    array.set(arr, 2, _b3)
    array.sort(arr)
    L1 := math.round(array.get(arr, 0), 2)
    L2 := math.round(array.get(arr, 1), 2)
    L3 := math.round(array.get(arr, 2), 2)
    L1_lock := L1
    L2_lock := L2
    L3_lock := L3

// ══════════════════════════════════════════════════════════════════════════════
// ZIGZAG STRUCTURE ANALYSIS
// ══════════════════════════════════════════════════════════════════════════════

// ── Collect Last 5 ZigZag Highs & Lows ────────────────────────────────────────
if new_htf_close
    array.clear(zz_highs_lock)
    array.clear(zz_lows_lock)

    n_piv = array.size(piv_val)
    if n_piv > 0
        for k = 0 to n_piv - 1
            i = n_piv - 1 - k
            if array.size(zz_highs_lock) < 5 or array.size(zz_lows_lock) < 5
                typ = array.get(piv_type, i)
                val = array.get(piv_val, i)

                if typ == 1 and array.size(zz_highs_lock) < 5
                    array.push(zz_highs_lock, val)

                if typ == 0 and array.size(zz_lows_lock) < 5
                    array.push(zz_lows_lock, val)
            else
                break

// ── Determine ZigZag Structure ────────────────────────────────────────────────
if new_htf_close
    if array.size(zz_highs_lock) < 2 or array.size(zz_lows_lock) < 2
        zz_structure := "N/A"
        zz_struct_clr := CLR_CHOP
    else if array.size(zz_highs_lock) >= 3 and array.size(zz_lows_lock) >= 2
        h0 = array.get(zz_highs_lock, 0)
        h1 = array.get(zz_highs_lock, 1)
        h2 = array.get(zz_highs_lock, 2)
        l0 = array.get(zz_lows_lock, 0)
        l1 = array.get(zz_lows_lock, 1)

        if h0 > h1 and h1 > h2 and l0 > l1
            zz_structure := "HH / HL (BULL)"
            zz_struct_clr := CLR_BULL
        else if h0 < h1 and h1 < h2 and l0 < l1
            zz_structure := "LH / LL (BEAR)"
            zz_struct_clr := CLR_BEAR
        else
            zz_structure := "RANGE / SHIFT"
            zz_struct_clr := CLR_CHOP

zz_bull_struct = zz_structure == "HH / HL (BULL)"
zz_bear_struct = zz_structure == "LH / LL (BEAR)"
zz_no_trade    = not zz_bull_struct and not zz_bear_struct

if new_htf_close and array.size(piv_val) > 0
    last_ix = array.size(piv_val) - 1
    zz_last_val := array.get(piv_val, last_ix)
    zz_last_type := array.get(piv_type, last_ix) == 1 ? "HIGH" : "LOW"
    zz_last_age := bar_index - array.get(piv_bar, last_ix)

zz_bias := zz_bull_struct ? "↑" : zz_bear_struct ? "↓" : "→"

// ══════════════════════════════════════════════════════════════════════════════
// ELLIOTT WAVE DETECTION
// ══════════════════════════════════════════════════════════════════════════════

// ── Directional Bias ─────────────────────────────────────────────────────────
is_long  = (bull or (ew_state == "ACTIVE" and ew_dir == "UP")) and zz_bull_struct and not chop
is_short = (bear or (ew_state == "ACTIVE" and ew_dir == "DOWN")) and zz_bear_struct and not chop

// ── Detect Elliott Wave Pattern ───────────────────────────────────────────────
ew_struct_ok = (zz_bull_struct and not zz_bear_struct) or (zz_bear_struct and not zz_bull_struct)
ew_found = ew_state == "ACTIVE"

if ew_state == "ACTIVE"
    if (ew_dir == "UP" and not zz_bull_struct) or (ew_dir == "DOWN" and not zz_bear_struct)
        ew_state := "WAITING"
        ew_age := 0
 
if ew_state == "WAITING" and ew_age > 2 and ew_struct_ok
    ew_state := "NONE"
    ew_dir := "NONE"
    ew_age := 0

// Strong signal: EW found OR momentum/power trend (less restrictive)
strong_signal = ew_found or t_type == "MOMENTUM" or t_type == "POWER" or (t_type == "NORMAL" and not chop)

// Prevent same-bar re-detection after invalidation
can_detect_ew = ew_state == "NONE" and ew_cooldown == 0 and (na(ew_invalid_bar) or bar_index != ew_invalid_bar)

if new_htf_close and piv_ready_for_ew and can_detect_ew and array.size(piv_val) >= 5 and ew_struct_ok
    piv_ready_for_ew := false
    [found_, dir_, w0_, w1_, w2_, w3_, w4_, w5_, invalid_] = f_detect_ew_strict(piv_val, piv_type, chop, i_min_retr_w2, i_max_retr_w2, i_min_ext_w3)
    if found_ and ((dir_ == "UP" and zz_bull_struct) or (dir_ == "DOWN" and zz_bear_struct))
        ew_state   := "ACTIVE"
        ew_dir     := dir_
        ew_w0      := w0_
        ew_w1      := w1_
        ew_w2      := w2_
        ew_w3      := w3_
        ew_w4      := w4_
        ew_w5      := w5_
        ew_invalid := invalid_
        ew_age     := 0
        ew_invalid_bar := na

// ── Age Elliott Wave Pattern ──────────────────────────────────────────────────
if (ew_state == "ACTIVE" or ew_state == "WAITING") and new_htf_close
    ew_age += 1

// ── Expire Old Elliott Wave Pattern ───────────────────────────────────────────
if ew_state == "ACTIVE" and ew_age > EW_MAX_AGE
    ew_state := "NONE"
    ew_dir := "NONE"
    ew_w0 := na
    ew_w1 := na
    ew_w2 := na
    ew_w3 := na
    ew_w4 := na
    ew_w5 := na
    ew_invalid := na
    fib_src := "N/A"
    ew_age := 0

// ── Clear targets when EW expires ───────────────────────────────────────────
if ew_state == "NONE" and targets_locked
    targets_locked := false
    T1 := na
    T2 := na
    T3 := na
    T1_lock := na
    T2_lock := na
    T3_lock := na
    tgt_dir := "NONE"

// ══════════════════════════════════════════════════════════════════════════════
// FIBONACCI LEVELS & TARGETS
// ══════════════════════════════════════════════════════════════════════════════

// ── Calculate Fibonacci Levels ───────────────────────────────────────────────
if ew_state == "ACTIVE"
    fib_src := "EW"
    // Use W1 range (from W1 start to W1 end) for Fibonacci calculations
    w1_rng = math.abs(ew_w1 - ew_w0)  // W1 range (the impulse wave)
    
    if ew_dir == "UP"
        // For UP waves: W0 is start (low), W1 is end (high)
        // Retracements: measured from W1 end back toward W0 start
        // Extensions: measured from W1 end continuing upward
        fib_50  := ew_w1 - w1_rng * 0.5
        fib_618 := ew_w1 - w1_rng * 0.618
        fib_786 := ew_w1 - w1_rng * 0.786
        fib_886 := ew_w1 - w1_rng * 0.886
        ext_127 := ew_w1 + w1_rng * 1.272
        ext_162 := ew_w1 + w1_rng * 1.618
        ext_200 := ew_w1 + w1_rng * 2.0
    else
        // For DOWN waves: W0 is start (high), W1 is end (low)
        // Retracements: measured from W1 end back toward W0 start
        // Extensions: measured from W1 end continuing downward
        fib_50  := ew_w1 + w1_rng * 0.5
        fib_618 := ew_w1 + w1_rng * 0.618
        fib_786 := ew_w1 + w1_rng * 0.786
        fib_886 := ew_w1 + w1_rng * 0.886
        ext_127 := ew_w1 - w1_rng * 1.272
        ext_162 := ew_w1 - w1_rng * 1.618
        ext_200 := ew_w1 - w1_rng * 2.0

    T1 := ext_127
    T2 := ext_162
    T3 := ext_200

// ── Lock Targets on L2 Crossover ─────────────────────────────────────────────
crossover_L2 = ta.crossover(close, L2)
crossunder_L2 = ta.crossunder(close, L2)
lock_condition = ew_state == "ACTIVE" and not targets_locked and not na(L2_lock) and ((ew_dir == "UP" and high > L2_lock) or (ew_dir == "DOWN" and low < L2_lock))

if not targets_locked and lock_condition and not na(T1)
    targets_locked := true
    T1_lock := T1
    T2_lock := T2
    T3_lock := T3
    tgt_dir := ew_dir

if targets_locked
    T1 := T1_lock
    T2 := T2_lock
    T3 := T3_lock

// ══════════════════════════════════════════════════════════════════════════════
// ENTRY SIGNAL GENERATION
// ══════════════════════════════════════════════════════════════════════════════

// ── Breakout Detection ────────────────────────────────────────────────────────
brk1 = close > L1_lock and close[1] <= L1_lock
brk2 = close > L2_lock and close[1] <= L2_lock
brk3 = close > L3_lock and close[1] <= L3_lock

brk1d = close < L1_lock and close[1] >= L1_lock
brk2d = close < L2_lock and close[1] >= L2_lock
brk3d = close < L3_lock and close[1] >= L3_lock

prev_long  = is_long[1]
prev_short = is_short[1]

// ── Retest Logic (Wick-Only Option) ───────────────────────────────────────────
// Less strict: Allow wick retest OR close retest (more flexible)
max_wick = atr * 0.5  // Increased from 0.25 to be less restrictive
rt1 = i_use_wick_retest ? (is_long ? ((low <= L1_lock and close > L1_lock) and ((L1_lock - low) <= max_wick or math.abs(close - L1_lock) <= max_wick * 0.5)) : ((high >= L1_lock and close < L1_lock) and ((high - L1_lock) <= max_wick or math.abs(close - L1_lock) <= max_wick * 0.5))) : (is_long ? close >= L1_lock : close <= L1_lock)
rt2 = i_use_wick_retest ? (is_long ? ((low <= L2_lock and close > L2_lock) and ((L2_lock - low) <= max_wick or math.abs(close - L2_lock) <= max_wick * 0.5)) : ((high >= L2_lock and close < L2_lock) and ((high - L2_lock) <= max_wick or math.abs(close - L2_lock) <= max_wick * 0.5))) : (is_long ? close >= L2_lock : close <= L2_lock)
rt3 = i_use_wick_retest ? (is_long ? ((low <= L3_lock and close > L3_lock) and ((L3_lock - low) <= max_wick or math.abs(close - L3_lock) <= max_wick * 0.5)) : ((high >= L3_lock and close < L3_lock) and ((high - L3_lock) <= max_wick or math.abs(close - L3_lock) <= max_wick * 0.5))) : (is_long ? close >= L3_lock : close <= L3_lock)

// ── Reset Hold Counters on Direction Change ──────────────────────────────────
if (is_long and prev_short) or (is_short and prev_long)
    hold_L1 := 0
    hold_L2 := 0
    hold_L3 := 0

// ── Track Bars Holding Levels ────────────────────────────────────────────────
if is_long
    hold_L1 := brk1 ? 1 : hold_L1 > 0 and close >= L1_lock ? hold_L1 + 1 : 0
    hold_L2 := brk2 ? 1 : hold_L2 > 0 and close >= L2_lock ? hold_L2 + 1 : 0
    hold_L3 := brk3 ? 1 : hold_L3 > 0 and close >= L3_lock ? hold_L3 + 1 : 0
else if is_short
    hold_L1 := brk1d ? -1 : hold_L1 < 0 and close <= L1_lock ? hold_L1 - 1 : 0
    hold_L2 := brk2d ? -1 : hold_L2 < 0 and close <= L2_lock ? hold_L2 - 1 : 0
    hold_L3 := brk3d ? -1 : hold_L3 < 0 and close <= L3_lock ? hold_L3 - 1 : 0

hld1 = hold_L1 >= i_bars_hold
hld2 = hold_L2 >= i_bars_hold
hld3 = hold_L3 >= i_bars_hold

// ── Generate Entry Signals ────────────────────────────────────────────────────
ent1 = ((is_long and brk1) or (is_short and brk1d)) and rt1 and hld1 and barstate.isconfirmed
ent2 = ((is_long and brk2) or (is_short and brk2d)) and rt2 and hld2 and barstate.isconfirmed
ent3 = ((is_long and brk3) or (is_short and brk3d)) and rt3 and hld3 and barstate.isconfirmed

struct_ok = (is_long and zz_bull_struct) or (is_short and zz_bear_struct)
ent1 := ent1 and struct_ok and strong_signal
ent2 := ent2 and struct_ok and strong_signal
ent3 := ent3 and struct_ok and strong_signal

// ══════════════════════════════════════════════════════════════════════════════
// PATTERN DETECTION NEAR LEVELS
// ══════════════════════════════════════════════════════════════════════════════
// Use confirmed bars only to prevent repaint
nr1 = math.abs(close[1] - L1_lock) <= i_buffer
nr2 = math.abs(close[1] - L2_lock) <= i_buffer
nr3 = math.abs(close[1] - L3_lock) <= i_buffer
need_ptn = (nr1 or nr2 or nr3) and bars_since_pivot > i_zz_depth and not new_htf_close and not new_htf_close[1] and barstate.isconfirmed

bull_ptn = false
bear_ptn = false

// Only calculate pattern detection when near levels and not choppy
if need_ptn and t_type != "CHOPPY"
    min_body  = atr * 0.2
    min_range = atr * 0.5
    body  = math.abs(close[1] - open[1])
    bar_rng = high[1] - low[1]
    
    if body >= min_body and bar_rng >= min_range
        bull_ptn := (open[2] > close[2] and close[1] > open[1] and open[1] <= close[2] and close[1] >= open[2]) or (bar_rng > 0 and (high[1] - math.max(open[1], close[1])) <= bar_rng * 0.25 and (math.min(open[1], close[1]) - low[1]) >= bar_rng * 0.5) or (close[3] < open[3] and close[2] < open[2] and close[1] > (open[3] + close[3]) * 0.5)
        bear_ptn := (open[2] < close[2] and close[1] < open[1] and open[1] >= close[2] and close[1] <= open[2]) or (bar_rng > 0 and (math.max(open[1], close[1]) - low[1]) <= bar_rng * 0.25 and (high[1] - math.min(open[1], close[1])) >= bar_rng * 0.5) or (close[3] > open[3] and close[2] > open[2] and close[1] < (open[3] + close[3]) * 0.5)

// ══════════════════════════════════════════════════════════════════════════════
// DASHBOARD DISPLAY
// ══════════════════════════════════════════════════════════════════════════════
if barstate.islast
    r = 0
    table.cell(tbl, 0, r, syminfo.ticker + " | Key Levels", text_color=color.white, bgcolor=CLR_HEADER)
    r += 1
    table.cell(tbl, 0, r, "Ready: " + rdy_txt, text_color=color.white, bgcolor=rdy_clr)
    r += 1
    table.cell(tbl, 0, r, "Trend: " + t_dir + " | " + t_type, text_color=color.white, bgcolor=t_clr)
    r += 1
    table.cell(tbl, 0, r, "L1/L2/L3: " + str.tostring(L1, FMT) + " / " + str.tostring(L2, FMT) + " / " + str.tostring(L3, FMT), text_color=color.white, bgcolor=CLR_LEVEL)
    r += 1
    t_src = targets_locked ? "(LOCKED)" : ew_found ? "(EW)" : fib_src == "ATR" ? "(ATR)" : "(N/A)"
    t_arr = ew_dir == "UP" ? "↑" : ew_dir == "DOWN" ? "↓" : bull ? "↑" : bear ? "↓" : "→"
    t_txt = ew_state != "ACTIVE" and not targets_locked ? "T1/T2/T3: N/A" : "T1/T2/T3 " + t_src + t_arr + ": " + str.tostring(T1, FMT) + " / " + str.tostring(T2, FMT) + " / " + str.tostring(T3, FMT)
    table.cell(tbl, 0, r, t_txt, text_color=color.white, bgcolor=CLR_TARGET )
    r += 1
    table.cell(tbl, 0, r, "ZZ Structure: " + zz_structure, text_color=color.white, bgcolor=zz_struct_clr)
    r += 1
    table.cell(tbl, 0, r, "ZZ Last: " + zz_last_type + " @ " + str.tostring(zz_last_val, FMT) + " | Age: " + str.tostring(zz_last_age), text_color=color.white, bgcolor=zz_struct_clr)
    r += 1
    table.cell(tbl, 0, r, "ZZ Highs: " + f_fmt_list(zz_highs_lock), text_color=color.white, bgcolor=CLR_BEAR)
    r += 1
    table.cell(tbl, 0, r, "ZZ Lows: " + f_fmt_list(zz_lows_lock), text_color=color.white, bgcolor=CLR_BULL)
    r += 1
    tr_now = high - low
    atr_p = close > 0 ? atr / close * 100 : 0
    table.cell(tbl, 0, r, "ATR: " + str.tostring(atr, FMT) + " (" + str.tostring(atr_p, "#.#") + "%) | TR: " + str.tostring(tr_now, FMT), text_color=color.white, bgcolor=CLR_ATR)
    r += 1
    table.cell(tbl, 0, r, lbl_l + " > " + str.tostring(atr_call, FMT) + " | " + lbl_s + " < " + str.tostring(atr_put, FMT), text_color=color.white, bgcolor=CLR_ATR)
    r += 1
    table.cell(tbl, 0, r, "Risk: " + t_risk, text_color=color.white, bgcolor=t_clr)
    r += 1
    if i_show_ew_fib
        if ew_state == "ACTIVE"
            table.cell(tbl, 0, r, "EW " + ew_dir + ": " + str.tostring(ew_w1, FMT) + "/" + str.tostring(ew_w2, FMT) + "/" + str.tostring(ew_w3, FMT) + "/" + str.tostring(ew_w4, FMT), text_color=color.white, bgcolor=CLR_EW)
            r += 1
            table.cell(tbl, 0, r, "Fib: .5=" + str.tostring(fib_50, FMT) + " .618=" + str.tostring(fib_618, FMT) + " .786=" + str.tostring(fib_786, FMT), text_color=color.white, bgcolor=CLR_FIB)
            r += 1
            table.cell(tbl, 0, r, "Ext: 1.27=" + str.tostring(ext_127, FMT) + " 1.62=" + str.tostring(ext_162, FMT) + " 2.0=" + str.tostring(ext_200, FMT), text_color=color.white, bgcolor=CLR_EXT)
        else
            table.cell(tbl, 0, r, "EW: None | Fib: N/A", text_color=color.rgb(67, 28, 28), bgcolor=color.rgb(80, 80, 80))

// ══════════════════════════════════════════════════════════════════════════════
// ALERT SYSTEM
// ══════════════════════════════════════════════════════════════════════════════

// ── Reset Alert State ─────────────────────────────────────────────────────────
if fire and barstate.isconfirmed and bar_index != last_alert_bar
    fire := false
    alrt := ""

// ── Elliott Wave Invalidation Alert ──────────────────────────────────────────
if ew_state == "ACTIVE" and not targets_locked and na(ew_invalid_bar) and ((ew_dir == "UP" and close < ew_invalid) or (ew_dir == "DOWN" and close > ew_invalid))
    fire := true
    alrt := "⚠ EW INVALID @ " + str.tostring(ew_invalid, FMT)
    ew_dir := "NONE"
    ew_invalid := na
    ew_invalid_bar := bar_index
    fib_src := "N/A"
    ew_age := 0
    ew_cooldown := 1
    ew_state := "NONE"
    targets_locked := false
    T1 := na
    T2 := na
    T3 := na
    T1_lock := na
    T2_lock := na
    T3_lock := na
    tgt_dir := "NONE"

 
if barstate.isconfirmed and ew_cooldown > 0
    ew_cooldown -= 1

// ── Pattern Near Levels Alerts ────────────────────────────────────────────────
if need_ptn and not fire
    if nr1 and bull_ptn and is_long
        fire := true
        alrt := "L1 + Bull @ " + str.tostring(L1, FMT)
    else if nr1 and bear_ptn and is_short
        fire := true
        alrt := "L1 + Bear @ " + str.tostring(L1, FMT)
    else if nr2 and bull_ptn and is_long
        fire := true
        alrt := "L2 + Bull @ " + str.tostring(L2, FMT)
    else if nr2 and bear_ptn and is_short
        fire := true
        alrt := "L2 + Bear @ " + str.tostring(L2, FMT)
    else if nr3 and bull_ptn and is_long
        fire := true
        alrt := "L3 + Bull @ " + str.tostring(L3, FMT)
    else if nr3 and bear_ptn and is_short
        fire := true
        alrt := "L3 + Bear @ " + str.tostring(L3, FMT)

// ── Breakout Alerts ──────────────────────────────────────────────────────────
if not fire
    xL1u = ta.crossover(close, L1_lock)
    xL1d = ta.crossunder(close, L1_lock)
    
    if xL1u and is_long and zz_bull_struct
        fire := true
        alrt := "BREAK ↑ L1 @ " + str.tostring(L1_lock, FMT)
    else if xL1d and is_short and zz_bear_struct
        fire := true
        alrt := "BREAK ↓ L1 @ " + str.tostring(L1_lock, FMT)
    else
        xL2u = ta.crossover(close, L2_lock)
        xL2d = ta.crossunder(close, L2_lock)
        
        if xL2u and is_long and zz_bull_struct
            fire := true
            alrt := "BREAK ↑ L2 @ " + str.tostring(L2_lock, FMT)
        else if xL2d and is_short and zz_bear_struct
            fire := true
            alrt := "BREAK ↓ L2 @ " + str.tostring(L2_lock, FMT)
        else
            xL3u = ta.crossover(close, L3_lock)
            xL3d = ta.crossunder(close, L3_lock)
            
            if xL3u and is_long and zz_bull_struct
                fire := true
                alrt := "BREAK ↑ L3 @ " + str.tostring(L3_lock, FMT)
            else if xL3d and is_short and zz_bear_struct
                fire := true
                alrt := "BREAK ↓ L3 @ " + str.tostring(L3_lock, FMT)

// ── Advanced Entry Alerts ─────────────────────────────────────────────────────
if not fire
    if ent1
        fire := true
        alrt := "ADV L1 @ " + str.tostring(L1_lock, FMT)
    else if ent2
        fire := true
        alrt := "ADV L2 @ " + str.tostring(L2_lock, FMT)
    else if ent3
        fire := true
        alrt := "ADV L3 @ " + str.tostring(L3_lock, FMT)

// ── Target Alerts ────────────────────────────────────────────────────────────
if not fire and not na(T1)
    bull_dir = ew_dir == "UP" or (ew_state != "ACTIVE" and bull)
    bear_dir = ew_dir == "DOWN" or (ew_state != "ACTIVE" and bear)
    
    if bull_dir
        if close >= T1 and close[1] < T1
            fire := true
            alrt := "T1 ↑ @ " + str.tostring(T1, FMT)
        else if close >= T2 and close[1] < T2
            fire := true
            alrt := "T2 ↑ @ " + str.tostring(T2, FMT)
        else if close >= T3 and close[1] < T3
            fire := true
            alrt := "T3 ↑ @ " + str.tostring(T3, FMT)
    
    if not fire and bear_dir
        if close <= T1 and close[1] > T1
            fire := true
            alrt := "T1 ↓ @ " + str.tostring(T1, FMT)
        else if close <= T2 and close[1] > T2
            fire := true
            alrt := "T2 ↓ @ " + str.tostring(T2, FMT)
        else if close <= T3 and close[1] > T3
            fire := true
            alrt := "T3 ↓ @ " + str.tostring(T3, FMT)

// ── ATR Trigger Alerts ───────────────────────────────────────────────────────
if not fire
    if is_long
        uATR = ta.crossover(close, atr_call)
        if uATR
            fire := true
            alrt := lbl_l + " @ " + str.tostring(atr_call, FMT)
    else if is_short
        dATR = ta.crossunder(close, atr_put)
        if dATR
            fire := true
            alrt := lbl_s + " @ " + str.tostring(atr_put, FMT)

// ── Fire Alert ───────────────────────────────────────────────────────────────
if fire and barstate.isconfirmed and bar_index != last_alert_bar
    alert(alrt, alert.freq_once_per_bar)
    last_alert_bar := bar_index
