//@version=5
indicator("Tradewar Options Assistant Multiple", overlay=true, dynamic_requests=true, max_labels_count=500)

group1 = "═══ TICKER 1 ═══"
t1_on   = input.bool(true, "Enable", group=group1)
t1_sym  = input.string("OKLO", "Symbol", group=group1)
t1_k    = input.float(113, "Strike ($)", group=group1, step=1)
t1_exp  = input.string("JAN-09-26", "Expiry", group=group1)
t1_tgt  = input.float(125, "Target Price ($)", group=group1, step=0.01, tooltip="Final target price (T2) - script calculates T1/T2 automatically")
t1_res  = input.float(116.57, "Entry: Breaks ($)", group=group1, step=0.01)

group2 = "═══ TICKER 2 ═══"
t2_on   = input.bool(true, "Enable", group=group2)
t2_sym  = input.string("TLRY", "Symbol", group=group2)
t2_k    = input.float(10, "Strike ($)", group=group2, step=1)
t2_exp  = input.string("JAN-09-26", "Expiry", group=group2)
t2_tgt  = input.float(11, "Target Price ($)", group=group2, step=0.01, tooltip="Final target price (T2)")
t2_res  = input.float(10.45, "Entry: Breaks ($)", group=group2, step=0.01)

group3 = "═══ TICKER 3 ═══"
t3_on   = input.bool(true, "Enable", group=group3)
t3_sym  = input.string("ABNB", "Symbol", group=group3)
t3_k    = input.float(138, "Strike ($)", group=group3, step=1)
t3_exp  = input.string("JAN-09-26", "Expiry", group=group3)
t3_tgt  = input.float(141.5, "Target Price ($)", group=group3, step=0.01, tooltip="Final target price (T2)")
t3_res  = input.float(140, "Entry: Breaks ($)", group=group3, step=0.01)

group4 = "═══ TICKER 4 ═══"
t4_on   = input.bool(true, "Enable", group=group4)
t4_sym  = input.string("CLF", "Symbol", group=group4)
t4_k    = input.float(12, "Strike ($)", group=group4, step=1)
t4_exp  = input.string("JAN-09-26", "Expiry", group=group4)
t4_tgt  = input.float(13, "Target Price ($)", group=group4, step=0.01, tooltip="Final target price (T2)")
t4_res  = input.float(12.68, "Entry: Breaks ($)", group=group4, step=0.01)

group5 = "═══ TICKER 5 ═══"
t5_on   = input.bool(true, "Enable", group=group5)
t5_sym  = input.string("LUV", "Symbol", group=group5)
t5_k    = input.float(43.5, "Strike ($)", group=group5, step=1)
t5_exp  = input.string("JAN-09-26", "Expiry", group=group5)
t5_tgt  = input.float(46, "Target Price ($)", group=group5, step=0.01, tooltip="Final target price (T2)")
t5_res  = input.float(44.6, "Entry: Breaks ($)", group=group5, step=0.01)

groupSettings = "═══ SETTINGS ═══"
cooldownMin     = input.int(2, "Cooldown After Open (min)", group=groupSettings, minval=1, maxval=10)
lotoWindowEnd   = input.int(10, "LOTO Window End (min)", group=groupSettings, minval=3, maxval=15)
confirmedStart  = input.int(5, "CONFIRMED Start (min)", group=groupSettings, minval=3, maxval=15)
earlyAlertDist  = input.float(0.50, "Early Alert Distance (%)", group=groupSettings, minval=0.10, maxval=2.00, step=0.10, tooltip="% below resistance to trigger early alert")
stopOffsetPct   = input.float(0.30, "Stop Offset (%)", group=groupSettings, minval=0.10, maxval=1.00, step=0.05, tooltip="% below entry for stop loss")

groupFilters = "═══ FILTERS ═══"
useTrendFilter  = input.bool(true, "Trend Filter (EMA 9 > 21)", group=groupFilters, tooltip="Recommended: ON - Prevents counter-trend entries")
emaFastLen      = input.int(9, "Fast EMA", group=groupFilters, minval=5, maxval=20, inline="ema")
emaSlowLen      = input.int(21, "Slow EMA", group=groupFilters, minval=10, maxval=50, inline="ema")
useVwapConfirm  = input.bool(false, "Require VWAP Confirmation", group=groupFilters, tooltip="OFF for catalyst plays - news stocks often gap above VWAP")
useLotoAlert    = input.bool(true, "Enable LOTO Alert (Fast 1-min)", group=groupFilters)

groupProtection = "═══ PROTECTION ═══"
useSpikeFilter      = input.bool(true, "Block Entry on Spike Candles", group=groupProtection, tooltip="Recommended: ON - Avoids chasing extended candles")
spikeMultiplier     = input.float(2.5, "Spike Threshold (x Avg Range)", group=groupProtection, minval=1.5, maxval=4.0, step=0.5, tooltip="Higher = more lenient for news spikes")
useVolumeConfirm    = input.bool(false, "Require Volume Confirmation", group=groupProtection, tooltip="OFF for catalyst plays - news already drives volume")
volumeMultiplier    = input.float(1.0, "Volume Threshold (x Avg)", group=groupProtection, minval=0.5, maxval=3.0, step=0.1)
useMiddayFilter     = input.bool(false, "Block Midday Chop (12:00-13:30 ET)", group=groupProtection, tooltip="OFF for catalyst plays - news can break out anytime")

groupAlerts = "═══ ALERT PREFERENCES ═══"
showWarningAlerts = input.bool(true, "Show Warning Alerts", group=groupAlerts, tooltip="GAP PENDING alerts")

groupVisual = "═══ VISUAL SETTINGS ═══"
showLabels      = input.bool(true, "Show Chart Labels", group=groupVisual, tooltip="Display visual labels on chart for entries, targets, and stops")
showLevelLines  = input.bool(true, "Show Entry/Target Lines", group=groupVisual, tooltip="Display horizontal lines for entry and target levels (only on matching ticker chart)")

enum TradeState
    IDLE
    EARLY
    IN_TRADE
    EXITED

MARKET_OPEN_HOUR  = 9
MARKET_OPEN_MIN   = 30
MARKET_CLOSE_HOUR = 16
MARKET_CLOSE_MIN  = 0
MARKET_OPEN       = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MIN
MARKET_CLOSE      = MARKET_CLOSE_HOUR * 60 + MARKET_CLOSE_MIN
DROP_THRESHOLD    = 0.10
FORCE_EXIT_MIN    = 5
MIDDAY_START      = 12 * 60
MIDDAY_END        = 13 * 60 + 30

T1_PCT = 0.40
T2_PCT = 0.60

MAX_ENTRY_SLIPPAGE = 0.15

parseMonth(m) =>
    u = str.upper(str.trim(m))
    u == "JAN" ? 1 : u == "FEB" ? 2 : u == "MAR" ? 3 : u == "APR" ? 4 : u == "MAY" ? 5 : u == "JUN" ? 6 : u == "JUL" ? 7 : u == "AUG" ? 8 : u == "SEP" ? 9 : u == "OCT" ? 10 : u == "NOV" ? 11 : u == "DEC" ? 12 : 0

parseExp(s) =>
    result = float(na)
    if str.length(s) >= 9
        p = str.split(s, "-")
        if array.size(p) >= 3
            monthNum = parseMonth(array.get(p, 0))
            dayNum = str.tonumber(array.get(p, 1))
            yearNum = str.tonumber(array.get(p, 2))
            if not na(yearNum) and yearNum < 100
                yearNum := yearNum + 2000
            if monthNum > 0 and not na(dayNum) and not na(yearNum)
                result := timestamp(int(yearNum), monthNum, int(dayNum), 16, 0, 0)
    result

dteStr(d) => d == 0 ? "0DTE" : d == 1 ? "1DTE" : str.tostring(d) + "DTE"

var string SESSION_STRING = str.format("{0,number,00}{1,number,00}-{2,number,00}{3,number,00}", MARKET_OPEN_HOUR, MARKET_OPEN_MIN, MARKET_CLOSE_HOUR, MARKET_CLOSE_MIN)
currentHour      = hour(time, "America/New_York")
currentMin       = minute(time, "America/New_York")
minutesET        = currentHour * 60 + currentMin
isRTH            = not na(time(timeframe.period, SESSION_STRING, "America/New_York"))
minutesSinceOpen = minutesET - MARKET_OPEN
minutesToClose   = MARKET_CLOSE - minutesET

inCooldown    = isRTH and minutesSinceOpen < cooldownMin
lotoWindowOK  = minutesSinceOpen >= cooldownMin and minutesSinceOpen < lotoWindowEnd
confirmedOK   = minutesSinceOpen >= confirmedStart
approachingOK = minutesSinceOpen >= cooldownMin

inMiddayChop = useMiddayFilter and minutesET >= MIDDAY_START and minutesET < MIDDAY_END

isLiveBar = barstate.isrealtime

chartTicker = str.upper(syminfo.ticker)

var int configLockTime = na
configLockTime := na(configLockTime) ? timenow : configLockTime

// Main ticker processing function - handles state machine, entry/exit logic, and target tracking
processTicker(tickerIdx, enabled, sym, expTs, entryLevel, targetPrice, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, t1HitArr, t2HitArr, earlyFiredArr, gapPendingArr, hadTradeArr) =>
    
    evt_early    = false
    evt_entry    = false
    evt_t1       = false
    evt_t2       = false
    evt_stop     = false
    evt_gapPend  = false
    evt_forceExit = false
    returnEntryMode = ""
    returnEntryPrice = 0.0
    returnStopPrice = 0.0
    returnT1 = 0.0
    returnT2 = 0.0
    returnDte = 999
    returnPrice = 0.0
    returnWasFirstTrade = false
    
    if enabled and entryLevel > 0
        // Fetch 1-minute timeframe data for entry signals and trend analysis
        [tickerClose, tickerHigh, tickerLow, tickerClose1, tickerEmaFast, tickerEmaSlow, tickerVwap, tickerRange, tickerAvgRange, tickerVol, tickerVolAvg] = request.security(sym, "1", [close, high, low, close[1], ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen), ta.vwap, high - low, ta.sma(high - low, 20), volume, ta.sma(volume, 20)], lookahead=barmerge.lookahead_off)
        
        // Fetch 5-minute timeframe data for confirmed trend analysis
        [m5EmaFast, m5EmaSlow, m5Vwap, m5Close] = request.security(sym, "5", [ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen), ta.vwap, close])
        
        returnPrice := tickerClose
        
        // Calculate days to expiration
        dte = na(expTs) ? 1 : math.max(0, math.floor((expTs - time) / 86400000))
        returnDte := dte
        isExpired = not na(expTs) and time >= expTs
        // Force exit for 0DTE/1DTE positions near market close to avoid assignment risk
        forceExit = ((dte == 0 or dte == 1) and minutesToClose <= FORCE_EXIT_MIN and minutesToClose >= 0)
        
        // Load current state and trade data from arrays
        state = array.get(stateArr, tickerIdx)
        entryMode = array.get(entryModeArr, tickerIdx)
        entryBar = array.get(entryBarArr, tickerIdx)
        entryPrice = array.get(entryPriceArr, tickerIdx)
        stopPrice = array.get(stopPriceArr, tickerIdx)
        t1Final = array.get(t1FinalArr, tickerIdx)
        t2Final = array.get(t2FinalArr, tickerIdx)
        t1Hit = array.get(t1HitArr, tickerIdx)
        t2Hit = array.get(t2HitArr, tickerIdx)
        earlyFired = array.get(earlyFiredArr, tickerIdx)
        gapPending = array.get(gapPendingArr, tickerIdx)
        hadTrade = array.get(hadTradeArr, tickerIdx)
        justExited = state == TradeState.EXITED
        
        // Entry filters: spike detection and volume confirmation
        isSpike = useSpikeFilter and not na(tickerAvgRange) and tickerRange > tickerAvgRange * spikeMultiplier
        volumeOK = not useVolumeConfirm or (bar_index > 20 and not na(tickerVolAvg) and tickerVol > tickerVolAvg * volumeMultiplier)
        
        // Trend analysis: 1-minute timeframe for LOTO entries
        emaBullish1m = tickerEmaFast > tickerEmaSlow
        vwapBullish1m = tickerClose > tickerVwap
        lotoUptrend = emaBullish1m and (not useVwapConfirm or vwapBullish1m)
        
        // Trend analysis: 5-minute timeframe for confirmed entries
        emaBullish5m = m5EmaFast > m5EmaSlow
        vwapBullish5m = m5Close > m5Vwap
        confirmedUptrend = emaBullish5m and (not useVwapConfirm or vwapBullish5m)
        
        // Detect strong downtrend on 5-minute timeframe
        pureDowntrend5m = m5EmaFast < m5EmaSlow and m5Close < m5Vwap
        
        // Entry mode permissions: LOTO requires uptrend and no previous trade, CONFIRMED requires trend filter check
        lotoAllowed = useLotoAlert and lotoUptrend and not pureDowntrend5m and not hadTrade
        confirmedAllowed = (not useTrendFilter or confirmedUptrend) and not pureDowntrend5m
        
        // Early alert: trigger when price approaches entry level within configured distance
        earlyDist = entryLevel * (earlyAlertDist / 100)
        earlyLevelPrice = entryLevel - earlyDist
        approaching = tickerClose < entryLevel and tickerClose >= earlyLevelPrice and approachingOK
        
        // Entry signal: price breaks above entry level (current bar above, previous bar below)
        priceBreak = tickerClose >= entryLevel and tickerClose1 < entryLevel
        
        // Gap detection: first bar of RTH session where price opens above entry level
        isFirstBarOfDay = isRTH and not isRTH[1]
        gapThrough = isFirstBarOfDay and tickerClose >= entryLevel
        
        // Gap pending logic: track gaps that occur during cooldown period
        localGapPending = gapPending
        if gapThrough and (inCooldown or (minutesSinceOpen == cooldownMin)) and not gapPending
            localGapPending := true
            evt_gapPend := true
        
        // Clear gap pending flag when cooldown ends, but allow entry if price is still above entry level
        gapPendingExpired = localGapPending and not inCooldown and minutesSinceOpen >= cooldownMin
        if gapPendingExpired
            localGapPending := false
        
        // Entry trigger: price break, gap-through, gap pending with price above entry, or expired gap pending with price still above entry
        breakOrGap = priceBreak or gapThrough or (localGapPending and tickerClose >= entryLevel) or (gapPendingExpired and tickerClose >= entryLevel)
        
        // Slippage check: allow entry if price is within acceptable range above entry level
        maxSlip = entryLevel * (MAX_ENTRY_SLIPPAGE / 100)
        slippageOK = tickerClose <= entryLevel + maxSlip
        
        // Validate target price is above entry level
        validTarget = targetPrice > entryLevel
        
        // Entry conditions: combine all filters and time windows
        canEnter = breakOrGap and isRTH and not isExpired and not isSpike and volumeOK and not inMiddayChop and slippageOK and not forceExit and validTarget
        lotoReady = canEnter and lotoWindowOK and lotoAllowed
        confirmedReady = canEnter and confirmedOK and confirmedAllowed
        readyToEnter = (state == TradeState.IDLE or state == TradeState.EARLY) and (lotoReady or confirmedReady)
        entryType = lotoReady ? "LOTO" : "CONFIRMED"
        
        // State transition: IDLE -> EARLY when price approaches entry level
        if state == TradeState.IDLE and approaching and isRTH and not isExpired and not earlyFired
            state := TradeState.EARLY
            earlyFired := true
            evt_early := true
        
        // State transition: IDLE/EARLY -> IN_TRADE when entry conditions are met
        if readyToEnter and not justExited
            returnWasFirstTrade := not hadTrade
            // Set entry price and calculate stop loss
            entryPrice := entryLevel
            stopOffset = entryLevel * (stopOffsetPct / 100)
            stopPrice := entryPrice - stopOffset
            // Calculate target levels: T1 (40%), T2 (60% = final target)
            targetDist = targetPrice - entryLevel
            t1Final := entryPrice + (targetDist * T1_PCT)
            t2Final := entryPrice + (targetDist * T2_PCT)
            entryMode := entryType
            entryBar := bar_index
            localGapPending := false
            hadTrade := true
            state := TradeState.IN_TRADE
            evt_entry := true
        
        // Target tracking: check if price has reached each target level (sequential)
        if state == TradeState.IN_TRADE and bar_index >= entryBar
            // T1 hit: first target reached
            if not t1Hit and not na(t1Final) and t1Final > 0 and tickerHigh >= t1Final
                t1Hit := true
                evt_t1 := true
            
            // T2 hit: final target reached, move stop to breakeven (T1 level) and exit trade
            if t1Hit and not t2Hit and not na(t2Final) and t2Final > 0 and tickerHigh >= t2Final
                t2Hit := true
                evt_t2 := true
                if not na(t1Final) and not na(stopPrice) and t1Final > stopPrice
                    stopPrice := t1Final
                state := TradeState.EXITED
        
        // Stop loss: exit if price drops below stop level
        if state == TradeState.IN_TRADE and bar_index >= entryBar and not na(stopPrice) and tickerLow <= stopPrice
            state := TradeState.EXITED
            evt_stop := true
        
        // Force exit: expiry or time-based exit (near market close for 0DTE/1DTE)
        if state == TradeState.IN_TRADE and (isExpired or forceExit)
            state := TradeState.EXITED
            evt_forceExit := true
        
        // State transition: EXITED -> IDLE (reset target flags, allow re-entry)
        if justExited
            t1Hit := false
            t2Hit := false
            state := TradeState.IDLE
        
        // State transition: EARLY -> IDLE if price drops significantly below early alert level
        dropThreshold = entryLevel * (DROP_THRESHOLD / 100)
        if state == TradeState.EARLY and tickerClose < earlyLevelPrice - dropThreshold
            state := TradeState.IDLE
            earlyFired := false
        
        // Persist state and trade data back to arrays
        array.set(stateArr, tickerIdx, state)
        array.set(entryModeArr, tickerIdx, entryMode)
        array.set(entryBarArr, tickerIdx, entryBar)
        array.set(entryPriceArr, tickerIdx, entryPrice)
        array.set(stopPriceArr, tickerIdx, stopPrice)
        array.set(t1FinalArr, tickerIdx, t1Final)
        array.set(t2FinalArr, tickerIdx, t2Final)
        array.set(t1HitArr, tickerIdx, t1Hit)
        array.set(t2HitArr, tickerIdx, t2Hit)
        array.set(earlyFiredArr, tickerIdx, earlyFired)
        array.set(gapPendingArr, tickerIdx, localGapPending)
        array.set(hadTradeArr, tickerIdx, hadTrade)
        
        returnEntryMode := entryMode
        returnEntryPrice := entryPrice
        returnStopPrice := stopPrice
        returnT1 := t1Final
        returnT2 := t2Final
    
    [evt_early, evt_entry, evt_t1, evt_t2, evt_stop, evt_gapPend, evt_forceExit, returnEntryMode, returnEntryPrice, returnStopPrice, returnT1, returnT2, returnDte, returnPrice, returnWasFirstTrade]

// Parse expiry dates for all tickers
t1_expTs = parseExp(t1_exp)
t2_expTs = parseExp(t2_exp)
t3_expTs = parseExp(t3_exp)
t4_expTs = parseExp(t4_exp)
t5_expTs = parseExp(t5_exp)

// Initialize state arrays for all 5 tickers
var stateArr = array.new<TradeState>(5, TradeState.IDLE)
var string[] entryModeArr = array.new_string(5, "")
var int[] entryBarArr = array.new_int(5, na)
var float[] entryPriceArr = array.new_float(5, na)
var float[] stopPriceArr = array.new_float(5, na)
var float[] t1FinalArr = array.new_float(5, na)
var float[] t2FinalArr = array.new_float(5, na)
var bool[] t1HitArr = array.new_bool(5, false)
var bool[] t2HitArr = array.new_bool(5, false)
var bool[] earlyFiredArr = array.new_bool(5, false)
var bool[] gapPendingArr = array.new_bool(5, false)
var bool[] hadTradeArr = array.new_bool(5, false)

// Reset all ticker states at start of each trading day
if ta.change(time("D", "America/New_York")) != 0
    for i = 0 to 4
        array.set(stateArr, i, TradeState.IDLE)
        array.set(entryModeArr, i, "")
        array.set(entryBarArr, i, na)
        array.set(entryPriceArr, i, na)
        array.set(stopPriceArr, i, na)
        array.set(t1FinalArr, i, na)
        array.set(t2FinalArr, i, na)
        array.set(t1HitArr, i, false)
        array.set(t2HitArr, i, false)
        array.set(earlyFiredArr, i, false)
        array.set(gapPendingArr, i, false)
        array.set(hadTradeArr, i, false)

// Process each ticker and generate events/alerts
[evt1_early, evt1_entry, evt1_t1, evt1_t2, evt1_stop, evt1_gapPend, evt1_forceExit, mode1, price1, stop1, t1_1, t2_1, dte1, cur1, first1] = processTicker(0, t1_on, t1_sym, t1_expTs, t1_res, t1_tgt, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, t1HitArr, t2HitArr, earlyFiredArr, gapPendingArr, hadTradeArr)

[evt2_early, evt2_entry, evt2_t1, evt2_t2, evt2_stop, evt2_gapPend, evt2_forceExit, mode2, price2, stop2, t1_2, t2_2, dte2, cur2, first2] = processTicker(1, t2_on, t2_sym, t2_expTs, t2_res, t2_tgt, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, t1HitArr, t2HitArr, earlyFiredArr, gapPendingArr, hadTradeArr)

[evt3_early, evt3_entry, evt3_t1, evt3_t2, evt3_stop, evt3_gapPend, evt3_forceExit, mode3, price3, stop3, t1_3, t2_3, dte3, cur3, first3] = processTicker(2, t3_on, t3_sym, t3_expTs, t3_res, t3_tgt, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, t1HitArr, t2HitArr, earlyFiredArr, gapPendingArr, hadTradeArr)

[evt4_early, evt4_entry, evt4_t1, evt4_t2, evt4_stop, evt4_gapPend, evt4_forceExit, mode4, price4, stop4, t1_4, t2_4, dte4, cur4, first4] = processTicker(3, t4_on, t4_sym, t4_expTs, t4_res, t4_tgt, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, t1HitArr, t2HitArr, earlyFiredArr, gapPendingArr, hadTradeArr)

[evt5_early, evt5_entry, evt5_t1, evt5_t2, evt5_stop, evt5_gapPend, evt5_forceExit, mode5, price5, stop5, t1_5, t2_5, dte5, cur5, first5] = processTicker(4, t5_on, t5_sym, t5_expTs, t5_res, t5_tgt, stateArr, entryModeArr, entryBarArr, entryPriceArr, stopPriceArr, t1FinalArr, t2FinalArr, t1HitArr, t2HitArr, earlyFiredArr, gapPendingArr, hadTradeArr)

// Alert processing function: sends alerts for trade events
processAlerts(sym, k, exp, evt_gapPend, evt_early, evt_entry, evt_t1, evt_t2, evt_stop, evt_forceExit, mode, entryLevel, price, stop, t1, t2, dte, cur, first) =>
    if evt_gapPend and isLiveBar and showWarningAlerts
        alert("[GAP PENDING] " + sym + " | $" + str.tostring(k, "#.##") + "C | Gapped above $" + str.tostring(entryLevel, "#.##") + " | Entry queued after cooldown", alert.freq_once_per_bar)
    
    if evt_early and isLiveBar
        alert("[EARLY] " + sym + " | $" + str.tostring(k, "#.##") + "C " + exp + " | Price $" + str.tostring(cur, "#.##") + " | Approaching $" + str.tostring(entryLevel, "#.##"), alert.freq_once_per_bar)
    
    // Entry alerts: LOTO always alerts (fast entries), CONFIRMED alerts on first trade or always
    if evt_entry and isLiveBar and (mode == "LOTO" or mode == "CONFIRMED" or first)
        alertMsg = "[" + mode + "] " + sym + " | $" + str.tostring(k, "#.##") + "C " + exp + " (" + dteStr(dte) + ") | Entry $" + str.tostring(price, "#.##") + " | Stop $" + str.tostring(stop, "#.##") + " | T1 $" + str.tostring(t1, "#.##") + " | T2 $" + str.tostring(t2, "#.##")
        if mode == "LOTO"
            alert(alertMsg, alert.freq_once_per_bar)
        else
            alert(alertMsg, alert.freq_once_per_bar_close)
    
    if evt_t1 and isLiveBar
        alert("[T1 HIT] " + sym + " | $" + str.tostring(k, "#.##") + "C " + exp + " | Hit $" + str.tostring(t1, "#.##") + " | Next T2 $" + str.tostring(t2, "#.##"), alert.freq_once_per_bar)
    
    if evt_t2 and isLiveBar
        alert("[TARGET] " + sym + " | $" + str.tostring(k, "#.##") + "C " + exp + " | Hit $" + str.tostring(t2, "#.##") + " | CLOSE POSITION | Mode: " + mode, alert.freq_once_per_bar)
    
    if evt_stop and isLiveBar
        alert("[STOP] " + sym + " | $" + str.tostring(k, "#.##") + "C " + exp + " | Stopped $" + str.tostring(stop, "#.##") + " | Mode: " + mode, alert.freq_once_per_bar)
    
    if evt_forceExit and isLiveBar
        alert("[FORCE EXIT] " + sym + " | $" + str.tostring(k, "#.##") + "C " + exp + " | EXIT NOW - Market closing", alert.freq_once_per_bar)

processAlerts(t1_sym, t1_k, t1_exp, evt1_gapPend, evt1_early, evt1_entry, evt1_t1, evt1_t2, evt1_stop, evt1_forceExit, mode1, t1_res, price1, stop1, t1_1, t2_1, dte1, cur1, first1)
processAlerts(t2_sym, t2_k, t2_exp, evt2_gapPend, evt2_early, evt2_entry, evt2_t1, evt2_t2, evt2_stop, evt2_forceExit, mode2, t2_res, price2, stop2, t1_2, t2_2, dte2, cur2, first2)
processAlerts(t3_sym, t3_k, t3_exp, evt3_gapPend, evt3_early, evt3_entry, evt3_t1, evt3_t2, evt3_stop, evt3_forceExit, mode3, t3_res, price3, stop3, t1_3, t2_3, dte3, cur3, first3)
processAlerts(t4_sym, t4_k, t4_exp, evt4_gapPend, evt4_early, evt4_entry, evt4_t1, evt4_t2, evt4_stop, evt4_forceExit, mode4, t4_res, price4, stop4, t1_4, t2_4, dte4, cur4, first4)
processAlerts(t5_sym, t5_k, t5_exp, evt5_gapPend, evt5_early, evt5_entry, evt5_t1, evt5_t2, evt5_stop, evt5_forceExit, mode5, t5_res, price5, stop5, t1_5, t2_5, dte5, cur5, first5)

// Label processing function: creates visual labels on chart for trade events
processLabels(sym, k, exp, evt_early, evt_entry, evt_t1, evt_t2, evt_stop, evt_forceExit, mode, entryLevel, price, stop, t1, t2, dte, first, match) =>
    if evt_early and match
        label.new(bar_index, high, "EARLY", style=label.style_label_down, color=color.new(color.yellow, 20), textcolor=color.black, size=size.small, tooltip="EARLY " + sym + " $" + str.tostring(k, "#.##") + "C | Approaching $" + str.tostring(entryLevel, "#.##"))
    
    if evt_entry and match
        lblText = mode == "LOTO" ? "LOTO" : "CONFIRMED"
        lblColor = mode == "LOTO" ? color.new(color.orange, 0) : color.new(color.green, 0)
        label.new(bar_index, low, lblText, style=label.style_label_up, color=lblColor, textcolor=color.white, size=size.small, tooltip="[" + mode + "] " + sym + " $" + str.tostring(k, "#.##") + "C " + dteStr(dte) + " | Entry $" + str.tostring(price, "#.##") + " | Stop $" + str.tostring(stop, "#.##") + " | T1 $" + str.tostring(t1, "#.##") + " | T2 $" + str.tostring(t2, "#.##"))
    
    if evt_t1 and match
        label.new(bar_index, high, "T1", style=label.style_label_down, color=color.new(color.blue, 20), textcolor=color.white, size=size.small, tooltip="T1 HIT " + sym + " | $" + str.tostring(t1, "#.##"))
    
    if evt_t2 and match
        label.new(bar_index, high, "TARGET", style=label.style_label_down, color=color.new(color.green, 0), textcolor=color.white, size=size.small, tooltip="TARGET " + sym + " | $" + str.tostring(t2, "#.##") + " | CLOSE")
    
    if evt_stop and match
        label.new(bar_index, low, "STOP", style=label.style_label_up, color=color.new(color.red, 0), textcolor=color.white, size=size.small, tooltip="STOP " + sym + " | $" + str.tostring(stop, "#.##"))
    
    if evt_forceExit and match
        label.new(bar_index, high, "EXIT", style=label.style_label_down, color=color.new(color.purple, 0), textcolor=color.white, size=size.small, tooltip="FORCE EXIT " + sym)

t1_match = showLabels and str.upper(t1_sym) == chartTicker
t2_match = showLabels and str.upper(t2_sym) == chartTicker
t3_match = showLabels and str.upper(t3_sym) == chartTicker
t4_match = showLabels and str.upper(t4_sym) == chartTicker
t5_match = showLabels and str.upper(t5_sym) == chartTicker

processLabels(t1_sym, t1_k, t1_exp, evt1_early, evt1_entry, evt1_t1, evt1_t2, evt1_stop, evt1_forceExit, mode1, t1_res, price1, stop1, t1_1, t2_1, dte1, first1, t1_match)
processLabels(t2_sym, t2_k, t2_exp, evt2_early, evt2_entry, evt2_t1, evt2_t2, evt2_stop, evt2_forceExit, mode2, t2_res, price2, stop2, t1_2, t2_2, dte2, first2, t2_match)
processLabels(t3_sym, t3_k, t3_exp, evt3_early, evt3_entry, evt3_t1, evt3_t2, evt3_stop, evt3_forceExit, mode3, t3_res, price3, stop3, t1_3, t2_3, dte3, first3, t3_match)
processLabels(t4_sym, t4_k, t4_exp, evt4_early, evt4_entry, evt4_t1, evt4_t2, evt4_stop, evt4_forceExit, mode4, t4_res, price4, stop4, t1_4, t2_4, dte4, first4, t4_match)
processLabels(t5_sym, t5_k, t5_exp, evt5_early, evt5_entry, evt5_t1, evt5_t2, evt5_stop, evt5_forceExit, mode5, t5_res, price5, stop5, t1_5, t2_5, dte5, first5, t5_match)

// Determine which entry/target lines to plot (only for matching ticker chart)
showT1Lines = showLevelLines and t1_on and t1_res > 0 and str.upper(t1_sym) == chartTicker
showT2Lines = showLevelLines and t2_on and t2_res > 0 and str.upper(t2_sym) == chartTicker
showT3Lines = showLevelLines and t3_on and t3_res > 0 and str.upper(t3_sym) == chartTicker
showT4Lines = showLevelLines and t4_on and t4_res > 0 and str.upper(t4_sym) == chartTicker
showT5Lines = showLevelLines and t5_on and t5_res > 0 and str.upper(t5_sym) == chartTicker

plot(showT1Lines ? t1_res : na, "T1 Entry", color=color.new(color.green, 40), linewidth=2, style=plot.style_linebr)
plot(showT1Lines ? t1_tgt : na, "T1 Target", color=color.new(color.green, 0), linewidth=2, style=plot.style_linebr)
plot(showT2Lines ? t2_res : na, "T2 Entry", color=color.new(color.green, 40), linewidth=2, style=plot.style_linebr)
plot(showT2Lines ? t2_tgt : na, "T2 Target", color=color.new(color.green, 0), linewidth=2, style=plot.style_linebr)
plot(showT3Lines ? t3_res : na, "T3 Entry", color=color.new(color.green, 40), linewidth=2, style=plot.style_linebr)
plot(showT3Lines ? t3_tgt : na, "T3 Target", color=color.new(color.green, 0), linewidth=2, style=plot.style_linebr)
plot(showT4Lines ? t4_res : na, "T4 Entry", color=color.new(color.green, 40), linewidth=2, style=plot.style_linebr)
plot(showT4Lines ? t4_tgt : na, "T4 Target", color=color.new(color.green, 0), linewidth=2, style=plot.style_linebr)
plot(showT5Lines ? t5_res : na, "T5 Entry", color=color.new(color.green, 40), linewidth=2, style=plot.style_linebr)
plot(showT5Lines ? t5_tgt : na, "T5 Target", color=color.new(color.green, 0), linewidth=2, style=plot.style_linebr)

// Helper function: format time component with leading zero
formatTimeComponent(val) => (val < 10 ? "0" : "") + str.tostring(val)

// Check if current chart matches any enabled ticker
anyTickerMatches = (t1_on and str.upper(t1_sym) == chartTicker) or (t2_on and str.upper(t2_sym) == chartTicker) or (t3_on and str.upper(t3_sym) == chartTicker) or (t4_on and str.upper(t4_sym) == chartTicker) or (t5_on and str.upper(t5_sym) == chartTicker)

// Display config lock timestamp on chart
var label configLockLabel = na
string configLockLabelText = "LOCKED AT : " + formatTimeComponent(month(configLockTime)) + "-" + formatTimeComponent(dayofmonth(configLockTime)) + " " + formatTimeComponent(hour(configLockTime)) + ":" + formatTimeComponent(minute(configLockTime)) + ":" + formatTimeComponent(second(configLockTime))

if anyTickerMatches and barstate.islast
    label.delete(configLockLabel)
    configLockLabel := label.new(bar_index, high, configLockLabelText, style = label.style_label_upper_right, color = color.new(color.blue, 70), textcolor = color.white, size = size.small)
